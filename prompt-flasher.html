<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>prompt-flasher</title>
  <style>
    :root{
      --fg: rgba(35,20,35,0.92);
      --ui: rgba(35,20,35,0.70);
      --ui3: rgba(35,20,35,0.22);

      --barH: 190px;
      --textScale: 1;
      --yPct: 45%;

      --phraseW: min(1180px, 92vw);
      --edgePad: 50px;

      --barOffset: 100px; /* requested: bottom should be 100px (not -100px) */

      /* requested: make UI text/buttons 5% larger without changing layout */
      --uiScale: 1.05;
    }

    html, body{
      margin:0; padding:0;
      width:100%; height:100%;
      overflow:hidden;
      background:#F7C6D0;
      font-family: Georgia, "Times New Roman", serif;
    }

    #stage{ position: fixed; inset: 0; pointer-events:none; }

    #phrase{
      position:absolute;
      left:50%;
      top: var(--yPct);
      transform: translate(-50%, -50%);
      font-weight: 560;
      font-size: calc(clamp(32px, 5vw, 84px) * var(--textScale));
      line-height:1.14;
      letter-spacing:.2px;
      user-select:none;

      width: var(--phraseW);
      max-width: calc(100vw - (var(--edgePad) * 2));
      text-align:center;

      white-space: normal;
      overflow-wrap: normal;
      word-break: normal;
      hyphens: none;

      overflow: visible;
    }

    /* UI: prefer bottom offset of 100px, but clamp so it never gets cropped on short viewports */
    #bar{
      position: fixed;
      left:0; right:0;
      bottom: max(0px, min(var(--barOffset), calc(100vh - var(--barH) - 8px)));
      height: var(--barH);
      padding: 0 10px calc(10px + env(safe-area-inset-bottom, 0px));
      box-sizing:border-box;
      pointer-events:auto;

      background: transparent;
      transition: opacity .18s ease, transform .18s ease;
    }
    #bar.hidden{
      opacity:0;
      transform: translateY(10px);
      pointer-events:none;
    }

    .barInner{
      padding-top: 30px;
      display:flex;
      flex-direction:column;
      gap:10px;
      height:100%;
      box-sizing:border-box;
      overflow: visible;
    }

    .topRow{
      display:flex;
      gap:10px;
      align-items:flex-end;
      flex-wrap:nowrap;
      min-width:0;
    }

    .grp{
      display:flex;
      flex-direction:column;
      gap:4px;
      min-width:0;
      flex: 1 1 auto;
    }

    .grp.tone{ flex: 1.45 1.45 0; }
    .grp.word{ flex: 0.85 0.85 0; }
    .grp.context{ flex: 0.85 0.85 0; }
    .grp.parts{ flex: 0.95 0.95 0; }
    .grp.colors{ flex: 1.05 1.05 0; }

    .label{
      font-size: calc(9px * var(--uiScale));
      letter-spacing:.10em;
      text-transform:uppercase;
      color: var(--ui);
      user-select:none;
      line-height:1;
      opacity:.82;
      display:block;
    }

    .btnGroup{
      display:flex;
      flex-wrap:wrap;
      gap:4.5px;
      align-items:center;
      min-width:0;
      overflow: visible;
      max-height: none;
    }

    button{
      font: inherit;
      font-weight: 600;
      font-size: calc(7.1px * var(--uiScale));
      letter-spacing: .10em;
      text-transform: uppercase;
      color: var(--ui);
      background: transparent;
      border: 1px solid var(--ui3);
      border-radius: 999px;
      padding: calc(3.75px * var(--uiScale)) calc(6px * var(--uiScale));
      cursor: pointer;
      line-height: 1;
      user-select: none;
      white-space: nowrap;
      transition: transform .05s ease, border-color .15s ease, color .15s ease;
    }
    button:active{ transform: translateY(1px); }

    /* requested: hover and active use phrase color for BOTH text and outline */
    button:hover{
      color: var(--fg);
      border-color: var(--fg);
    }
    button.active{
      color: var(--fg);
      border-color: var(--fg);
      border-width: 1.5px;
    }

    .rightCol{
      display:flex;
      flex-direction:column;
      gap:6px;
      align-items:flex-end;
      flex: 0 0 auto;
      padding-left: 6px;
    }

    .sliderRow{
      display:flex;
      gap:12px;
      align-items:flex-end;
      flex-wrap:nowrap;
      min-width:0;
    }
    .ctrl{
      flex: 1 1 0;
      display:flex;
      flex-direction:column;
      gap:4px;
      min-width:0;
    }
    input[type=range]{
      appearance:none;
      width:100%;
      height:16px;
      background:transparent;
      color: var(--fg);
      margin:0;
      padding:0;
      touch-action: none;
    }
    input[type=range]::-webkit-slider-runnable-track{
      height:2px;
      background:var(--ui3);
      border-radius:999px;
    }
    input[type=range]::-moz-range-track{
      height:2px;
      background:var(--ui3);
      border-radius:999px;
    }
    input[type=range]::-webkit-slider-thumb{
      appearance:none;
      width:10px; height:10px;
      border-radius:50%;
      background: currentColor;
      margin-top:-4px;
    }
    input[type=range]::-moz-range-thumb{
      width:10px; height:10px;
      border-radius:50%;
      background: currentColor;
      border:0;
    }

    @media(max-width: 980px){
      :root{ --barH: 250px; }
      .topRow{ flex-wrap:wrap; }
      .sliderRow{ flex-wrap:wrap; }
      .rightCol{ flex-direction:row; align-items:center; }
    }

    @media(max-width: 640px){
      :root{ --barH: 280px; }
      #phrase{ font-size: calc(clamp(28px, 7vw, 64px) * var(--textScale)); }
      button{
        font-size: calc(6.8px * var(--uiScale));
        padding: calc(3.6px * var(--uiScale)) calc(5.3px * var(--uiScale));
      }
      .label{ font-size: calc(8.5px * var(--uiScale)); }
      .btnGroup{ gap:4px; }
    }
  </style>
</head>

<body>
  <div id="stage">
    <div id="phrase"></div>
  </div>

  <div id="bar">
    <div class="barInner">
      <div class="topRow">
        <div class="grp tone">
          <div class="label">Tone</div>
          <div class="btnGroup" id="toneRow"></div>
        </div>

        <div class="grp word">
          <div class="label">Word</div>
          <div class="btnGroup" id="wordRow"></div>
        </div>

        <div class="grp context">
          <div class="label">Context</div>
          <div class="btnGroup" id="contextRow"></div>
        </div>

        <div class="grp parts">
          <div class="label">Parts</div>
          <div class="btnGroup" id="partsRow"></div>
        </div>

        <div class="grp colors">
          <div class="label">Colors (BG)</div>
          <div class="btnGroup" id="bgColorsRow"></div>
          <div class="label" style="margin-top:6px;">Colors (Text)</div>
          <div class="btnGroup" id="fgColorsRow"></div>
        </div>

        <div class="rightCol">
          <button id="resetBtn" type="button">Reset</button>
          <button id="fsBtn" type="button">Full screen</button>
        </div>
      </div>

      <div class="sliderRow">
        <div class="ctrl">
          <div class="label">Speed</div>
          <input id="speedSlider" type="range" min="0.25" max="10" step="0.05" value="1.5">
        </div>
        <div class="ctrl">
          <div class="label">Size</div>
          <input id="sizeSlider" type="range" min="20" max="140" step="1" value="100">
        </div>
        <div class="ctrl">
          <div class="label">Height</div>
          <input id="ySlider" type="range" min="0" max="100" step="1" value="45">
        </div>
        <div class="ctrl">
          <div class="label">Width</div>
          <input id="widthSlider" type="range" min="0" max="1" step="0.01" value="0.75">
        </div>

        <div class="ctrl">
          <div class="label">BG Bright</div>
          <input id="bgBrightSlider" type="range" min="0" max="1" step="0.01" value="0.5">
        </div>
        <div class="ctrl">
          <div class="label">Text Bright</div>
          <input id="fgBrightSlider" type="range" min="0" max="1" step="0.01" value="0.5">
        </div>
      </div>
    </div>
  </div>

<script>
function uniq(arr){
  const s = new Set();
  for(const x of arr){
    const v = String(x || "").trim().replace(/\s+/g," ");
    if(v) s.add(v);
  }
  return Array.from(s);
}
function rand(arr){ return arr[(Math.random()*arr.length) | 0]; }
function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
function lerp(a,b,t){ return a + (b-a)*t; }

/* ===== Controls ===== */
const TONE_OPTS = ["sublime","positive","neutral","negative","bleak","ennui","funny"];
const WORD_OPTS = ["common","obscure"];
const CONTEXT_OPTS = ["home","work","fun"];
const COLOR_OPTS = ["circus","beachy","fleshy","earthy","retro","future"];
const PART_OPTS = ["description","object","action","location"];

/* DEFAULT: ALL buttons selected on load */
const sel = {
  tone: new Set(TONE_OPTS),
  word: new Set(WORD_OPTS),
  context: new Set(CONTEXT_OPTS),
  bgColor: new Set(COLOR_OPTS),
  fgColor: new Set(COLOR_OPTS),
  parts: new Set(PART_OPTS)
};

/* ===== Palettes (locked) ===== */
const PAL = {
  circus: ["#FF6AD5","#FF8A00","#FF4D1A","#C85AE0","#FF007A"],
  beachy: ["#BDE8FF","#8FB2CF","#CBE7FF","#445F86","#74A8E8"],
  fleshy: ["#F7D59B","#F6B77D","#B7852F","#F7B59D","#E1780A"],
  future: ["#9EDB00","#C86AD6","#F8C6A4","#B23A2B","#7FB1D9"],
  retro:  ["#DDE6B7","#00AEB0","#D85A10","#B10D33","#F6A623"],
  earthy: ["#A7B827","#D79A16","#536A00","#6F8A1A","#806200"]
};

/* ===== Color helpers ===== */
function hexToRgb(hex){
  const h = hex.replace("#","").trim();
  const full = h.length === 3 ? h.split("").map(c=>c+c).join("") : h;
  const n = parseInt(full,16);
  return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
}
function rgbToHex(r,g,b){
  const to = (v)=> v.toString(16).padStart(2,"0");
  return "#" + to(r) + to(g) + to(b);
}
function rgbToHsl(r,g,b){
  r/=255; g/=255; b/=255;
  const max = Math.max(r,g,b), min = Math.min(r,g,b);
  let h=0, s=0;
  const l = (max+min)/2;
  const d = max-min;
  if(d !== 0){
    s = d / (1 - Math.abs(2*l - 1));
    switch(max){
      case r: h = ((g-b)/d) % 6; break;
      case g: h = (b-r)/d + 2; break;
      case b: h = (r-g)/d + 4; break;
    }
    h *= 60;
    if(h < 0) h += 360;
  }
  return {h, s, l};
}
function hslToRgb(h,s,l){
  const c = (1 - Math.abs(2*l - 1)) * s;
  const x = c * (1 - Math.abs(((h/60) % 2) - 1));
  const m = l - c/2;
  let rp=0,gp=0,bp=0;

  if(0<=h && h<60){ rp=c; gp=x; bp=0; }
  else if(60<=h && h<120){ rp=x; gp=c; bp=0; }
  else if(120<=h && h<180){ rp=0; gp=c; bp=x; }
  else if(180<=h && h<240){ rp=0; gp=x; bp=c; }
  else if(240<=h && h<300){ rp=x; gp=0; bp=c; }
  else { rp=c; gp=0; bp=x; }

  return {
    r: Math.round((rp+m)*255),
    g: Math.round((gp+m)*255),
    b: Math.round((bp+m)*255)
  };
}
function setHsl(hex, h, s, l){
  const out = hslToRgb(h, s, l);
  return rgbToHex(out.r,out.g,out.b);
}
function relativeLuma(hex){
  const {r,g,b} = hexToRgb(hex);
  const f = (u)=>{
    u/=255;
    return (u<=0.03928) ? u/12.92 : Math.pow((u+0.055)/1.055, 2.4);
  };
  const R=f(r), G=f(g), B=f(b);
  return 0.2126*R + 0.7152*G + 0.0722*B;
}
function contrastRatio(aHex,bHex){
  const L1 = relativeLuma(aHex);
  const L2 = relativeLuma(bHex);
  const hi = Math.max(L1,L2), lo = Math.min(L1,L2);
  return (hi+0.05)/(lo+0.05);
}

/* Dimmer-style brightness:
   - slider 0.5 => EXACT palette
   - left => darker (same hue)
   - right => brighter + more vibrant (same hue)
   - moving slider never changes the phrase; only re-renders current bg/text colors. */
function applyDimmer(hex, t){
  t = clamp(Number(t), 0, 1);
  const {r,g,b} = hexToRgb(hex);
  let {h,s,l} = rgbToHsl(r,g,b);

  if(t === 0.5) return hex;

  if(t < 0.5){
    const k = (0.5 - t) / 0.5;         // 0..1
    const lMul = lerp(1.0, 0.42, k);   // darken
    l = clamp(l * lMul, 0.08, 0.90);
    s = clamp(s * lerp(1.0, 1.10, k), 0.18, 0.98);
  }else{
    const k = (t - 0.5) / 0.5;         // 0..1
    l = clamp(l + (1 - l) * (0.33 * k), 0.08, 0.92);
    s = clamp(s * lerp(1.0, 1.28, k), 0.18, 0.98);
  }

  return setHsl(hex, h, s, l);
}

/* Contrast helper (does NOT override the brightness slider).
   - Starts from the already-dimmed fg.
   - Only nudges lightness if contrast is below target.
   - Keeps hue/sat. */
function nudgeForContrast(bg, fg){
  if(!bg || !fg) return fg;
  const target = 4.5;

  const bgL = relativeLuma(bg);
  const REALLY_DARK_BG = 0.22;

  let out = fg;
  let tries = 0;

  while(contrastRatio(bg, out) < target && tries < 26){
    const {r,g,b} = hexToRgb(out);
    let {h,s,l} = rgbToHsl(r,g,b);

    if(bgL < REALLY_DARK_BG) l = clamp(l + 0.055, 0.04, 0.96);
    else l = clamp(l - 0.055, 0.04, 0.96);

    out = setHsl(out, h, s, l);
    tries++;
  }

  return out;
}

/* ===== Phrase generator ===== */
const DESC_COMMON = uniq([
  "brittle","woolen","velvety","ashen","glowing","aggressive","ambiguous","antique","architectural",
  "baggy","beefy","bent","brassy","brilliant","bumpy","burnt","buttery","buzzing",
  "charming","crumbly","crunchy","crushed","crusty","crying",
  "drafty","dreamy","dusty",
  "feathery","flashy","flavorful","fleshy","foggy","foamy","frosted","frowning","fruity","fried","furry",
  "gentle","ghostly","gigantic","giggling","girly","greasy","greedy","guilty",
  "hard","hungry","happy","jealous","joyful","jazzy","jiggly","junky",
  "leisurely","lively","messy","moldy","mysterious","nervous","oily","orderly","ornamental",
  "painted","pearly","pillowy","poetic","poignant","polished","powdery",
  "ribbed","risky","rocky","rotating",
  "salty","sandy","scrambled","sculpted","sculptural","slimy","slippery","smelly","smoggy","sneaky",
  "soft","stormy","strange","strappy","sweet",
  "thick","thirsty","windy","worried","wrapped",
  "sweaty","sunset","daybreak","elevated","elongated","smooth","bloated","curly","twisted","wiggly",
  "burnished","reclusive","exploratory","introverted",
  "dingy","patched","repaired","tarnished","dented","angled","tilted","distorted","skewed","melted","enlarged","engorged",
  "moist","dewy","plump","buff","extended","compact","oversized","skimpy",
  "malaise","ennui","weary","blasé","disenchanted","disaffected","detached","existential","indifferent","futile","flaneur",
  "vivacious","zestful","vigorous","verve","élan","immersed","flowing","delighted","radiant","witty","fulfilled","buoyant","spontaneous","lighthearted","ecstatic",
  "attentive","subtle","nuanced","deft","precise","helpful","perceptive","evocative","suggestive",
  "sparkly","glittery","crusted","scabbed",
  "loud","silent","muffled","enrobed",
  "wet","damp","dry","cracked","ashy",
  "spilt","spoiled","rotten","fresh","growing","withering",
  "elegant","crude","muscular","lean","long","short","tall","fat","thin","slim","chubby",
  "cute","ugly","beautiful","attractive","contrasting","contrary",
  "hairy","bald","shaved","stubbly","rough","matte","glossy",
  "inverted",

  /* additions (normalized so they work before a noun) */
  "refined","understated","restrained","poised","subtle","tailored","classical",
  "grand","petite","polished","considered","ritualistic","witchy",
  "dried out","toweled off","lumpy","mindful","civilized","unhurried","guarded",
  "formal","discreet","reserved","confident",
  "diaphanous","opalescent","iridescent","mother-of-pearl","inlaid",
  "sunken","padded","carpeted",
  "glowering","sullen","beaming","unctuous","supple","ungulating","waving","wiggling","undulating",
  "sycophantic","ubiquitous","obsequious",
  "dulcet","flickering","fugitive","illegal","insular","capitulating",
  "flying","soaring","limpid","smoky","atonal","hushed","muted",
  "esoteric","arcane","hermetic","cryptic",
  "languid","listless","wistful","pensive","yearning","plaintive","ethereal","reflective",
  "longing","tender","gentle","aching","mournful","downcast",
  "faded","vibrant","nostalgic","reminiscent","unspoken","unrequited",
  "deferential","accepting","tempered","subdued","settled","composed","veiled",
  "effervescent","dusky","dank","dim","rueful",
  "balanced","effortlessly arranged","nonchalantly placed","pure","tasteful","delicate","proportional",
  "gracefully arranged","lightly worn","tenderly handled","gently used",

  /* materials/patterns as adjectives */
  "herringbone-patterned","walnut","mahogany","pine","maple",
  "stone","quartz","emerald","ruby","diamond",
  "granite","marble","soapstone","soapy"
]);

const DESC_OBSCURE = uniq([
  "effervescent","despondent","petulant","hedonistic","gluttonous",
  "malnourished","overflowing","puffy","bloated","skewed","tilted","melted","inverted",
  "thoughtful","breezy","terse","abandoned","vibrant","crowded","busy",
  "filled with dread","depressed","emotional","moody","imperfect","misaligned","transparent",
  "decaying","slippery","wiggly","twisted",

  /* extra niche-y/tonal additions */
  "diaphanous","opalescent","iridescent","mother-of-pearl","hermetic","cryptic","atonal","limpid",
  "unctuous","obsequious","sycophantic","fugitive","insular","plaintive","wistful","rueful"
]);

function pickDescriptor(tone, rarity){
  const pool = (rarity === "common") ? DESC_COMMON
             : (rarity === "obscure") ? uniq(DESC_OBSCURE.concat(DESC_COMMON.slice(0, 120)))
             : uniq(DESC_COMMON.concat(DESC_OBSCURE));

  const t = tone;

  if(t === "funny"){
    const funnyPool = uniq(["beefy","jiggly","jazzy","junky","brassy","bumpy","crumbly","crusty","giggling","puffy","bloated","wiggly"])
      .filter(x => pool.includes(x));
    if(funnyPool.length) return rand(funnyPool);
  }
  if(t === "bleak" || t === "ennui" || t === "negative"){
    const bleakPool = uniq(["ashen","burnt","moldy","dusty","abandoned","despondent","filled with dread","depressed","crushed","rotten","decaying","downcast","rueful"])
      .filter(x => pool.includes(x));
    if(bleakPool.length) return rand(bleakPool);
  }
  if(t === "sublime" || t === "positive"){
    const upPool = uniq(["glowing","ghostly","effervescent","velvety","woolen","pearly","poignant","poetic","dreamy","frosted","ornamental","radiant","delighted","vivacious","opalescent","iridescent"])
      .filter(x => pool.includes(x));
    if(upPool.length) return rand(upPool);
  }
  return rand(pool);
}

const OBJ_HOME_COMMON = uniq([
  "dish rack","drying rack","clothes line","shower head","kitchen sink","vanity mirror","hair brush","toilet paper",
  "coffee mug","tea pot","tea bag","coffee maker","french press","percolator",
  "frying pan","cutting board","crock pot","soupspoon",
  "laundry basket,","laundry hamper","trash can","mop bucket","broom",
  "bed","mattress","book shelf","bookcase","curtains","doorknob","window","lamp","lampshade","clock","wrist watch",
  "cabinet","drawer","coffee table","ottoman","couch","love seat","chaise longue","cushion","throw pillow","duvet","comforter","wool blanket","fleece blanket","polar fleece",
  "bath tub","hot tub","jacuzzi",
  "lipstick","lip gloss","blush","makeup","nail polish","perfume bottle","deodorant","hair clip","hair tie",
  "high heels","tights","pantyhose","cardigan","turtleneck","necklaces","bracelet","wedding band","ring","pendant",
  "camp stove","grill","fire pit","fire place",
  "pizza box","pizza","mini fridge","refrigerator","oven","freezer","closet","hardwood floors","carpet","rug","upholstery",
  "remote control","computer monitor","ipad","tablet",

  /* additions */
  "wardrobe","drapery","portrait","trophy","moving boxes","linen napkin","room service tray","soap"
]);

const OBJ_WORK_COMMON = uniq([
  "computer monitor","keyboard","printer","xerox machine","photo copier","cash register",
  "envelope","notebook","dictionary","novel","paperback book",
  "workbench","sawhorse","chisel","paint brush","spray paint","ink wash","canvas","plywood","ladder","toolbox","tape measure","scissors",
  "drill press","table saw","bandsaw","vacuum cleaner","hot glue gun","dental pick","drill",
  "office cubicle","lecture hall","waiting room","doctor's office","library","gallery","museum",
  "ATM",

  /* additions */
  "portrait","trophy","moving boxes"
]);

const OBJ_FUN_COMMON = uniq([
  "seltzer","waffle maker","diner booth","martini","cocktail","wine glass",
  "baguette","taqueria","dive bar","dance club","punk club","rave","comedy club","microphone","record store",
  "frisbee","playing cards","chess board","cribbage board","board game","video game","playstation",
  "slot machine","grand piano","pipe organ","drum kit","synthesizer",
  "bicycle","station wagon","hatch back","convertible","sports car","subaru forester",
  "house boat","castle","gazebo","palapa",
  "water slide","trailhead","switchback","mountain lodge","snow shoes","cross country skis","skis",
  "baseball bat","sword",

  /* additions */
  "harmonica","folded map","ticket stub","vinegar","pickled carrots","salsa verde"
]);

const OBJ_OBSCURE = uniq([
  "birdbath","birdcage","birdhouse","hourglass","sundial","pendulum","pocket watch",
  "velvet rope","bank vault","water tower","traffic median","airport shuttle",
  "dune buggy","dump truck","freight train","gondola",
  "greenhouse","terrarium",
  "record player","typewriter","ukulele","trombone","tambourine","saxophone","banjo","bagpipe",
  "brownstone","townhouse","alleyway","dumpster","manhole cover","sewer",
  "parking garage","parking lot","driveway",
  "parachute","bungee cord","propeller","umbrella",
  "cooler","cardboard box","tissue paper","newspaper","tombstone","baby bottle","maxi pad",

  /* additions */
  "deck chair","neon sign"
]);

const OBJECTS = {
  home: { common: OBJ_HOME_COMMON, obscure: uniq(OBJ_HOME_COMMON.concat(OBJ_OBSCURE)) },
  work: { common: OBJ_WORK_COMMON, obscure: uniq(OBJ_WORK_COMMON.concat(OBJ_OBSCURE)) },
  fun:  { common: OBJ_FUN_COMMON,  obscure: uniq(OBJ_FUN_COMMON.concat(OBJ_OBSCURE)) }
};

function pickObject(context, rarity){
  const bank = (rarity === "common") ? OBJECTS[context].common
             : (rarity === "obscure") ? OBJECTS[context].obscure
             : uniq(OBJECTS[context].common.concat(OBJECTS[context].obscure));
  return rand(bank);
}

const ACT_COMMON = uniq([
  "blowing in the wind","soaking wet","floating","stretched out","tilted","melted","inverted",
  "broken","misaligned","rusty","chunky","crusty",
  "laying in the grass","feet in the sand","wind in your hair","gentle breeze",

  /* additions (kept as verb-y / participle phrases so they attach cleanly) */
  "toweled off","dripping","folded neatly","left out overnight","cooling slightly","resting quietly","waiting in line"
]);

const ACT_OBSCURE = uniq([
  "dripping quietly","vibrating faintly","flickering softly","humming to itself","balanced on a ledge","half submerged","caught in the rain",
  "sparkling in sunlight","crusted over","patched up","freshly repaired",

  /* additions (scene-moments) */
  "zipping a suitcase slowly","resting your head against a train window","opening the shutters",
  "standing at the window while the city wakes","coffee cooling slightly before the first sip",
  "butter melting on warm toast","lighting a candle","blowing out a candle","applying perfume",
  "people watching","caught in summer rain","glowing under dappled light"
]);

function pickAction(rarity){
  if(rarity === "common") return rand(ACT_COMMON);
  if(rarity === "obscure") return rand(ACT_OBSCURE.concat(ACT_COMMON));
  return rand(ACT_COMMON.concat(ACT_OBSCURE));
}

const LOC_HOME = uniq([
  "in the bedroom","in the kitchen","in the bathroom","in the attic","on the balcony","in the backyard","in the driveway","in the apartment",

  /* additions */
  "in a spare bedroom","in a long-unused childhood bedroom","in a steamy bathroom","on a balcony chair"
]);

const LOC_WORK = uniq([
  "in the office","in the cubicle","in the workshop","in the studio","in the lecture hall","in the waiting room","in the doctor's office","in the library"
]);

const LOC_FUN = uniq([
  "at the beach","on the pier","in the swimming pool","in the mud puddle","on the sidewalk",
  "in a diner booth","at a dive bar","at a dance club","at a punk club","at a rave",
  "at a protest march","by the fire pit","at the farm stand","at the hardware store",
  "on the trail","on a dirt road","on a gravel road","at the trailhead",
  "in the amusement park","in the arcade",

  /* additions */
  "in an airport lounge","at a rooftop bar","in a mosh pit","in a boxing ring",
  "at a bus stop at dusk","on a winding coastal road","at a cafe table",
  "at a ferry terminal in fog","on an empty train platform"
]);

const LOC_OBSCURE = uniq([
  "under the overpass","in the parking garage","in the parking lot","at the waterfront","by the water tower","in the alleyway",
  "in a bog","at the catacombs","at the garbage dump",

  /* additions */
  "in an off-season seaside town","on an empty boardwalk","among folded deck chairs",
  "outside a closed movie theater","in an empty museum gallery","in an obsolete shopping mall",
  "in a shuttered movie theater","on side streets","in back stairwells","beneath a flickering neon sign",
  "on stone steps","on cobblestone","by a courtyard fountain","under overgrown vines","in a vineyard"
]);

function pickLocation(context, rarity){
  const base = (context === "home") ? LOC_HOME : (context === "work") ? LOC_WORK : LOC_FUN;
  if(rarity === "common") return rand(base);
  if(rarity === "obscure") return rand(base.concat(LOC_OBSCURE));
  return rand(base.concat(LOC_OBSCURE));
}

const recentSetP = new Set();
const recentQueue = [];
const RECENT_P = 180;

function rememberPhrase(p){
  recentQueue.push(p);
  recentSetP.add(p);
  if(recentQueue.length > RECENT_P){
    const old = recentQueue.shift();
    recentSetP.delete(old);
  }
}

function buildPhrase(parts, tone, rarity, context){
  const useDesc = parts.has("description");
  const useObj  = parts.has("object");
  const useAct  = parts.has("action");
  const useLoc  = parts.has("location");

  if(!useDesc && !useObj && !useAct && !useLoc) return "";

  let lastOut = "";

  for(let tries=0; tries<70; tries++){
    const desc = pickDescriptor(tone, rarity);
    const obj  = pickObject(context, rarity);
    const act  = pickAction(rarity);
    const loc  = pickLocation(context, rarity);

    let out = "";
    if(useDesc) out += desc + " ";
    if(useObj) out += obj;
    if(useAct) out += (out ? " " : "") + act;
    if(useLoc) out += (out ? " " : "") + loc;

    out = out.replace(/\s+/g," ").trim();
    if(out) lastOut = out;

    if(out && !recentSetP.has(out)){
      rememberPhrase(out);
      return out;
    }
  }

  if(lastOut){
    rememberPhrase(lastOut);
    return lastOut;
  }

  return pickDescriptor(tone, rarity);
}

/* ===== UI plumbing ===== */
const phraseEl = document.getElementById("phrase");
const barEl = document.getElementById("bar");

const speedEl = document.getElementById("speedSlider");
const sizeEl  = document.getElementById("sizeSlider");
const yEl     = document.getElementById("ySlider");
const widthEl = document.getElementById("widthSlider");
const bgBrightEl = document.getElementById("bgBrightSlider");
const fgBrightEl = document.getElementById("fgBrightSlider");

const resetBtn = document.getElementById("resetBtn");
const fsBtn = document.getElementById("fsBtn");

let timer = null;

/* Current base (exact palette swatches) — sliders only dim/brighten these */
const current = {
  bgFamily: null,
  bgBase: null,   // hex, or null if bg disabled => white
  fgFamily: null,
  fgBase: null,   // hex, or null if fg disabled => grey
  phrase: ""
};

/* Reset toggle behavior */
let resetAllOn = true;

/* Continuity preference for BG family */
let lastBgFamily = null;

/* Render button rows */
function renderGroup(containerId, opts, key){
  const row = document.getElementById(containerId);
  row.innerHTML = "";
  for(const opt of opts){
    const b = document.createElement("button");
    b.type = "button";
    b.textContent = opt;

    b.addEventListener("click", ()=>{
      if(sel[key].has(opt)) sel[key].delete(opt);
      else sel[key].add(opt);

      resetAllOn = true;

      syncButtons();
      evaluateAndRun();
      bumpUI();
    });

    row.appendChild(b);
  }
}

function isAllOff(){
  return (
    sel.tone.size === 0 &&
    sel.word.size === 0 &&
    sel.context.size === 0 &&
    sel.parts.size === 0 &&
    sel.bgColor.size === 0 &&
    sel.fgColor.size === 0
  );
}

/* If all buttons are deselected => WHITE page, grey UI, no flashing */
function setBlankMode(){
  document.body.style.background = "#FFFFFF";
  phraseEl.textContent = "";
  phraseEl.style.color = "#666666";
  document.documentElement.style.setProperty("--fg", "rgba(120,120,120,0.92)");
  document.documentElement.style.setProperty("--ui", "rgba(120,120,120,0.70)");
  document.documentElement.style.setProperty("--ui3", "rgba(120,120,120,0.22)");
}

/* Button styling */
function syncButtons(){
  const groups = [
    ["toneRow", "tone"],
    ["wordRow", "word"],
    ["contextRow", "context"],
    ["partsRow", "parts"],
    ["bgColorsRow", "bgColor"],
    ["fgColorsRow", "fgColor"]
  ];
  for(const [id, key] of groups){
    const row = document.getElementById(id);
    const buttons = [...row.querySelectorAll("button")];
    buttons.forEach(btn=>{
      const v = btn.textContent;
      btn.classList.toggle("active", sel[key].has(v));
    });
  }
}

/* Phrase width */
function applyPhraseWidth(){
  const t = clamp(Number(widthEl.value), 0, 1);
  const wMin = 140;
  const wMax = Math.max(260, window.innerWidth - 100);
  const w = Math.round(lerp(wMin, wMax, t));
  document.documentElement.style.setProperty("--phraseW", w + "px");
}

/* Sliders */
function applyTextScale(){
  document.documentElement.style.setProperty("--textScale", String(Number(sizeEl.value)/100));
}
function applyTextY(){
  document.documentElement.style.setProperty("--yPct", clamp(Number(yEl.value), 0, 100) + "%");
}

/* Choose a random swatch from a selected family */
function pickPaletteColor(family){
  const sw = PAL[family] || PAL.earthy;
  return rand(sw);
}

/* Choose BG family with continuity, but only from selected BG families */
function pickBgFamily(){
  const allowed = [...sel.bgColor];
  if(!allowed.length) return null;

  if(!lastBgFamily) return rand(allowed);
  if(allowed.includes(lastBgFamily) && Math.random() < 0.80) return lastBgFamily;

  const others = allowed.filter(f => f !== lastBgFamily);
  return others.length ? rand(others) : lastBgFamily;
}

/* (Re)pick base colors + phrase — ONLY on a tick (not on brightness slider) */
function pickNextBase(){
  if(sel.bgColor.size === 0){
    current.bgFamily = null;
    current.bgBase = null; // white
  }else{
    current.bgFamily = pickBgFamily();
    current.bgBase = pickPaletteColor(current.bgFamily);
    lastBgFamily = current.bgFamily;
  }

  const phraseEnabled =
    sel.parts.size > 0 &&
    sel.tone.size > 0 &&
    sel.word.size > 0 &&
    sel.context.size > 0;

  if(!phraseEnabled){
    current.phrase = "";
  }else{
    const tone = rand([...sel.tone]);
    const rarity = rand([...sel.word]);
    const ctx = rand([...sel.context]);
    current.phrase = buildPhrase(sel.parts, tone, rarity, ctx);
  }

  if(sel.fgColor.size === 0){
    current.fgFamily = null;
    current.fgBase = null; // grey
  }else{
    current.fgFamily = rand([...sel.fgColor]);
    current.fgBase = pickPaletteColor(current.fgFamily);
  }
}

/* Apply current base colors + dimmers (no phrase change) */
function applyCurrentColors(){
  if(isAllOff()){
    setBlankMode();
    return;
  }

  let bg = "#FFFFFF";
  if(current.bgBase){
    bg = applyDimmer(current.bgBase, bgBrightEl.value);
  }
  document.body.style.background = bg;

  let fg = "#666666";
  if(current.fgBase){
    fg = applyDimmer(current.fgBase, fgBrightEl.value);
  }
  if(current.bgBase && current.fgBase) fg = nudgeForContrast(bg, fg);

  phraseEl.style.color = fg;
  phraseEl.textContent = current.phrase || "";

  if(isAllOff()){
    setBlankMode();
  }else{
    const ui = "rgba(35,20,35,0.70)";
    const ui3 = "rgba(35,20,35,0.22)";
    document.documentElement.style.setProperty("--fg", fg);
    document.documentElement.style.setProperty("--ui", current.bgBase ? ui : "rgba(120,120,120,0.70)");
    document.documentElement.style.setProperty("--ui3", current.bgBase ? ui3 : "rgba(120,120,120,0.22)");
  }
}

/* Tick */
function tick(){
  if(isAllOff()){
    setBlankMode();
    return;
  }

  const bgEnabled = sel.bgColor.size > 0;
  const phraseEnabled =
    sel.parts.size > 0 &&
    sel.tone.size > 0 &&
    sel.word.size > 0 &&
    sel.context.size > 0;

  if(!bgEnabled && !phraseEnabled){
    document.body.style.background = "#FFFFFF";
    phraseEl.textContent = "";
    phraseEl.style.color = "#666666";
    document.documentElement.style.setProperty("--fg", "rgba(120,120,120,0.92)");
    document.documentElement.style.setProperty("--ui", "rgba(120,120,120,0.70)");
    document.documentElement.style.setProperty("--ui3", "rgba(120,120,120,0.22)");
    return;
  }

  pickNextBase();
  applyCurrentColors();
}

/* Timing */
function restart(){
  if(timer) clearInterval(timer);

  if(isAllOff()){
    timer = null;
    setBlankMode();
    return;
  }

  const bgEnabled = sel.bgColor.size > 0;
  const phraseEnabled =
    sel.parts.size > 0 &&
    sel.tone.size > 0 &&
    sel.word.size > 0 &&
    sel.context.size > 0;

  if(!bgEnabled && !phraseEnabled){
    timer = null;
    document.body.style.background = "#FFFFFF";
    phraseEl.textContent = "";
    phraseEl.style.color = "#666666";
    document.documentElement.style.setProperty("--fg", "rgba(120,120,120,0.92)");
    document.documentElement.style.setProperty("--ui", "rgba(120,120,120,0.70)");
    document.documentElement.style.setProperty("--ui3", "rgba(120,120,120,0.22)");
    return;
  }

  const ms = Math.max(120, Number(speedEl.value) * 1000);
  timer = setInterval(tick, ms);
}

function evaluateAndRun(){
  /* prevent stale bases when palettes are emptied quickly */
  if(sel.bgColor.size === 0){ current.bgFamily = null; current.bgBase = null; }
  if(sel.fgColor.size === 0){ current.fgFamily = null; current.fgBase = null; }

  if(isAllOff()){
    restart();
    return;
  }

  const needsBase =
    (sel.bgColor.size > 0 && !current.bgBase) ||
    (sel.fgColor.size > 0 && !current.fgBase) ||
    ((sel.parts.size > 0 && sel.tone.size > 0 && sel.word.size > 0 && sel.context.size > 0) && !current.phrase);

  if(needsBase) pickNextBase();
  applyCurrentColors();
  restart();
}

/* Slider handlers */
speedEl.addEventListener("input", ()=> { restart(); bumpUI(); });
sizeEl.addEventListener("input", ()=> { applyTextScale(); bumpUI(); });
yEl.addEventListener("input", ()=> { applyTextY(); bumpUI(); });
widthEl.addEventListener("input", ()=> { applyPhraseWidth(); bumpUI(); });

bgBrightEl.addEventListener("input", ()=> { applyCurrentColors(); bumpUI(); });
fgBrightEl.addEventListener("input", ()=> { applyCurrentColors(); bumpUI(); });

/* Reset toggle */
resetBtn.addEventListener("click", ()=>{
  if(resetAllOn){
    sel.tone.clear();
    sel.word.clear();
    sel.context.clear();
    sel.parts.clear();
    sel.bgColor.clear();
    sel.fgColor.clear();
    resetAllOn = false;

    syncButtons();
    restart();
    bumpUI();
    return;
  }

  sel.tone = new Set(TONE_OPTS);
  sel.word = new Set(WORD_OPTS);
  sel.context = new Set(CONTEXT_OPTS);
  sel.parts = new Set(PART_OPTS);
  sel.bgColor = new Set(COLOR_OPTS);
  sel.fgColor = new Set(COLOR_OPTS);
  resetAllOn = true;

  syncButtons();
  pickNextBase();
  applyCurrentColors();
  restart();
  bumpUI();
});

/* Fullscreen */
fsBtn.addEventListener("click", async ()=>{
  bumpUI();
  try{
    if(!document.fullscreenElement) await document.documentElement.requestFullscreen();
    else await document.exitFullscreen();
  }catch(e){}
  fsBtn.textContent = document.fullscreenElement ? "Exit full" : "Full screen";
});
document.addEventListener("fullscreenchange", ()=>{
  fsBtn.textContent = document.fullscreenElement ? "Exit full" : "Full screen";
});

/* Auto-hide UI after 5s */
let hideT = null;
function scheduleHide(){
  if(hideT) clearTimeout(hideT);
  hideT = setTimeout(()=> barEl.classList.add("hidden"), 5000);
}
function bumpUI(){
  barEl.classList.remove("hidden");
  scheduleHide();
}
["mousemove","mousedown","keydown","touchstart","wheel"].forEach(evt=>{
  window.addEventListener(evt, bumpUI, {passive:true});
});

/* Mount */
renderGroup("toneRow", TONE_OPTS, "tone");
renderGroup("wordRow", WORD_OPTS, "word");
renderGroup("contextRow", CONTEXT_OPTS, "context");
renderGroup("partsRow", PART_OPTS, "parts");
renderGroup("bgColorsRow", COLOR_OPTS, "bgColor");
renderGroup("fgColorsRow", COLOR_OPTS, "fgColor");

(function init(){
  phraseEl.textContent = "";
  applyTextScale();
  applyTextY();
  applyPhraseWidth();

  syncButtons();
  pickNextBase();
  applyCurrentColors();
  restart();
  bumpUI();
})();
window.addEventListener("resize", applyPhraseWidth);
</script>
</body>
</html>