
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#F7C6D0" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>Sculpture Poems by Margot DeMarco</title>

  <style>
    :root{
      --fg: rgba(0,0,0,0.92);
      --ui: rgba(0,0,0,0.72);
      --ui3: rgba(0,0,0,0.20);
      --vh: 1vh;

      /* UI sizing */
      --barH: clamp(175px, 21vh, 240px);
      --barOffset: 40px;

      /* slight scale that doesn't break layout */
      --uiScale: 1.02;

      /* Phrase layout */
      --textScale: 1;
      --fitScale: 1;
      --sceneZoom: 1;
      --yPct: 50%;
      --phraseW: 75vw;
      --edgePad: 50px;

      /* Sentence-structure pill sizing */
      --pillH: 16px;
      --pillPadX: 10px;
      --pillFont: 7.1px;

      /* Swatches */
      --swOuter: 1px;
      --swRing: 4px;
      --swW: calc(var(--pillH) * 2);
      --uiGlobalScale: 0.9;
      --menuTextSize: calc(14px * 1.15 * 1.05 * 1.1 * var(--uiGlobalScale));

      /* Global UI padding */
      --uiPadX: 30px;

      /* UI lane */
      --uiMaxW: 1120px;
      --uiW: min(
        var(--uiMaxW),
        calc(
          100vw
          - (var(--uiPadX) * 2)
          - env(safe-area-inset-left, 0px)
          - env(safe-area-inset-right, 0px)
        )
      );

      --titlePadTop: 18px;
    }

    *{ box-sizing:border-box; }

    html, body{
      margin:0; padding:0;
      width:100%;
      height:100%;
      overflow:hidden;
      background:#F7C6D0;
      font-family: "Times New Roman", Times, Georgia, serif;
      -webkit-text-size-adjust: 100%;
    }

    body{ min-height: calc(var(--vh, 1vh) * 100); }

    /* Stage above border, below UI */
    #stage{
      position: fixed;
      top:0; left:0;
      width:100vw;
      height: calc(var(--vh, 1vh) * 100);
      pointer-events:auto;
      touch-action: none;
      z-index: 20;
    }

    #phrase{
      position:absolute;
      left:50%;
      top: var(--yPct);
      transform: translate(-50%, -50%);
      user-select:none;

      text-align:center;
      width: 100vw;
      max-width: 100vw;
      z-index: 25;
    }

    #phraseText{
      display:block;
      margin-left: auto;
      margin-right: auto;
      font-weight: 650;
      font-size: calc(clamp(32px, 5vw, 92px) * var(--textScale) * var(--fitScale) * var(--sceneZoom));
      line-height:1.12;
      letter-spacing:.2px;
      width: calc(var(--phraseW) * var(--sceneZoom));
      max-width: calc((100vw - (var(--edgePad) * 2)) * var(--sceneZoom));
      text-align:center;
      white-space: normal;
      overflow-wrap: normal;
      word-break: normal;
      hyphens: none;
    }

    /* Card behind phrase */
    #card{
      position:absolute;
      left:50%;
      top: var(--yPct);
      transform: translate(-50%, -50%);
      background: transparent;
      pointer-events: none;
      z-index: 10;
    }

    /* ===== UI wrapper (title + bar) ===== */
    #uiWrap{
      position: fixed;
      left:0; right:0;
      top:0; bottom:0;
      z-index: 30;
      pointer-events: none; /* bar re-enables */
      transition: opacity .18s ease, transform .18s ease;
    }
    #uiWrap.hidden{
      opacity:0;
      transform: translateY(10px);
    }
    #uiWrap.hidden #bar,
    #uiWrap.hidden #titleBlock{
      pointer-events: none;
    }

    /* Minimal entry point when UI is hidden. */
    #menuToggleBtn{
      position: fixed;
      left: 50%;
      bottom: calc(env(safe-area-inset-bottom, 0px) + 12px);
      transform: translateX(-50%);
      z-index: 80;
      width: calc(66px * 1.1 * var(--uiGlobalScale));
      height: calc(30px * 1.1 * var(--uiGlobalScale));
      border-radius: 0;
      padding: 0;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-size: var(--menuTextSize);
      font-weight: 650;
      line-height: 1;
      letter-spacing: .2px;
      text-transform: lowercase;
      background: var(--menuBg, rgba(0,0,0,0.12));
      color: var(--menuFg, var(--ui));
      border: none;
      outline: none;
      box-shadow: none;
      opacity: 0;
      pointer-events: none;
      transition: opacity .25s ease, transform .08s ease;
    }
    #menuToggleBtn.show{
      opacity: 1;
      pointer-events: auto;
    }
    #menuToggleBtn:active{
      transform: translateX(-50%) translateY(1px);
    }
    #menuToggleBtn:hover,
    #menuToggleBtn:focus-visible{
      opacity: 1;
    }
    #menuToggleBtn.on{
      opacity: 1;
      pointer-events: auto;
    }
    #menuToggleBtn.dock-focus{
      font-size: var(--menuTextSize);
    }
    #menuToggleBtn.dock-hover-focus{
      font-size: var(--menuTextSize);
    }
    @media (hover: hover) and (pointer: fine){
      #menuToggleBtn[data-tip]::after{
        content: attr(data-tip);
        position: absolute;
        left: 50%;
        bottom: calc(100% + 2px);
        transform: translateX(-50%);
        color: var(--cardUiFg, var(--ui));
        font-size: calc(var(--menuTextSize) * 0.62);
        font-weight: 650;
        line-height: 1;
        letter-spacing: .02em;
        text-transform: lowercase;
        white-space: nowrap;
        opacity: 0;
        z-index: 2;
        pointer-events: none;
        transition: opacity .12s ease;
      }
      #menuToggleBtn[data-tip]:hover::after,
      #menuToggleBtn[data-tip]:focus-visible::after{
        opacity: .9;
      }
    }

    /* ===== Title (inside uiWrap) ===== */
    #titleBlock{
      position: fixed;
      top: calc(env(safe-area-inset-top, 0px) + var(--titlePadTop));
      left: 0;
      right: 0;
      z-index: 40;
      pointer-events: auto;

      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 6px;

      width: var(--uiW);
      max-width: var(--uiMaxW);
      margin-left: auto;
      margin-right: auto;

      text-align:center;
      color: var(--ui);
    }
    .lockBtn{
      height: calc(var(--pillH) + 1px);
      width: 34px; /* match playback icon pills */
      padding: 1px 0 0 0; /* +1px breathing room above the glyph */
      font-size: var(--pillFont);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      position: relative; /* tooltip anchor */
    }
    .lockBtn:hover{ filter: none; }

    .lockIcons{
      position: relative;
      width: calc(14px * var(--uiGlobalScale));
      height: calc(14px * var(--uiGlobalScale));
      display:inline-block;
      flex: 0 0 auto;
      opacity: 0.72;
    }
    .lockIcons .lockSvg{
      position:absolute;
      inset:0;
      transition: opacity 140ms ease;
    }
    .lockSvg{
      width: calc(14px * var(--uiGlobalScale));
      height: calc(14px * var(--uiGlobalScale));
      display:block;
      overflow: visible;
    }
    .lockBtn .lockSvg--open{ opacity: 1; }
    .lockBtn .lockSvg--closed{ opacity: 0; }
    .lockBtn.locked .lockSvg--open{ opacity: 0; }
    .lockBtn.locked .lockSvg--closed{ opacity: 1; }
    .lockBtn:not(.locked):hover .lockSvg--open{ opacity: 0; }
    .lockBtn:not(.locked):hover .lockSvg--closed{ opacity: 1; }
    .lockBtn.locked:hover .lockSvg--open{ opacity: 1; }
    .lockBtn.locked:hover .lockSvg--closed{ opacity: 0; }

    @media (hover: hover) and (pointer: fine){
      .lockBtn[data-tip]::after{
        content: attr(data-tip);
        position: absolute;
        left: 50%;
        top: calc(100% + 8px);
        transform: translate(-50%, -4px);
        color: var(--ui);
        font-size: 9px;
        letter-spacing: .10em;
        text-transform: uppercase;
        line-height: 1;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity .12s ease, transform .12s ease;
      }
      .lockBtn[data-tip]:hover::after{
        opacity: .9;
        transform: translate(-50%, 0);
      }
    }

    .iconBtn{
      width: 34px;
      height: var(--pillH);
      padding: 0;
      letter-spacing: 0;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border-color: var(--ui3);
      color: var(--ui);
      background: transparent;
      position: relative;
    }
    .iconBtn::before{
      content:"";
      position:absolute;
      inset:0;
      border-radius: inherit;
      background: var(--btnBg, transparent);
    }
    .iconBtn svg{
      width: 14px;
      height: 14px;
      display:block;
      position: relative;
      z-index: 1;
    }
    #pausePoemBtn .playIcon{ display:none; }
    #pausePoemBtn.paused .pauseIcon{ display:none; }
    #pausePoemBtn.paused .playIcon{ display:block; }
    .iconBtn:disabled{
      opacity: 0.35;
      cursor: default;
      background: transparent !important;
    }
    .iconBtn:hover{
      color: var(--ui);
      border-color: var(--ui3);
    }
    .iconBtn:hover::before,
    .iconBtn.forceHover::before{
      background: color-mix(in srgb, var(--btnBg) 70%, transparent);
      filter: none;
    }
    .iconBtn:active::before{
      background: color-mix(in srgb, var(--btnBg) 70%, transparent);
    }
    .iconBtn:disabled:hover{
      filter: none;
      color: var(--ui);
      border-color: var(--ui3);
    }
    .iconBtn:disabled:hover::before{ filter: none; }

    @media (hover: hover) and (pointer: fine){
      .iconBtn[data-tip]::after{
        content: attr(data-tip);
        position: absolute;
        left: 50%;
        bottom: calc(100% + 8px);
        transform: translate(-50%, 4px);
        color: var(--ui);
        font-size: 9px;
        letter-spacing: .10em;
        text-transform: uppercase;
        line-height: 1;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity .12s ease, transform .12s ease;
      }
      .iconBtn[data-tip]:hover::after{
        opacity: .9;
        transform: translate(-50%, 0);
      }
    }

    @media (hover: hover) and (pointer: fine){
      /* Dock button hover text (below the button). */
      .dockBtn[data-tip]{
        position: relative;
      }
      .dockBtn[data-tip]::after{
        content: attr(data-tip);
        position: absolute;
        left: 50%;
        top: calc(100% + 8px);
        transform: translate(-50%, -4px);
        color: var(--ui);
        font-size: 9px;
        letter-spacing: .10em;
        text-transform: uppercase;
        line-height: 1;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity .12s ease, transform .12s ease;
      }
      .dockBtn[data-tip]:hover::after{
        opacity: .9;
        transform: translate(-50%, 0);
      }
    }

    /* ===== Bottom Dock + Sliding Panel ===== */
    #bar{
      position: fixed;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      height: 100%;
      padding: 0;

      pointer-events:none;
      background: transparent;

      max-height: calc(var(--vh, 1vh) * 100);
      max-width: none;
      overflow: visible;
      transform: none;
      transition: none;
    }

    .barInner{
      width: 100%;
      max-width: none;
      margin-left: auto;
      margin-right: auto;

      display:flex;
      flex-direction:column;
      gap:0;
      height:100%;
      overflow: visible;

      transform: none;
      transform-origin: center;
    }

    #panelWrap{
      --panelMaxH: 62vh; /* JS may override this to keep UI out of the phrase/card safe zone */
      position: fixed;
      left: 0;
      top: 0;
      bottom: auto;
      width: fit-content;
      max-width: calc(100vw - 12px);
      overflow: visible;
      max-height: 0;
      opacity: 0;
      transform: none;
      transition: opacity .14s ease;
      pointer-events: none;
      margin-bottom: 0;
    }
    #panelWrap.panel-tiles{
      left: 0 !important;
      top: 0 !important;
      width: 0 !important;
      height: 0 !important;
      max-width: none !important;
      max-height: none !important;
      overflow: visible !important;
      pointer-events: none !important;
      margin: 0 !important;
    }
    body[data-ui-page]:not([data-ui-page="none"]) #panelWrap{
      max-height: var(--panelMaxH, 62vh);
      opacity: 1;
      transform: none;
      pointer-events: auto;
      margin-bottom: 10px;
    }
    #panelInner{
      max-height: none;
      overflow: visible;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 8px;
      padding-top: 4px;
    }
    #panelWrap.panel-tiles #panelInner{
      max-height: none !important;
      overflow: visible !important;
      display: block !important;
      padding: 0 !important;
      gap: 0 !important;
      pointer-events: none !important;
    }
    #panelInner .uiPage{
      background: var(--cardUiBg, transparent);
      width: fit-content;
      max-width: min(var(--uiW), 94vw);
      padding: 6px 8px;
    }
    #panelWrap.panel-tiles #panelInner .uiPage{
      background: transparent !important;
      width: auto !important;
      max-width: none !important;
      padding: 0 !important;
    }
    #panelInner .panelTileFloat{
      position: fixed !important;
      margin: 0 !important;
      z-index: 58;
      pointer-events: auto !important;
    }

    #dock{
      position: fixed;
      inset: 0;
      display: block;
      padding: 0;
      margin: 0;
      pointer-events: none;
      transform: none !important;
      transition: none;
    }
    #titleBlock #dock{ margin-top: 22px; }
    #dockPlayback{
      display:flex;
      gap: 3px;
      align-items:center;
    }
    #dockMenu{
      display: contents;
    }
    #dockBottom{
      display: contents;
    }
    .dockBtn{
      height: var(--pillH);
      padding: 0 12px;
      font-size: var(--pillFont);
      min-width: 0;
    }
    #screenshotBtn{ grid-area: shot; }
    #tabColorsBtn{ grid-area: colors; }
    #fsBtn{ grid-area: fs; }
    #tabLanguageBtn{ grid-area: lang; }
    #tabContrastBtn{ grid-area: contrast; }
    #tabSpeedBtn{ grid-area: speed; }
    #lockCompositionBtn{ grid-area: lock; }
    #dock .dockBtn,
    #dock .iconBtn,
    #dock .lockBtn{
      --btnScale: var(--uiGlobalScale);
      border-radius: 0;
      border: none;
      background: var(--cardUiBg, transparent);
      color: var(--cardUiFg, var(--ui));
      box-shadow: none;
      text-transform: lowercase;
      font-weight: 650;
      letter-spacing: .02em;
    }
    #dock .dockBtn:hover,
    #dock .iconBtn:hover,
    #dock .lockBtn:hover,
    #dock .dockBtn:focus-visible,
    #dock .iconBtn:focus-visible,
    #dock .lockBtn:focus-visible,
    #dock .iconBtn:disabled:hover{
      color: var(--cardUiFg, var(--ui));
    }
    #dock .dockBtn{
      height: calc(30px * var(--btnScale));
      font-size: calc(var(--menuTextSize) * var(--btnScale));
      line-height: 1;
      padding: 0 calc(12px * var(--btnScale));
    }
    #dock .iconBtn{
      width: calc(32px * var(--btnScale));
      height: calc(30px * var(--btnScale));
      padding: 0;
    }
    #dock .iconBtn::before{
      background: var(--cardUiBg, transparent);
      border-radius: 0;
    }
    #dock .iconBtn svg{
      width: calc(14px * var(--uiGlobalScale));
      height: calc(14px * var(--uiGlobalScale));
    }
    #dock .lockBtn{
      width: calc(30px * var(--btnScale));
      height: calc(30px * var(--btnScale));
      padding: 0;
    }
    #dock .lockIcons{
      opacity: 1;
    }
    #panelInner .uiPage .label,
    #panelInner .uiPage .val{
      color: var(--cardUiFg, var(--ui));
      opacity: .9;
    }
    #panelInner .uiPage .ssBtn,
    #panelInner .uiPage .colorBtn{
      border-radius: 0;
      border: none;
      background: var(--cardUiBg, transparent);
      color: var(--cardUiFg, var(--ui));
      text-transform: lowercase;
      font-weight: 650;
      letter-spacing: .02em;
    }
    #panelInner .uiPage .ssBtn:hover,
    #panelInner .uiPage .ssBtn:focus-visible,
    #panelInner .uiPage .colorBtn:hover,
    #panelInner .uiPage .colorBtn:focus-visible{
      color: var(--cardUiFg, var(--ui));
    }
    #panelInner .uiPage .label,
    #panelInner .uiPage .val,
    #panelInner .uiPage .ssBtn,
    #panelInner .uiPage .colorBtn{
      font-size: var(--menuTextSize) !important;
      line-height: 1;
    }
    #panelInner .uiPage .label,
    #panelInner .uiPage .val{
      font-size: calc(var(--menuTextSize) * 0.72) !important;
      line-height: 1.05;
      letter-spacing: .02em;
      text-transform: lowercase;
      font-weight: 650;
    }
    #panelInner .uiPage--contrast,
    #panelInner .uiPage--speed{
      background: transparent;
      padding: 0;
    }
    #dock .dockControl{
      position: fixed;
      margin-top: 0;
      z-index: 60;
      transform: scale(1);
      transform-origin: center center;
      transition: width .16s ease, height .16s ease, padding .16s ease, font-size .16s ease, margin-top .16s ease, left .18s ease, top .18s ease, transform .12s ease;
    }
    #dock .dockControl.dock-shrink{
      --btnScale: var(--uiGlobalScale);
      transform: scale(1);
    }
    #dock .dockControl.dock-focus{
      --btnScale: var(--uiGlobalScale);
      transform: scale(1);
      z-index: 62;
    }
    #dock .dockControl.dock-hover-focus{
      --btnScale: var(--uiGlobalScale);
      transform: scale(1);
    }
    #dock .dockControl.dock-hover-shrink{
      --btnScale: var(--uiGlobalScale);
      transform: scale(1);
    }
    /* When a panel is open, keep extra center space by shrinking non-focused controls. */
    body[data-ui-page]:not([data-ui-page="none"]) #dock .dockControl.dock-shrink{
      --btnScale: var(--uiGlobalScale);
      transform: scale(0.9);
    }
    body[data-ui-page]:not([data-ui-page="none"]) #dock .dockControl.dock-focus{
      --btnScale: var(--uiGlobalScale);
      transform: scale(1);
    }
    #dock .dockObject{
      position: fixed;
      pointer-events: auto;
    }
    #dock .dockControl[data-tip]::after{
      content: attr(data-tip);
      position: absolute;
      left: 50%;
      bottom: calc(100% + 2px);
      top: auto;
      transform: translateX(-50%);
      color: var(--cardUiFg, var(--ui));
      font-size: calc(var(--menuTextSize) * 0.62);
      font-weight: 650;
      line-height: 1;
      letter-spacing: .02em;
      text-transform: lowercase;
      white-space: nowrap;
      opacity: 0;
      z-index: 2;
      pointer-events: none;
      transition: opacity .12s ease;
    }
    #dock .dockControl.dock-tip-open::after{
      opacity: 1;
    }
    #dock .iconBtn[data-tip]::after{
      color: var(--cardUiFg, var(--ui));
      font-size: calc(var(--menuTextSize) * 0.62);
      font-weight: 650;
      line-height: 1;
      letter-spacing: .02em;
      text-transform: lowercase;
      bottom: calc(100% + 2px);
    }
    .row{
      display:flex;
      gap:12px;
      align-items:flex-end;
      flex-wrap:nowrap;
      min-width:0;
    }
    .centerRow{
      justify-content: center;
      align-items: center;
      text-align: center;
    }

    /* centered 3 swatch sections */
    .colorsRow{
      justify-content: center;
      align-items:flex-end;
      gap: 28px;
      flex-wrap:nowrap;
    }
    /* (removed) vertical swatch column; colors page uses the 3-up row again */

    .grp{
      display:flex;
      flex-direction:column;
      gap:5px;
      min-width:0;
      flex: 0 1 360px;
    }
    .grp.words{
      flex: 0 0 auto;
      align-items: stretch;
    }

    .label{
      font-size: 9px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color: var(--ui);
      user-select:none;
      line-height:1;
      opacity:.82;
      display:block;
      white-space:nowrap;
    }
    .labelRow{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      min-width:0;
    }
    .val{
      font-size: 9px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color: var(--ui);
      opacity:.9;
      user-select:none;
      white-space:nowrap;
    }

    button{
      font: inherit;
      font-weight: 520;
      font-size: 7.1px;
      letter-spacing: .10em;
      text-transform: uppercase;
      color: var(--ui);
      background: transparent;
      border: none;
      border-radius: 999px;
      padding: 3.6px 6px;
      cursor: pointer;
      line-height: 1;
      user-select: none;
      white-space: nowrap;
      transition: transform .05s ease, color .15s ease, background-color .15s ease;
      -webkit-tap-highlight-color: transparent;
    }
    button:active{ transform: translateY(1px); }
    button:hover{ color: var(--ui); }

    /* When a button is "on", kill the outline entirely (keeps sliders unaffected). */
    button.on{ border: none !important; }
    button.on:hover{ border: none !important; }

    .colorBtn{
      background: var(--btnBg, transparent);
      border: none;
      color: var(--ui);
    }
    .colorBtn:not(.on){
      background: var(--btnBg, transparent);
    }
    .colorBtn:not(.on):hover,
    .colorBtn.forceHover:not(.on){
      background: var(--btnBg, transparent);
      filter: none;
      color: var(--ui);
      border: none;
    }
    .colorBtn.on:hover,
    .colorBtn.forceHover.on{
      background: var(--btnBg, transparent);
      filter: none;
      color: var(--ui);
      border: none;
    }
    .colorBtn:not(.on):active{
      background: var(--btnBg, transparent);
    }
    .colorBtn.on:active{
      background: var(--btnBg, transparent);
    }
    .colorBtn.disabled{
      opacity: 0.55;
      cursor: default;
      filter: none;
    }

    .btnGroup{
      display:flex;
      flex-wrap:wrap;
      gap:4.5px;
      align-items:center;
      min-width:0;
      overflow: visible;
    }
    .btnGroup.centered{ justify-content: center; }

    /* Center the "Sentence Structure" title while keeping the tiny on/off indicator on the right. */
    .grp.words .labelRow{
      position: relative;
      justify-content: flex-end;
      width: 100%;
    }
    .grp.words .labelRow .label{
      position:absolute;
      left:50%;
      transform: translateX(-50%);
    }
    .grp.words .labelRow .hoverVal{
      margin-left: auto;
    }
    .ssBtn{
      height: var(--pillH);
      padding: 0 var(--pillPadX);
      border-radius: 999px;
      border: none;
      font-weight: 520;
      font-size: var(--pillFont);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      color: var(--fg);
      background: transparent;
    }
    .ssBtn.on{
      background: var(--ssBg);
      color: var(--fg);
      border: none;
    }
    .ssBtn:not(.on){
      background: transparent;
      color: var(--ui);
      border: none;
    }
    .ssBtn:not(.on):hover,
    .ssBtn.forceHover:not(.on){
      background: color-mix(in srgb, var(--ssBg) 50%, transparent);
      filter: none;
      color: var(--ui);
      border: none;
    }
    .ssBtn.on:hover,
    .ssBtn.forceHover.on{
      background: color-mix(in srgb, var(--ssBg) 70%, transparent);
      filter: none;
      color: var(--ui);
      border: none;
    }
    .ssBtn:not(.on):active{
      background: color-mix(in srgb, var(--ssBg) 50%, transparent);
    }
    .ssBtn.on:active{
      background: color-mix(in srgb, var(--ssBg) 70%, transparent);
    }

    .sliderRow{
      display:flex;
      gap:12px;
      align-items:flex-end;
      flex-wrap:nowrap;
      min-width:0;
    }

    /* ===== Paged UI (Language / Contrast / Colors / Speed) ===== */
    .uiPage{ display:none; }
    body[data-ui-page="language"] .uiPage--language{ display:block; }
    body[data-ui-page="info"] .uiPage--info{ display:block; }
    body[data-ui-page="contrast"] .uiPage--contrast{ display:block; }
    body[data-ui-page="colors"] .uiPage--colors{ display:block; }
    body[data-ui-page="speed"] .uiPage--speed{ display:block; }

    /* Language panel: sentence structure buttons are standalone controls. */
    .uiPage--language{
      max-width: min(960px, 96vw);
      margin-left: auto;
      margin-right: auto;
      background: transparent;
      padding: 0;
    }
    .uiPage--language #partsRow{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
      justify-content: center;
      align-items:center;
    }
    .uiPage--language #partsRow .ssBtn{
      min-width: max-content;
      width: max-content;
      height: calc(36px * var(--uiGlobalScale));
      padding: 0 calc(12px * var(--uiGlobalScale));
      border-radius: 0;
      border: none;
      background: var(--cardUiBg, transparent);
      color: var(--cardUiFg, var(--ui));
      text-transform: lowercase;
      font-weight: 650;
      letter-spacing: .02em;
      font-size: calc(var(--menuTextSize) * 1.2) !important;
      line-height: 1;
      transition: height .12s ease, padding .12s ease, font-size .12s ease;
    }
    .uiPage--language #partsRow .ssBtn:not(.on){
      opacity: 1;
      filter: none;
      box-shadow: none;
      min-width: max-content;
      width: max-content;
      height: calc(18px * var(--uiGlobalScale));
      padding: 0 calc(8px * var(--uiGlobalScale));
      font-size: calc(var(--menuTextSize) * 0.6) !important;
    }
    .uiPage--language #partsRow .ssBtn.on{
      opacity: 1;
      filter: none;
      box-shadow: none;
      min-width: max-content;
      width: max-content;
      height: calc(36px * var(--uiGlobalScale));
      padding: 0 calc(12px * var(--uiGlobalScale));
      font-size: calc(var(--menuTextSize) * 1.2) !important;
    }
    .uiPage--language #partsRow .ssBtn:hover,
    .uiPage--language #partsRow .ssBtn:focus-visible,
    .uiPage--language #partsRow .ssBtn:active{
      background: var(--cardUiBg, transparent);
      color: var(--cardUiFg, var(--ui));
      border: none;
    }

    .uiPage--info{
      max-width: min(980px, 96vw);
      margin-left: auto;
      margin-right: auto;
    }
    .uiPage--info .infoGroup{
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      width: fit-content;
      max-width: 94vw;
      margin-left: auto;
      margin-right: auto;
    }
    .uiPage--info .infoHeadTile,
    .uiPage--info .infoBlurbTile{
      background: var(--cardUiBg, transparent);
      color: var(--cardUiFg, var(--ui));
      text-align: center;
    }
    .uiPage--info .infoHeadTile{
      padding: calc(8px * var(--uiGlobalScale)) calc(10px * var(--uiGlobalScale));
      width: max-content;
      max-width: 94vw;
    }
    .uiPage--info .infoBlurbTile{
      padding: calc(12px * var(--uiGlobalScale)) calc(14px * var(--uiGlobalScale));
      width: min(86vw, 620px);
    }
    .uiPage--info .infoTitle{
      font-size: calc((var(--menuTextSize) * 0.7) + 2px);
      font-weight: 400;
      letter-spacing: .01em;
      line-height: 1.1;
      margin-bottom: 0;
      text-transform: none;
    }
    .uiPage--info .infoByline{
      font-size: calc((var(--menuTextSize) * 0.7) + 2px);
      font-weight: 650;
      line-height: 1.1;
      margin-bottom: 0;
      text-transform: none;
    }
    .uiPage--info p{
      margin: 0 0 10px 0;
      font-size: calc((var(--menuTextSize) * 0.7) + 1px);
      line-height: 1.24;
      letter-spacing: .01em;
      text-transform: none;
      text-align: center;
    }
    .uiPage--info p:last-child{
      margin-bottom: 0;
    }

    /* Contrast panel: dedicated brightness sliders. */
    .uiPage--contrast{
      max-width: min(980px, 96vw);
      margin-left: auto;
      margin-right: auto;
    }
    .uiPage--contrast .colorsBrightnessRow{
      margin-bottom: 0;
      display:grid;
      grid-template-columns: repeat(3, minmax(196px, 1fr));
      gap: 10px;
    }
    .uiPage--contrast .ctrl{
      min-width: 196px;
      flex: 1 1 auto;
    }

    /* Colors panel: all swatches shown together (no grouped rows). */
    .uiPage--colors{
      max-width: min(940px, 96vw);
      margin-left: auto;
      margin-right: auto;
    }
    .uiPage--colors .colorsPanelLayout{
      display: grid;
      grid-template-columns: max-content max-content max-content;
      align-items: center;
      justify-content: center;
      gap: 14px;
      width: fit-content;
      margin-left: auto;
      margin-right: auto;
    }
    .uiPage--colors .colorsScopeCol,
    .uiPage--colors .colorsBulkCol{
      display: flex;
      flex-direction: column;
      gap: 7px;
      align-items: center;
      justify-content: center;
      background: transparent;
      padding: 0;
    }
    .uiPage--colors .colorsGridCol{
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      min-width: 0;
      background: var(--cardUiBg, transparent);
      padding: calc(9px * var(--uiGlobalScale));
    }
    .uiPage--colors .swatchGridPanel{
      background: transparent;
      padding: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .uiPage--colors .colorScopeBtn{
      height: auto;
      min-height: 0;
      min-width: max-content;
      width: max-content;
      padding: calc(6px * var(--uiGlobalScale)) calc(14px * var(--uiGlobalScale));
      display: inline-flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
      line-height: 1;
      font-size: var(--menuTextSize) !important;
      transition: padding .12s ease, font-size .12s ease, opacity .12s ease;
    }
    #panelInner .uiPage--colors .colorScopeBtn{
      font-size: var(--menuTextSize) !important;
      padding: calc(6px * var(--uiGlobalScale)) calc(14px * var(--uiGlobalScale));
      min-width: max-content;
      width: max-content;
    }
    #panelInner .uiPage--colors .colorScopeBtn:not(.on){
      opacity: 1;
      filter: none;
      font-size: calc(var(--menuTextSize) * 0.7) !important;
      padding: calc(4px * var(--uiGlobalScale)) calc(10px * var(--uiGlobalScale)) !important;
    }
    #panelInner .uiPage--colors .colorScopeBtn.on{
      opacity: 1;
      filter: none;
      box-shadow: none;
      font-size: var(--menuTextSize) !important;
      padding: calc(6px * var(--uiGlobalScale)) calc(14px * var(--uiGlobalScale)) !important;
    }
    #panelInner .uiPage--colors .colorScopeBtn:not(.on):active{
      font-size: calc(var(--menuTextSize) * 0.7) !important;
      padding: calc(4px * var(--uiGlobalScale)) calc(10px * var(--uiGlobalScale));
    }
    #panelInner .uiPage--colors .colorScopeBtn.on:active{
      font-size: var(--menuTextSize) !important;
      padding: calc(6px * var(--uiGlobalScale)) calc(14px * var(--uiGlobalScale));
    }
    .uiPage--colors .label,
    .uiPage--colors .val{
      font-size: 8px;
      letter-spacing: .07em;
    }
    .uiPage--colors .swatchRow--all{
      display: grid;
      grid-template-columns: repeat(10, max-content);
      justify-content: center;
      gap: 7px;
      width: auto;
    }
    .uiPage--colors .swatchHeader{
      width: auto !important;
      min-width: 100%;
      display: flex;
      justify-content: space-between;
      gap: 14px;
    }
    .uiPage--colors .swatchHeader{ display: none; }
    .uiPage--colors .swatchHeader .label{
      text-transform: lowercase;
    }
    .uiPage--colors .swatchHeader .hoverVal{
      min-width: 12ch;
      text-align: right;
    }
    .uiPage--colors .swatchRow--all .swatch{
      position: relative;
      width: 30px;
      height: 30px;
      border: none;
      border-radius: 0;
      padding: 0;
      background: var(--fillCol);
      overflow: hidden;
      box-shadow: none;
    }
    .uiPage--colors .swatchRow--all .swatch::before{
      content:"";
      position:absolute;
      left: 5px;
      right: 5px;
      top: 14px;
      height: 1.6px;
      background: color-mix(in srgb, var(--cardUiFg, var(--ui)) 70%, transparent);
      transform: rotate(42deg);
      opacity: 0;
      pointer-events: none;
    }
    .uiPage--colors .swatchRow--all .swatch::after{
      content:"";
      position:absolute;
      left: 5px;
      right: 5px;
      top: 14px;
      height: 1.6px;
      background: color-mix(in srgb, var(--cardUiFg, var(--ui)) 70%, transparent);
      transform: rotate(-42deg);
      opacity: 0;
      pointer-events: none;
    }
    .uiPage--colors .swatchRow--all .swatch.on{
      background: var(--fillCol);
      opacity: 1;
      filter: none;
      box-shadow: none;
    }
    .uiPage--colors .swatchRow--all .swatch:not(.on){
      background: var(--fillCol);
      opacity: .62;
      filter: saturate(.82);
      box-shadow: none;
    }
    .uiPage--colors .swatchRow--all .swatch:not(.on)::before,
    .uiPage--colors .swatchRow--all .swatch:not(.on)::after{ opacity: .72; }
    .uiPage--colors .swatchRow--all .swatch.on:hover,
    .uiPage--colors .swatchRow--all .swatch.on:active{
      background: color-mix(in srgb, var(--fillCol) 88%, transparent);
      opacity: 1;
      box-shadow: none;
    }
    .uiPage--colors .swatchRow--all .swatch:not(.on):hover,
    .uiPage--colors .swatchRow--all .swatch:not(.on):active{
      background: var(--fillCol);
      opacity: .78;
      box-shadow: none;
    }

    @media(max-width: 860px){
      .uiPage--language{ max-width: min(640px, 100%); }
      .uiPage--language #partsRow .ssBtn{
        height: calc(34px * var(--uiGlobalScale));
      }
      .uiPage--language #partsRow .ssBtn:not(.on){
        height: calc(17px * var(--uiGlobalScale));
        padding: 0 calc(7px * var(--uiGlobalScale));
      }

      .uiPage--contrast{
        max-width: min(640px, 100%);
      }
      .uiPage--contrast .colorsBrightnessRow{
        grid-template-columns: repeat(2, minmax(187px, 1fr));
      }
      .uiPage--colors{
        max-width: min(640px, 100%);
      }
      .uiPage--colors .colorsPanelLayout{
        grid-template-columns: 1fr;
        justify-items: center;
        gap: 10px;
      }
      .uiPage--colors .colorsScopeCol,
      .uiPage--colors .colorsBulkCol{
        flex-direction: column;
      }
      .uiPage--colors .swatchRow--all{
        grid-template-columns: repeat(6, max-content);
      }
    }
    @media(max-width: 640px){
      .uiPage--contrast .colorsBrightnessRow{ grid-template-columns: 1fr; }
    }

    #panelInner .uiPage button{
      overflow: hidden;
      text-overflow: clip;
    }

    /* ===== Mobile landscape ===== */
    @media (pointer: coarse) and (orientation: landscape) and (max-height: 520px){
      /* Reduce top clutter so the dock never covers the phrase/card. */
      #titleBlock{ gap: 4px; }
      #titleBlock #dock{
        margin-top: 14px;
        gap: 10px;
      }

      /* Contrast + colors: keep wide layout in landscape. */
      .uiPage--contrast{
        max-width: min(920px, 94vw);
      }
      .uiPage--contrast .colorsBrightnessRow{
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }

      .uiPage--colors{
        max-width: min(920px, 94vw);
      }
      .uiPage--colors .colorsPanelLayout{
        grid-template-columns: max-content max-content max-content;
      }
      .uiPage--colors .colorsScopeCol,
      .uiPage--colors .colorsBulkCol{
        flex-direction: column;
      }
      .uiPage--colors .swatchRow--all{
        grid-template-columns: repeat(8, max-content);
      }
    }

    /* Speed submenu uses the same tile language as other slider menus. */
    .uiPage--speed{
      max-width: min(420px, 96vw);
      margin-left: auto;
      margin-right: auto;
    }
    .uiPage--speed .sliderRow{
      display:grid;
      grid-template-columns: minmax(230px, 1fr);
      justify-content: center;
    }
    .uiPage--speed .ctrl{ min-width: 230px; }

    .uiPage--contrast .ctrl,
    .uiPage--speed .ctrl{
      background: var(--cardUiBg, transparent);
      color: var(--cardUiFg, var(--ui));
      padding: calc(9px * var(--uiGlobalScale)) calc(12px * var(--uiGlobalScale));
      display: flex;
      flex-direction: column;
      gap: calc(7px * var(--uiGlobalScale));
      min-width: 0;
    }
    .uiPage--contrast .labelRow,
    .uiPage--speed .labelRow{
      margin-bottom: 0;
      align-items: center;
    }
    .uiPage--contrast .label,
    .uiPage--speed .label,
    .uiPage--contrast .val,
    .uiPage--speed .val{
      font-size: calc((var(--menuTextSize) * 0.74) + 1px) !important;
      letter-spacing: .02em;
      text-transform: lowercase;
      font-weight: 650;
    }
    .uiPage--contrast input[type=range],
    .uiPage--speed input[type=range]{
      height: calc(20px * var(--uiGlobalScale));
    }
    .uiPage--contrast input[type=range]::-webkit-slider-runnable-track,
    .uiPage--speed input[type=range]::-webkit-slider-runnable-track{
      height: 3px;
    }
    .uiPage--contrast input[type=range]::-moz-range-track,
    .uiPage--speed input[type=range]::-moz-range-track{
      height: 3px;
    }
    .uiPage--contrast input[type=range]::-webkit-slider-thumb,
    .uiPage--speed input[type=range]::-webkit-slider-thumb{
      width: calc(12px * var(--uiGlobalScale));
      height: calc(12px * var(--uiGlobalScale));
      margin-top: calc(-4.5px * var(--uiGlobalScale));
    }
    .uiPage--contrast input[type=range]::-moz-range-thumb,
    .uiPage--speed input[type=range]::-moz-range-thumb{
      width: calc(12px * var(--uiGlobalScale));
      height: calc(12px * var(--uiGlobalScale));
    }

    /* Dock buttons stay fully visible in the unified card-color style. */
    .ctrl{
      flex: 1 1 0;
      display:flex;
      flex-direction:column;
      gap:3px;
      min-width:0;
    }
    input[type=range]{
      appearance:none;
      width:100%;
      height:16px;
      background:transparent;
      color: var(--thumbCol, var(--fg));
      margin:0;
      padding:0;
      touch-action: none;
    }
    input[type=range]::-webkit-slider-runnable-track{
      height:2px;
      background:var(--ui3);
      border-radius:999px;
    }
    input[type=range]::-moz-range-track{
      height:2px;
      background:var(--ui3);
      border-radius:999px;
    }
    input[type=range]::-webkit-slider-thumb{
      appearance:none;
      width:10px; height:10px;
      border-radius:50%;
      background: currentColor;
      margin-top:-4px;
      border: none;
      box-sizing: border-box;
    }
    input[type=range]::-moz-range-thumb{
      width:10px; height:10px;
      border-radius:50%;
      background: currentColor;
      border: none;
      box-sizing: border-box;
    }

    .swatchWrap{
      display:flex;
      flex-direction:column;
      gap:5px;
      width:100%;
      max-width:100%;
      align-items:center;
    }
    .swatchHeader{
      display:flex;
      justify-content: space-between;
      gap: 10px;
      align-items: baseline;
      width: fit-content;
    }
    .hoverVal{ min-width: 7ch; text-align: right; }

    .swatchRow{
      display:flex;
      flex-wrap:nowrap;
      gap: 10px;
      align-items:center;
      justify-content:center;
      min-width:0;
      max-width: 100%;
      width: fit-content;
    }

    #phraseText.oneWord{
      white-space: normal;
      width: 100%;
      max-width: 100%;
    }

    .swatch{
      width: var(--swW);
      height: var(--pillH);
      padding: 0;
      border-radius: 999px;
      border: none;
      background: transparent;
      box-shadow: none;
      cursor: pointer;
      transition: transform .05s ease, filter .12s ease, box-shadow .12s ease, background-color .12s ease;
    }
    .swatch:active{ transform: translateY(1px); }

    .swatch.on{
      background: var(--fillCol);
      box-shadow: inset 0 0 0 var(--swRing) var(--ringCol);
    }
    .swatch:not(.on):hover,
    .swatch.forceHover:not(.on){
      background: color-mix(in srgb, var(--fillCol) 50%, transparent);
      box-shadow: inset 0 0 0 var(--swRing) color-mix(in srgb, var(--ringCol) 50%, transparent);
      filter: none;
    }
    .swatch.on:hover,
    .swatch.forceHover.on{
      background: color-mix(in srgb, var(--fillCol) 70%, transparent);
      box-shadow: inset 0 0 0 var(--swRing) color-mix(in srgb, var(--ringCol) 70%, transparent);
      filter: none;
    }
    .swatch:not(.on):active{
      background: color-mix(in srgb, var(--fillCol) 50%, transparent);
      box-shadow: inset 0 0 0 var(--swRing) color-mix(in srgb, var(--ringCol) 50%, transparent);
    }
    .swatch.on:active{
      background: color-mix(in srgb, var(--fillCol) 70%, transparent);
      box-shadow: inset 0 0 0 var(--swRing) color-mix(in srgb, var(--ringCol) 70%, transparent);
    }

    @supports not (color-mix(in srgb, red 30%, transparent)){
      .swatch{
        background: transparent;
        box-shadow: none;
        opacity: 1;
      }
      .swatch.on{
        background: var(--fillCol);
        box-shadow: inset 0 0 0 var(--swRing) var(--ringCol);
      }
      .swatch:hover{
        background: var(--fillCol);
        box-shadow: inset 0 0 0 var(--swRing) var(--ringCol);
        opacity: 0.85;
      }

      .colorBtn:hover{ background: var(--btnBg, transparent); }
      .ssBtn:hover{ background: var(--ssBg); }
      .iconBtn:hover::before{ background: var(--btnBg, transparent); }
    }

@media (pointer: coarse){
  :root{
    --pillH: 18px;
    --pillPadX: 12px;
    --pillFont: 7.6px;
  }
  button{ font-size: 7.4px; padding: 5px 8px; }
  .iconBtn{ width: 42px; height: var(--pillH); padding: 0; }
  .iconBtn svg{ width: 18px; height: 18px; }
  input[type=range]{ height: 20px; }
      input[type=range]::-webkit-slider-thumb{
        width:13px; height:13px;
        margin-top:-5.5px;
      }
      input[type=range]::-moz-range-thumb{
        width:13px; height:13px;
      }
    }

    @media(max-width: 980px){
      :root{
        --barH: clamp(240px, 34vh, 330px);
        --barOffset: 30px;
        --uiMaxW: 980px;
      }
      .row, .sliderRow{ flex-wrap:wrap; }
      .colorsRow{ flex-wrap:wrap; }
      .grp{ flex: 1 1 320px; }
      .swatchRow{ flex-wrap:wrap; }
    }

    @media(max-width: 640px){
      :root{
        --barH: clamp(260px, 40vh, 370px);
        --barOffset: 20px;
        --pillH: 15px;
        --swW: calc(var(--pillH) * 2);
        --uiMaxW: 620px;
        --titlePadTop: 16px;
      }
      #phraseText{ font-size: calc(clamp(28px, 7vw, 70px) * var(--textScale) * var(--fitScale) * var(--sceneZoom)); }
      button{ font-size: 6.8px; padding: 3.4px 5.3px; }
      .label, .val{ font-size: 8.5px; }
      .btnGroup{ gap:4px; }
      .swatchRow{ gap: 9px; flex-wrap:wrap; }
    }

    @media(max-width: 480px), (max-height: 720px){
      :root{
        --barH: clamp(210px, 30vh, 250px);
        --barOffset: 8px;
        --uiScale: 0.96;
        --uiPadX: 14px;
      }
      /* Bottom dock/panel manages its own scrolling (panelInner). */
      #titleBlock{ gap: 4px; }
    }
  </style>
</head>

<body data-ui-page="none">
  <div id="stage">
    <div id="card" aria-hidden="true"></div>
    <div id="phrase" role="status" aria-live="polite">
      <span id="phraseText"></span>
    </div>
  </div>

  <!-- UI WRAP: title + bar (fades together) -->
  <div id="uiWrap">
    <div id="titleBlock">
      <!-- TOP BUTTONS (always visible on load; fade with UI) -->
      <div id="dockTopHost" aria-label="buttons (top host)">
        <div id="dock" aria-label="buttons">
        <div id="dockPlayback" aria-label="playback controls">
          <button id="prevPoemBtn" type="button" class="iconBtn" aria-label="previous poem (left arrow)" data-tip="previous">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M15 6l-6 6 6 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
          <button id="pausePoemBtn" type="button" class="iconBtn" aria-label="pause (space)" aria-pressed="false" data-tip="pause">
            <svg class="pauseIcon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M7 6h3v12H7zM14 6h3v12h-3z" fill="currentColor"/>
            </svg>
            <svg class="playIcon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M9 7l10 5-10 5V7z" fill="currentColor"/>
            </svg>
          </button>
          <button id="nextPoemBtn" type="button" class="iconBtn" aria-label="next poem (right arrow)" data-tip="forward">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M9 6l6 6-6 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
        </div>

        <div id="dockBottom" aria-label="utilities">
          <button id="screenshotBtn" type="button" class="colorBtn dockBtn" aria-label="screenshot (s)" data-tip="take pic">screenshot</button>
          <button id="fsBtn" type="button" class="colorBtn dockBtn" aria-pressed="false" data-tip="zoom">full screen</button>
          <button id="lockCompositionBtn" type="button" class="colorBtn lockBtn" aria-label="lock composition" aria-pressed="false" data-tip="lock">
            <span class="lockIcons" aria-hidden="true">
              <svg class="lockSvg lockSvg--open" viewBox="0 0 24 24" focusable="false" aria-hidden="true">
                <rect x="5" y="10" width="14" height="12" rx="1.5" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
                <path d="M7 10V7 Q7 2 12 2 Q17 2 17 7 V10" transform="translate(34 -1) scale(-1 1)" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <rect x="9" y="15" width="6" height="2" fill="currentColor"/>
              </svg>
              <svg class="lockSvg lockSvg--closed" viewBox="0 0 24 24" focusable="false" aria-hidden="true">
                <rect x="5" y="10" width="14" height="12" rx="1.5" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
                <path d="M7 10V7 Q7 2 12 2 Q17 2 17 7 V10" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <rect x="11" y="14" width="2" height="5" fill="currentColor"/>
              </svg>
            </span>
          </button>
        </div>

        <div id="dockMenu" aria-label="menus">
          <button id="tabLanguageBtn" type="button" class="colorBtn dockBtn" aria-pressed="false" data-tip="change phrase structure">language</button>
          <button id="tabContrastBtn" type="button" class="colorBtn dockBtn" aria-pressed="false" data-tip="adjust light / dark">contrast</button>
          <button id="tabColorsBtn" type="button" class="colorBtn dockBtn" aria-pressed="false" data-tip="adjust swatches">colors</button>
          <button id="tabSpeedBtn" type="button" class="colorBtn dockBtn" aria-pressed="false" data-tip="adjust sequence">speed</button>
          <button id="tabInfoBtn" type="button" class="colorBtn dockBtn" aria-pressed="false" data-tip="sculpture poems">info</button>
        </div>
      </div>
      </div>
    </div>

    <div id="bar">
      <div class="barInner">

        <!-- Submenu pages -->
        <div id="panelWrap" aria-label="submenu panel">
          <div id="panelInner">
            <section class="uiPage uiPage--language" aria-label="language">
              <div class="btnGroup centered" id="partsRow"></div>
            </section>

            <section class="uiPage uiPage--info" aria-label="info">
              <div class="infoGroup">
                <div class="infoHeadTile">
                  <div class="infoTitle">Sculpture Poems by Margot DeMarco</div>
                </div>
                <div class="infoBlurbTile">
                  <p>These poems are randomly generated object-focused sculptural scenes, continuously reshuffled. All language is drawn from a large bank of words written by the artist. Viewer can adjust the sentence structure of the poems, as well as how they look visually.</p>
                </div>
              </div>
            </section>

            <section class="uiPage uiPage--speed" aria-label="speed">
              <div class="sliderRow">
                <div class="ctrl">
                  <div class="labelRow"><div class="label">speed</div><div class="val" id="speedVal">7.0s</div></div>
                  <input id="speedSlider" type="range" min="0" max="1" step="0.001" value="0.595">
                </div>
              </div>
            </section>

            <section class="uiPage uiPage--contrast" aria-label="contrast">
              <div class="sliderRow colorsBrightnessRow">
                <div class="ctrl">
                  <div class="labelRow"><div class="label">background brightness</div><div class="val" id="bgBrightVal">50%</div></div>
                  <input id="bgBrightSlider" type="range" min="0" max="1" step="0.001" value="0.50">
                </div>
                <div class="ctrl">
                  <div class="labelRow"><div class="label">text brightness</div><div class="val" id="fgBrightVal">0%</div></div>
                  <input id="fgBrightSlider" type="range" min="0" max="1" step="0.001" value="0.00">
                </div>
                <div class="ctrl">
                  <div class="labelRow"><div class="label">card brightness</div><div class="val" id="bdBrightVal">100%</div></div>
                  <input id="bdBrightSlider" type="range" min="0" max="1" step="0.001" value="1.00">
                </div>
              </div>
            </section>

            <section class="uiPage uiPage--colors" aria-label="colors">
              <div class="colorsPanelLayout">
                <div class="colorsScopeCol" id="colorScopeRow" aria-label="color target">
                  <button id="scopeFgBtn" type="button" class="colorBtn colorScopeBtn" aria-pressed="false">text color</button>
                  <button id="scopeBgBtn" type="button" class="colorBtn colorScopeBtn" aria-pressed="false">background color</button>
                  <button id="scopeBdBtn" type="button" class="colorBtn colorScopeBtn" aria-pressed="true">card color</button>
                </div>

                <div class="colorsGridCol" id="colorsGridTile">
                  <div class="swatchGridPanel">
                    <div class="swatchRow swatchRow--all" id="allColorsRow"></div>
                  </div>
                </div>

                <div class="colorsBulkCol">
                  <button id="allOffBtn" type="button" class="colorBtn colorScopeBtn">all off</button>
                  <button id="allOnBtn" type="button" class="colorBtn colorScopeBtn">all on</button>
                </div>
              </div>
            </section>
          </div>
        </div>

        <div id="layoutStateStore" hidden aria-hidden="true">
          <input id="sizeSlider" type="range" min="0" max="150" step="0.1" value="40">
          <input id="ySlider" type="range" min="0" max="100" step="0.01" value="50">
          <input id="widthSlider" type="range" min="0" max="100" step="0.01" value="40">
          <input id="bdThickSlider" type="range" min="0" max="1" step="0.001" value="0.30">
          <button id="bdToggleBtn" type="button" aria-pressed="true">on</button>
          <span id="sizeVal">40%</span>
          <span id="yVal">50%</span>
          <span id="widthVal">40%</span>
          <span id="bdThickVal">30%</span>
        </div>

        <div id="dockBottomHost" aria-label="buttons (bottom host)"></div>

      </div>
    </div>
  </div>

  <button id="menuToggleBtn" type="button" aria-label="toggle menu" aria-pressed="false">menu</button>

<script>
/* ================= Helpers ================= */
function uniq(arr){
  const s = new Set();
  for(const x of arr){
    const v = String(x ?? "").trim().replace(/\s+/g," ");
    const v2 = v.toLowerCase();
    if(v2) s.add(v2);
  }
  return Array.from(s);
}
function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
function lerp(a,b,t){ return a + (b-a)*t; }

function shuffleInPlace(a){
  for(let i=a.length-1;i>0;i--){
    const j = (Math.random()*(i+1))|0;
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}

function setViewportVars(){
  const vv = window.visualViewport;
  const h = (vv ? vv.height : window.innerHeight) * 0.01;
  document.documentElement.style.setProperty("--vh", `${h}px`);
}

function getViewportSize(){
  const vv = window.visualViewport;
  return {
    w: vv ? vv.width : window.innerWidth,
    h: vv ? vv.height : window.innerHeight
  };
}

function parsePx(val){
  const n = Number(String(val || "").replace("px","").trim());
  return Number.isFinite(n) ? n : 0;
}
function getRootVarPx(name){
  return parsePx(getComputedStyle(document.documentElement).getPropertyValue(name));
}
function getRootVarVw(name){
  const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  if(v.endsWith("vw")) return Number(v.replace("vw","").trim());
  const n = Number(v);
  return Number.isFinite(n) ? n : null;
}

/* ================= Non-repeating shuffle bags ================= */
const BAGS = new Map();
function bagNext(key, pool){
  const cleanPool = uniq(pool);
  if(!cleanPool.length) return null;

  const sig = cleanPool.join("");
  const prev = BAGS.get(key);

  if(!prev || prev._sig !== sig){
    const arr = cleanPool.slice();
    shuffleInPlace(arr);
    BAGS.set(key, { arr, i: 0, _sig: sig });
  }
  const bag = BAGS.get(key);
  if(bag.i >= bag.arr.length){
    shuffleInPlace(bag.arr);
    bag.i = 0;
  }
  const out = bag.arr[bag.i];
  bag.i++;
  return out;
}

const WORD_RECENCY = new Map();
function normToken(v){
  return String(v || "").trim().replace(/\s+/g, " ").toLowerCase();
}
function getWordRecencyBucket(key, maxKeep){
  const k = String(key || "");
  const keep = Math.max(0, Math.floor(maxKeep || 0));
  let bucket = WORD_RECENCY.get(k);
  if(!bucket){
    bucket = { max: keep, queue: [], seen: new Set() };
    WORD_RECENCY.set(k, bucket);
  }else if(bucket.max !== keep){
    bucket.max = keep;
    while(bucket.queue.length > bucket.max){
      const old = bucket.queue.shift();
      if(!bucket.queue.includes(old)) bucket.seen.delete(old);
    }
  }
  return bucket;
}
function rememberWordRecent(key, token, maxKeep){
  const t = normToken(token);
  if(!t) return;
  const bucket = getWordRecencyBucket(key, maxKeep);
  if(bucket.max <= 0) return;
  bucket.queue.push(t);
  bucket.seen.add(t);
  while(bucket.queue.length > bucket.max){
    const old = bucket.queue.shift();
    if(!bucket.queue.includes(old)) bucket.seen.delete(old);
  }
}
function bagNextWithCooldown(key, pool, maxRecent){
  const cleanPool = uniq(pool);
  if(!cleanPool.length) return null;
  const effectiveRecent = clamp(Math.floor(maxRecent || 0), 0, Math.max(0, cleanPool.length - 1));
  if(effectiveRecent <= 0){
    return bagNext(key, cleanPool);
  }

  const bucket = getWordRecencyBucket(key, effectiveRecent);
  const maxTries = Math.max(cleanPool.length + 8, effectiveRecent + 8);
  let fallback = null;
  for(let i=0; i<maxTries; i++){
    const candidate = bagNext(key, cleanPool);
    if(candidate == null) continue;
    fallback = candidate;
    const cn = normToken(candidate);
    if(!bucket.seen.has(cn)){
      rememberWordRecent(key, candidate, effectiveRecent);
      return candidate;
    }
  }
  if(fallback != null){
    rememberWordRecent(key, fallback, effectiveRecent);
    return fallback;
  }
  return bagNext(key, cleanPool);
}

/* ================= Palettes ================= */
const PAL = {
  circus: ["#FF6AD5","#FF8A00","#FF4D1A","#C85AE0","#FF007A"],
  beachy: ["#BDE8FF","#8FB2CF","#CBE7FF","#445F86","#74A8E8"],
  fleshy: ["#F7D59B","#F6B77D","#B7852F","#F7B59D","#E1780A"],
  future: ["#9EDB00","#C86AD6","#F8C6A4","#B23A2B","#7FB1D9"],
  retro:  ["#DDE6B7","#00AEB0","#D85A10","#B10D33","#F6A623"],
  earthy: ["#A7B827","#D79A16","#536A00","#6F8A1A","#806200"]
};

/* ================= Color helpers ================= */
function hexToRgb(hex){
  const h = hex.replace("#","").trim();
  const full = h.length === 3 ? h.split("").map(c=>c+c).join("") : h;
  const n = parseInt(full,16);
  return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
}
function rgbToHex(r,g,b){
  const to = (v)=> v.toString(16).padStart(2,"0");
  return "#" + to(r) + to(g) + to(b);
}
function rgbToHsl(r,g,b){
  r/=255; g/=255; b/=255;
  const max = Math.max(r,g,b), min = Math.min(r,g,b);
  let h=0, s=0;
  const l = (max+min)/2;
  const d = max-min;
  if(d !== 0){
    s = d / (1 - Math.abs(2*l - 1));
    switch(max){
      case r: h = ((g-b)/d) % 6; break;
      case g: h = (b-r)/d + 2; break;
      case b: h = (r-g)/d + 4; break;
    }
    h *= 60;
    if(h < 0) h += 360;
  }
  return {h, s, l};
}
function hslToRgb(h,s,l){
  const c = (1 - Math.abs(2*l - 1)) * s;
  const x = c * (1 - Math.abs(((h/60) % 2) - 1));
  const m = l - c/2;
  let rp=0,gp=0,bp=0;

  if(0<=h && h<60){ rp=c; gp=x; bp=0; }
  else if(60<=h && h<120){ rp=x; gp=c; bp=0; }
  else if(120<=h && h<180){ rp=0; gp=c; bp=x; }
  else if(180<=h && h<240){ rp=0; gp=x; bp=c; }
  else if(240<=h && h<300){ rp=x; gp=0; bp=c; }
  else { rp=c; gp=0; bp=x; }

  return { r: Math.round((rp+m)*255), g: Math.round((gp+m)*255), b: Math.round((bp+m)*255) };
}
function setHsl(hex, h, s, l){
  const out = hslToRgb(h, s, l);
  return rgbToHex(out.r,out.g,out.b);
}

/* brightness dimmer */
function applyDimmer(hex, sliderVal){
  const t = clamp(Number(sliderVal), 0, 1);
  const {r,g,b} = hexToRgb(hex);
  let {h,s,l} = rgbToHsl(r,g,b);

  if(Math.abs(t - 0.5) < 1e-6) return hex;

  if(t < 0.5){
    const k = (0.5 - t) / 0.5;
    const lMul = lerp(1.0, 0.42, k);
    l = clamp(l * lMul, 0.08, 0.90);
    s = clamp(s * lerp(1.0, 1.10, k), 0.18, 0.98);
  }else{
    const k = (t - 0.5) / 0.5;
    l = clamp(l + (1 - l) * (0.33 * k), 0.08, 0.92);
    s = clamp(s * lerp(1.0, 1.28, k), 0.18, 0.98);
  }
  return setHsl(hex, h, s, l);
}

function lightestHexFromPalette(palName){
  const pal = PAL[palName] || [];
  let best = pal[0] || "#ffffff";
  let bestL = -1;
  for(const hex of pal){
    const {r,g,b} = hexToRgb(hex);
    const {l} = rgbToHsl(r,g,b);
    if(l > bestL){
      bestL = l;
      best = hex;
    }
  }
  return best;
}
function darkestHexFromPalette(palName){
  const pal = PAL[palName] || [];
  let best = pal[0] || "#000000";
  let bestL = 2;
  for(const hex of pal){
    const {r,g,b} = hexToRgb(hex);
    const {l} = rgbToHsl(r,g,b);
    if(l < bestL){
      bestL = l;
      best = hex;
    }
  }
  return best;
}

/* ================= Controls ================= */
const PART_OPTS = ["description","object","person","action","location"];
const COLOR_OPTS = ["earthy","beachy","fleshy","retro","future","circus"];
const ALL_SWATCH_COLORS = uniq(Object.values(PAL).flat().map((hex)=> String(hex || "").trim().toLowerCase()));
const SLIDER_PALS = ["circus","beachy","fleshy","retro","future","earthy","circus","beachy"];
const palCycleIndex = {};

function initPaletteCycles(){
  for(const name of COLOR_OPTS) palCycleIndex[name] = 0;
}
function paletteColor(name, offset=0){
  const pal = PAL[name] || [];
  if(!pal.length) return "#000000";
  const idx = palCycleIndex[name] ?? 0;
  return pal[(idx + offset) % pal.length];
}
function normHex(hex){
  return String(hex || "").trim().toLowerCase();
}
function getBgLiveHex(){
  // Prefer the actual rendered background; fall back to what we'd compute right now.
  const live = normHex(current.bgLive);
  if(live) return live;
  return normHex(applyDimmer(current.bgBase, Number(bgBrightEl.value)));
}
function getFgLiveHex(){
  const live = normHex(current.fgLive);
  if(live) return live;
  return normHex(applyDimmer(current.fgBase, Number(fgBrightEl.value)));
}
function paletteColorAvoid(palName, offset=0, avoidHex=""){
  const pal = PAL[palName] || [];
  if(!pal.length) return "#000000";
  const avoid = normHex(avoidHex);
  const idx = palCycleIndex[palName] ?? 0;
  if(!avoid) return pal[(idx + offset) % pal.length];

  for(let i=0; i<pal.length; i++){
    const c = pal[(idx + offset + i) % pal.length];
    if(normHex(c) !== avoid) return c;
  }
  return pal[(idx + offset) % pal.length];
}

function advancePaletteCycle(){
  for(const name of COLOR_OPTS){
    const pal = PAL[name] || [];
    if(!pal.length) continue;
    palCycleIndex[name] = (palCycleIndex[name] + 1) % pal.length;
  }
}

/* ================= DOM refs ================= */
const phraseEl = document.getElementById("phraseText");
const uiWrapEl = document.getElementById("uiWrap");
const panelWrapEl = document.getElementById("panelWrap");
const panelInnerEl = document.getElementById("panelInner");
const cardEl = document.getElementById("card");

const speedEl = document.getElementById("speedSlider");
const bgBrightEl = document.getElementById("bgBrightSlider");
const fgBrightEl = document.getElementById("fgBrightSlider");
const bdBrightEl = document.getElementById("bdBrightSlider");

const sizeEl  = document.getElementById("sizeSlider");
const yEl     = document.getElementById("ySlider");
const widthEl = document.getElementById("widthSlider");

const bdThickEl = document.getElementById("bdThickSlider");
const bdToggleBtn = document.getElementById("bdToggleBtn");
const fsBtn = document.getElementById("fsBtn");
const prevPoemBtn = document.getElementById("prevPoemBtn");
const pausePoemBtn = document.getElementById("pausePoemBtn");
const nextPoemBtn = document.getElementById("nextPoemBtn");
const screenshotBtn = document.getElementById("screenshotBtn");
const lockCompositionBtn = document.getElementById("lockCompositionBtn");
const tabLanguageBtn = document.getElementById("tabLanguageBtn");
const tabContrastBtn = document.getElementById("tabContrastBtn");
const tabColorsBtn = document.getElementById("tabColorsBtn");
const tabSpeedBtn = document.getElementById("tabSpeedBtn");
const tabInfoBtn = document.getElementById("tabInfoBtn");
const dockPlaybackEl = document.getElementById("dockPlayback");
const scopeBgBtn = document.getElementById("scopeBgBtn");
const scopeFgBtn = document.getElementById("scopeFgBtn");
const scopeBdBtn = document.getElementById("scopeBdBtn");
const allOnBtn = document.getElementById("allOnBtn");
const allOffBtn = document.getElementById("allOffBtn");
const menuToggleBtn = document.getElementById("menuToggleBtn");
const dockEl = document.getElementById("dock");
const dockTopHostEl = document.getElementById("dockTopHost");
const dockBottomHostEl = document.getElementById("dockBottomHost");

const speedVal = document.getElementById("speedVal");
const bgBrightVal = document.getElementById("bgBrightVal");
const fgBrightVal = document.getElementById("fgBrightVal");
const bdBrightVal = document.getElementById("bdBrightVal");
const sizeVal = document.getElementById("sizeVal");
const yVal = document.getElementById("yVal");
const widthVal = document.getElementById("widthVal");
const bdThickVal = document.getElementById("bdThickVal");

const sliderEls = [
  speedEl, bgBrightEl, fgBrightEl, bdBrightEl,
  bdThickEl, sizeEl, yEl, widthEl
];

/* ================= Dock Constellation sizing ================= */
const dockControlBtns = [
  dockPlaybackEl,
  screenshotBtn, fsBtn, lockCompositionBtn,
  tabLanguageBtn, tabContrastBtn, tabColorsBtn, tabSpeedBtn, tabInfoBtn
].filter(Boolean);
const dockControlById = new Map(dockControlBtns.map((btn)=>[btn.id, btn]));
let dockActiveBtnId = "";
let dockHoverBtnId = "";
let dockLayoutRaf = 0;
const DOCK_LAYOUT_MARGIN = 8;
const DOCK_LAYOUT_GAP = 6;
const DOCK_LAYOUT_OBS_PAD = 8;
const DOCK_GRID_MIN_STEP_X = 12;
const DOCK_GRID_MIN_STEP_Y = 10;
const DOCK_GRID_MAX_RING = 64;
const DOCK_PANEL_MAX_RING = 96;
const DOCK_SUBMENU_Y_SHIFT = 20;
const DOCK_MENU_SPACER_EXTRA = 28;
const DOCK_SUBMENU_IDS = new Set([
  "tabLanguageBtn",
  "tabContrastBtn",
  "tabColorsBtn",
  "tabSpeedBtn",
  "tabInfoBtn",
  "screenshotBtn",
  "fsBtn"
]);

function shouldUseBandedMobileLayout(vw, vh){
  const w = Number.isFinite(vw) ? vw : (window.innerWidth || 0);
  const h = Number.isFinite(vh) ? vh : (window.innerHeight || 0);
  const coarse = !!(window.matchMedia && window.matchMedia("(pointer: coarse)").matches);
  const touch = (navigator.maxTouchPoints || 0) > 0;
  const maxSide = Math.max(w, h);
  return (coarse || touch) && maxSide <= 1400;
}

function inflateRect(r, pad){
  return {
    left: r.left - pad,
    top: r.top - pad,
    right: r.right + pad,
    bottom: r.bottom + pad
  };
}

function makeDockRect(x, y, w, h, tipTop = 0){
  return {
    left: x,
    top: y - tipTop,
    right: x + w,
    bottom: y + h
  };
}

function measureDockControl(btn){
  const rect = btn.getBoundingClientRect();
  // Use layout box dimensions so measurements stay stable while CSS transforms animate.
  const w = Math.max(20, Math.ceil(btn.offsetWidth || rect.width || 0));
  const h = Math.max(20, Math.ceil(btn.offsetHeight || rect.height || 0));
  const fontPx = parseFloat(getComputedStyle(btn).fontSize) || 12;
  const hasTip = !!(btn.dataset && btn.dataset.tip);
  const hasChildTips = (btn.id === "dockPlayback");
  // Reserve tooltip space in layout at all times so hover text never collides.
  const tipTop = (hasTip || hasChildTips) ? Math.ceil((fontPx * 0.9) + 10) : 0;
  return { w, h, tipTop };
}

function getDockLayoutOrder(){
  const priority = {
    tabLanguageBtn: 10,
    tabColorsBtn: 20,
    tabInfoBtn: 30,
    lockCompositionBtn: 40,
    tabSpeedBtn: 50,
    dockPlayback: 60,
    tabContrastBtn: 70,
    fsBtn: 80,
    screenshotBtn: 90
  };
  return dockControlBtns
    .map((btn)=>btn.id)
    .sort((a, b)=>(priority[a] ?? 999) - (priority[b] ?? 999));
}

function getDockObstacles(){
  const obstacles = [];
  const safe = getSceneSafeRect();
  if(safe){
    obstacles.push(inflateRect(safe, DOCK_LAYOUT_OBS_PAD));
  }
  if(menuToggleBtn){
    const mr = menuToggleBtn.getBoundingClientRect();
    if(mr.width > 0 && mr.height > 0){
      obstacles.push(inflateRect(mr, DOCK_LAYOUT_GAP));
    }
  }
  return obstacles;
}

function fitsDockRect(rect, vw, vh, obstacles, placed){
  if(rect.left < DOCK_LAYOUT_MARGIN) return false;
  if(rect.top < DOCK_LAYOUT_MARGIN) return false;
  if(rect.right > (vw - DOCK_LAYOUT_MARGIN)) return false;
  if(rect.bottom > (vh - DOCK_LAYOUT_MARGIN)) return false;
  for(const r of obstacles){
    if(rectsOverlap(rect, r, 0)) return false;
  }
  for(const r of placed){
    if(rectsOverlap(rect, r, DOCK_LAYOUT_GAP)) return false;
  }
  return true;
}

function buildDockCandidates(maxRing){
  const out = [];
  for(let row = -maxRing; row <= maxRing; row++){
    for(let col = -maxRing; col <= maxRing; col++){
      if(row === 0 && col === 0) continue;
      const ring = Math.max(Math.abs(row), Math.abs(col));
      if(ring > maxRing) continue;
      // Compact square around menu with strong bias to rows above menu.
      let score = (ring * 8) + (Math.abs(col) * 0.6) + (Math.abs(row) * 0.4);
      if(row > 0) score += 100 + (row * 14);
      out.push({ row, col, score });
    }
  }
  out.sort((a,b)=> a.score - b.score);
  return out;
}

function buildPanelCandidates(maxRing){
  const out = [];
  const seen = new Set();
  const rows = [-4,-5,-3,-6,-2,-7,-1,-8,0,1,2];
  const cols = [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6];
  for(const row of rows){
    for(const col of cols){
      if(row === 0 && col === 0) continue;
      const key = `${row},${col}`;
      if(seen.has(key)) continue;
      seen.add(key);
      out.push({ row, col });
    }
  }
  for(const c of buildDockCandidates(maxRing)){
    const key = `${c.row},${c.col}`;
    if(seen.has(key)) continue;
    seen.add(key);
    out.push({ row: c.row, col: c.col });
  }
  return out;
}

function shouldUsePanelTileLayout(vw, vh, page){
  const activePage = String(page || document.body.dataset.uiPage || "none");
  if(activePage === "none") return false;
  return true;
}

function getActivePanelTileEls(page){
  if(!panelInnerEl) return [];
  const safePage = String(page || "none");
  if(safePage === "language"){
    return Array.from(panelInnerEl.querySelectorAll(".uiPage--language #partsRow .ssBtn"));
  }
  if(safePage === "info"){
    return Array.from(panelInnerEl.querySelectorAll(".uiPage--info .infoGroup"));
  }
  if(safePage === "contrast"){
    return Array.from(panelInnerEl.querySelectorAll(".uiPage--contrast .ctrl"));
  }
  if(safePage === "colors"){
    return [
      panelInnerEl.querySelector("#colorsGridTile"),
      panelInnerEl.querySelector("#scopeFgBtn"),
      panelInnerEl.querySelector("#scopeBgBtn"),
      panelInnerEl.querySelector("#scopeBdBtn"),
      panelInnerEl.querySelector("#allOffBtn"),
      panelInnerEl.querySelector("#allOnBtn")
    ].filter(Boolean);
  }
  if(safePage === "speed"){
    return Array.from(panelInnerEl.querySelectorAll(".uiPage--speed .ctrl"));
  }
  return [];
}

function clearPanelFloatingTiles(){
  if(!panelWrapEl || !panelInnerEl) return;
  panelWrapEl.classList.remove("panel-tiles");
  panelWrapEl.style.left = "";
  panelWrapEl.style.top = "";
  panelWrapEl.style.bottom = "";
  panelWrapEl.style.transform = "";
  panelWrapEl.style.width = "";
  panelWrapEl.style.height = "";
  panelInnerEl.querySelectorAll(".panelTileFloat").forEach((el)=>{
    el.classList.remove("panelTileFloat");
    el.style.left = "";
    el.style.top = "";
    el.style.width = "";
    el.style.height = "";
    el.style.opacity = "";
    el.style.pointerEvents = "";
  });
}

function getPanelTopBounds(vh, blockH, panelTopLimit){
  const { w: vw } = getViewportSize();
  const safe = getSceneSafeRect();
  if(shouldUseBandedMobileLayout(vw, vh) && safe){
    const minTopBand = DOCK_LAYOUT_MARGIN;
    const topZoneBottom = Math.max(minTopBand, Math.round(safe.top - UI_SAFE_GAP_PX - 6));
    const maxTopBand = Math.max(minTopBand, topZoneBottom - blockH);
    if(maxTopBand >= minTopBand){
      return { minTop: minTopBand, maxTop: maxTopBand };
    }
  }
  const safeBottom = safe ? safe.bottom : Math.round(vh * 0.40);
  const minTop = Math.max(
    DOCK_LAYOUT_MARGIN,
    Math.round(safeBottom + UI_SAFE_GAP_PX + 8)
  );
  const topLimit = Number.isFinite(panelTopLimit)
    ? panelTopLimit
    : (vh - DOCK_LAYOUT_MARGIN);
  const maxTop = Math.max(minTop, Math.round(topLimit - blockH - 6));
  return { minTop, maxTop };
}

function buildPanelFlowRows(items, maxRowW, gapX){
  const rows = [];
  let row = [];
  let rowW = 0;
  let rowH = 0;

  const flush = ()=>{
    if(!row.length) return;
    rows.push({ items: row, rowW, rowH });
    row = [];
    rowW = 0;
    rowH = 0;
  };

  for(const item of items){
    const w = item.measure.w;
    const h = item.measure.h;
    const nextW = row.length ? (rowW + gapX + w) : w;
    if(row.length && nextW > maxRowW){
      flush();
    }
    row.push(item);
    rowW = row.length === 1 ? w : (rowW + gapX + w);
    rowH = Math.max(rowH, h);
  }
  flush();
  return rows;
}

function tryPlacePanelFlowCluster(measured, vw, vh, obstacles, placed, opts = {}){
  if(!measured.length) return false;
  const preferBelow = !!opts.preferBelow;
  const gapX = Math.max(6, Math.round(opts.gapX || 8));
  const gapY = Math.max(6, Math.round(opts.gapY || 8));
  const maxAvailW = Math.max(120, vw - (DOCK_LAYOUT_MARGIN * 2));
  const centerX = Number.isFinite(opts.centerX) ? opts.centerX : (vw * 0.5);
  const requestedRowW = Number.isFinite(opts.maxRowW) ? opts.maxRowW : maxAvailW;
  const maxRowW = clamp(Math.round(requestedRowW), 120, maxAvailW);

  const rows = buildPanelFlowRows(measured, maxRowW, gapX);
  if(!rows.length) return false;

  const blockW = Math.max(...rows.map((r)=>r.rowW));
  const blockH = rows.reduce((sum, r)=>sum + r.rowH, 0) + (gapY * (rows.length - 1));
  const { minTop, maxTop } = getPanelTopBounds(vh, blockH, opts.panelTopLimit);
  const minX = DOCK_LAYOUT_MARGIN;
  const maxX = Math.max(minX, vw - DOCK_LAYOUT_MARGIN - blockW);
  const xShifts = [0, -12, 12, -24, 24, -36, 36];
  const desiredTop = preferBelow
    ? minTop
    : clamp(
        Math.round(minTop + ((maxTop - minTop) * 0.45)),
        minTop,
        maxTop
      );
  const yCandidates = preferBelow
    ? Array.from(new Set([
        minTop,
        clamp(minTop + 8, minTop, maxTop),
        clamp(minTop + 16, minTop, maxTop),
        maxTop
      ]))
    : Array.from(new Set([
        desiredTop,
        minTop,
        maxTop,
        clamp(desiredTop - 10, minTop, maxTop),
        clamp(desiredTop + 10, minTop, maxTop)
      ]));

  for(const yBase of yCandidates){
    for(const sx of xShifts){
      const blockX = clamp(Math.round(centerX - (blockW * 0.5) + sx), minX, maxX);
      const blockY = clamp(Math.round(yBase), minTop, maxTop);
      const local = [];
      const placements = [];
      let y = blockY;
      let ok = true;

      for(const row of rows){
        let x = blockX + Math.round((blockW - row.rowW) * 0.5);
        for(const item of row.items){
          const top = y + Math.round((row.rowH - item.measure.h) * 0.5);
          const rect = makeDockRect(x, top, item.measure.w, item.measure.h, 0);
          if(!fitsDockRect(rect, vw, vh, obstacles, placed.concat(local))){
            ok = false;
            break;
          }
          local.push(rect);
          placements.push({ item, x, y: top, rect });
          x += item.measure.w + gapX;
        }
        if(!ok) break;
        y += row.rowH + gapY;
      }
      if(!ok) continue;

      for(const p of placements){
        p.item.el.style.left = `${Math.round(p.x)}px`;
        p.item.el.style.top = `${Math.round(p.y)}px`;
        obstacles.push(p.rect);
        placed.push(p.rect);
      }
      return true;
    }
  }
  return false;
}

function tryPlaceColorsPanelCluster(measured, vw, vh, obstacles, placed, opts = {}){
  const byId = new Map(measured.map((item)=>[String(item.el && item.el.id || ""), item]));
  const grid = byId.get("colorsGridTile");
  const leftBtns = ["scopeFgBtn","scopeBgBtn","scopeBdBtn"]
    .map((id)=>byId.get(id))
    .filter(Boolean);
  const rightBtns = ["allOffBtn","allOnBtn"]
    .map((id)=>byId.get(id))
    .filter(Boolean);

  if(!grid || leftBtns.length !== 3 || rightBtns.length !== 2) return false;

  function commitIfFits(placements){
    const local = [];
    for(const p of placements){
      const rect = makeDockRect(p.x, p.y, p.item.measure.w, p.item.measure.h, 0);
      if(!fitsDockRect(rect, vw, vh, obstacles, placed.concat(local))){
        return false;
      }
      local.push(rect);
      p.rect = rect;
    }
    for(const p of placements){
      p.item.el.style.left = `${Math.round(p.x)}px`;
      p.item.el.style.top = `${Math.round(p.y)}px`;
      obstacles.push(p.rect);
      placed.push(p.rect);
    }
    return true;
  }

  const rowGap = Math.max(6, DOCK_LAYOUT_GAP);
  const colGap = 12;

  const leftW = Math.max(...leftBtns.map((item)=>item.measure.w));
  const leftH = leftBtns.reduce((sum, item)=>sum + item.measure.h, 0) + (rowGap * (leftBtns.length - 1));
  const rightW = Math.max(...rightBtns.map((item)=>item.measure.w));
  const rightH = rightBtns.reduce((sum, item)=>sum + item.measure.h, 0) + (rowGap * (rightBtns.length - 1));
  const gridW = grid.measure.w;
  const gridH = grid.measure.h;
  const maxAvailW = vw - (DOCK_LAYOUT_MARGIN * 2);

  const centerX = Number.isFinite(opts.centerX) ? opts.centerX : (vw * 0.5);
  const xShifts = [0, -16, 16, -32, 32, -48, 48];

  // layout A: classic left stack + swatch grid + right stack (all shift together).
  {
    const blockW = leftW + colGap + gridW + colGap + rightW;
    const blockH = Math.max(leftH, gridH, rightH);
    if(blockW <= maxAvailW){
      const { minTop, maxTop } = getPanelTopBounds(vh, blockH, opts.panelTopLimit);
      const minX = DOCK_LAYOUT_MARGIN;
      const maxX = Math.max(minX, vw - DOCK_LAYOUT_MARGIN - blockW);
      const desiredTop = clamp(
        Math.round(minTop + ((maxTop - minTop) * 0.42)),
        minTop,
        maxTop
      );
      const yCandidates = Array.from(new Set([
        desiredTop,
        minTop,
        maxTop,
        clamp(desiredTop - 8, minTop, maxTop),
        clamp(desiredTop + 8, minTop, maxTop)
      ]));
      for(const topBase of yCandidates){
        for(const sx of xShifts){
          const leftX = clamp(Math.round(centerX - (blockW * 0.5) + sx), minX, maxX);
          const topY = clamp(Math.round(topBase), minTop, maxTop);
          const gridX = leftX + leftW + colGap;
          const rightX = gridX + gridW + colGap;
          const leftStartY = Math.round(topY + ((blockH - leftH) * 0.5));
          const gridY = Math.round(topY + ((blockH - gridH) * 0.5));
          const rightStartY = Math.round(topY + ((blockH - rightH) * 0.5));
          const placements = [{ item: grid, x: gridX, y: gridY }];
          let yL = leftStartY;
          for(const item of leftBtns){
            const x = leftX + Math.round((leftW - item.measure.w) * 0.5);
            placements.push({ item, x, y: yL });
            yL += item.measure.h + rowGap;
          }
          let yR = rightStartY;
          for(const item of rightBtns){
            const x = rightX + Math.round((rightW - item.measure.w) * 0.5);
            placements.push({ item, x, y: yR });
            yR += item.measure.h + rowGap;
          }
          if(commitIfFits(placements)) return true;
        }
      }
    }
  }

  // layout B: narrow fallback, still grouped tightly and moving as one bundle.
  {
    const leftRowW = leftBtns.reduce((sum, item)=>sum + item.measure.w, 0) + (rowGap * (leftBtns.length - 1));
    const rightRowW = rightBtns.reduce((sum, item)=>sum + item.measure.w, 0) + (rowGap * (rightBtns.length - 1));
    const leftRowH = Math.max(...leftBtns.map((item)=>item.measure.h));
    const rightRowH = Math.max(...rightBtns.map((item)=>item.measure.h));
    const blockW = Math.max(gridW, leftRowW, rightRowW);
    const blockH = gridH + rowGap + leftRowH + rowGap + rightRowH;
    if(blockW <= maxAvailW){
      const { minTop, maxTop } = getPanelTopBounds(vh, blockH, opts.panelTopLimit);
      const minX = DOCK_LAYOUT_MARGIN;
      const maxX = Math.max(minX, vw - DOCK_LAYOUT_MARGIN - blockW);
      const desiredTop = clamp(
        Math.round(minTop + ((maxTop - minTop) * 0.38)),
        minTop,
        maxTop
      );
      const yCandidates = Array.from(new Set([
        desiredTop,
        minTop,
        clamp(minTop + 12, minTop, maxTop),
        maxTop
      ]));
      for(const topBase of yCandidates){
        for(const sx of xShifts){
          const blockX = clamp(Math.round(centerX - (blockW * 0.5) + sx), minX, maxX);
          const topY = clamp(Math.round(topBase), minTop, maxTop);
          const gridX = blockX + Math.round((blockW - gridW) * 0.5);
          const leftY = topY + gridH + rowGap;
          const rightY = leftY + leftRowH + rowGap;
          const leftStartX = blockX + Math.round((blockW - leftRowW) * 0.5);
          const rightStartX = blockX + Math.round((blockW - rightRowW) * 0.5);
          const placements = [{ item: grid, x: gridX, y: topY }];
          let xL = leftStartX;
          for(const item of leftBtns){
            placements.push({ item, x: xL, y: leftY + Math.round((leftRowH - item.measure.h) * 0.5) });
            xL += item.measure.w + rowGap;
          }
          let xR = rightStartX;
          for(const item of rightBtns){
            placements.push({ item, x: xR, y: rightY + Math.round((rightRowH - item.measure.h) * 0.5) });
            xR += item.measure.w + rowGap;
          }
          if(commitIfFits(placements)) return true;
        }
      }
    }
  }

  return false;
}

function placeOpenPanelTiles(anchorX, anchorY, vw, vh, obstacles, placed, opts = {}){
  if(!panelWrapEl || !panelInnerEl) return false;
  const page = String(document.body.dataset.uiPage || "none");
  const centerX = Number.isFinite(opts.centerX) ? opts.centerX : (vw * 0.5);
  const panelTopLimit = Number.isFinite(opts.panelTopLimit) ? opts.panelTopLimit : null;
  const tiles = getActivePanelTileEls(page);
  if(!tiles.length) return false;

  panelWrapEl.classList.add("panel-tiles");
  panelWrapEl.style.left = "0px";
  panelWrapEl.style.top = "0px";
  panelWrapEl.style.bottom = "auto";
  panelWrapEl.style.transform = "none";

  const measured = [];
  tiles.forEach((el, idx)=>{
    if(!el) return;
    const r = el.getBoundingClientRect();
    const w = Math.max(44, Math.ceil(r.width || 0));
    const h = Math.max(28, Math.ceil(r.height || 0));
    if(w <= 0 || h <= 0) return;
    measured.push({
      el,
      idx,
      measure: { w, h, tipTop: 0 }
    });
  });
  if(!measured.length) return false;

  measured.forEach((item)=>{
    item.el.classList.add("panelTileFloat");
    item.el.style.width = `${item.measure.w}px`;
    item.el.style.height = `${item.measure.h}px`;
    item.el.style.opacity = "1";
    item.el.style.pointerEvents = "auto";
  });

  if(page === "colors"){
    const clustered = tryPlaceColorsPanelCluster(
      measured,
      vw,
      vh,
      obstacles,
      placed,
      {
        centerX,
        panelTopLimit
      }
    );
    if(clustered) return true;
  }

  const flowMaxW = (()=>{
    if(page === "language") return Math.min(vw - (DOCK_LAYOUT_MARGIN * 2), 860);
    if(page === "contrast") return vw - (DOCK_LAYOUT_MARGIN * 2);
    if(page === "speed" || page === "info"){
      return Math.max(...measured.map((item)=>item.measure.w));
    }
    return vw - (DOCK_LAYOUT_MARGIN * 2);
  })();
  const flowPlaced = tryPlacePanelFlowCluster(
    measured,
    vw,
    vh,
    obstacles,
    placed,
    {
      centerX,
      panelTopLimit,
      maxRowW: flowMaxW,
      preferBelow: page === "info",
      gapX: 8,
      gapY: 8
    }
  );
  if(flowPlaced) return true;

  const ordered = measured.slice().sort((a, b)=>{
    const areaA = a.measure.w * a.measure.h;
    const areaB = b.measure.w * b.measure.h;
    if(areaA !== areaB) return areaB - areaA;
    return a.idx - b.idx;
  });

  let baseY = Math.round(anchorY - 12);
  if(Number.isFinite(panelTopLimit)){
    baseY = Math.min(baseY, Math.round(panelTopLimit - 24));
  }
  for(const item of ordered){
    let spot = findDockSpot(
      `__panel_tile_${item.idx}`,
      item.measure,
      centerX,
      baseY,
      vw,
      vh,
      obstacles,
      placed,
      {
        stepX: Math.max(10, Math.floor(DOCK_GRID_MIN_STEP_X * 0.9)),
        stepY: Math.max(8, Math.floor(DOCK_GRID_MIN_STEP_Y * 0.9)),
        maxRing: DOCK_PANEL_MAX_RING
      }
    );

    if(!spot || !spot.rect || !fitsDockRect(spot.rect, vw, vh, obstacles, placed)){
      spot = null;
      const fallbackCandidates = buildPanelCandidates(DOCK_PANEL_MAX_RING + 28);
      for(const c of fallbackCandidates){
        const cx = centerX + (c.col * DOCK_GRID_MIN_STEP_X);
        const cy = baseY + (c.row * DOCK_GRID_MIN_STEP_Y);
        const x = Math.round(cx - (item.measure.w * 0.5));
        const y = Math.round(cy - (item.measure.h * 0.5));
        const rect = makeDockRect(x, y, item.measure.w, item.measure.h, 0);
        if(!fitsDockRect(rect, vw, vh, obstacles, placed)) continue;
        spot = { x, y, rect };
        break;
      }
    }

    if(!spot || !spot.rect || !fitsDockRect(spot.rect, vw, vh, obstacles, placed)){
      // Keep strict no-overlap behavior on cramped screens.
      item.el.style.opacity = "0";
      item.el.style.pointerEvents = "none";
      continue;
    }

    item.el.style.left = `${Math.round(spot.x)}px`;
    item.el.style.top = `${Math.round(spot.y)}px`;
    obstacles.push(spot.rect);
    placed.push(spot.rect);
  }
  return true;
}

function findDockSpot(btnId, measure, anchorX, anchorY, vw, vh, obstacles, placed, layoutCfg){
  const localAnchorY = anchorY + (DOCK_SUBMENU_IDS.has(btnId) ? DOCK_SUBMENU_Y_SHIFT : 0);
  const stepX = Math.max(DOCK_GRID_MIN_STEP_X, Math.round(layoutCfg?.stepX || DOCK_GRID_MIN_STEP_X));
  const stepY = Math.max(DOCK_GRID_MIN_STEP_Y, Math.round(layoutCfg?.stepY || DOCK_GRID_MIN_STEP_Y));
  const maxRing = Math.max(6, Math.round(layoutCfg?.maxRing || DOCK_GRID_MAX_RING));
  const candidates = (btnId === "__panel__")
    ? buildPanelCandidates(Math.max(maxRing, DOCK_PANEL_MAX_RING))
    : buildDockCandidates(maxRing);

  for(const c of candidates){
    const cx = anchorX + (c.col * stepX);
    const cy = localAnchorY + (c.row * stepY);
    const x = Math.round(cx - (measure.w * 0.5));
    const y = Math.round(cy - (measure.h * 0.5));
    const rect = makeDockRect(x, y, measure.w, measure.h, measure.tipTop);
    if(fitsDockRect(rect, vw, vh, obstacles, placed)){
      return { x, y, rect };
    }
  }

  // Exhaustive near-anchor scan before hard fallback.
  const minX = DOCK_LAYOUT_MARGIN;
  const maxX = Math.max(minX, vw - DOCK_LAYOUT_MARGIN - measure.w);
  const minY = DOCK_LAYOUT_MARGIN + measure.tipTop;
  const maxY = Math.max(minY, vh - DOCK_LAYOUT_MARGIN - measure.h);
  const scanStepX = Math.max(6, Math.floor(stepX * 0.9));
  const scanStepY = Math.max(6, Math.floor(stepY * 0.9));
  const centerX = clamp(Math.round(anchorX - (measure.w * 0.5)), minX, maxX);

  for(let y = maxY; y >= minY; y -= scanStepY){
    const tried = new Set();
    const xs = [centerX];
    for(let d = scanStepX; d <= (vw + stepX); d += scanStepX){
      xs.push(centerX - d, centerX + d);
      if((centerX - d) <= minX && (centerX + d) >= maxX) break;
    }
    for(const xRaw of xs){
      const x = clamp(Math.round(xRaw), minX, maxX);
      if(tried.has(x)) continue;
      tried.add(x);
      const rect = makeDockRect(x, y, measure.w, measure.h, measure.tipTop);
      if(fitsDockRect(rect, vw, vh, obstacles, placed)){
        return { x, y, rect };
      }
    }
  }

  // Final fallback: pin near menu center, above the menu whenever possible.
  const fallbackY = clamp(
    Math.round(localAnchorY - (stepY * 2) - (measure.h * 0.5)),
    DOCK_LAYOUT_MARGIN + measure.tipTop,
    vh - DOCK_LAYOUT_MARGIN - measure.h
  );
  const fallbackX = clamp(
    Math.round(anchorX - (measure.w * 0.5)),
    DOCK_LAYOUT_MARGIN,
    Math.max(DOCK_LAYOUT_MARGIN, vw - DOCK_LAYOUT_MARGIN - measure.w)
  );
  const fallbackRect = makeDockRect(fallbackX, fallbackY, measure.w, measure.h, measure.tipTop);
  return { x: fallbackX, y: fallbackY, rect: fallbackRect };
}

function placePresetDockCluster(anchorX, anchorY, vw, vh, obstacles, placed, measuresById){
  const placedIds = new Set();
  const getM = (id)=> measuresById.get(id) || measureDockControl(dockControlById.get(id));
  const menuRect = menuToggleBtn ? menuToggleBtn.getBoundingClientRect() : null;
  const menuW = Math.max(40, Math.ceil(menuRect ? menuRect.width : 68));
  const menuH = Math.max(24, Math.ceil(menuRect ? menuRect.height : 32));
  const g = DOCK_LAYOUT_GAP;
  const minX = DOCK_LAYOUT_MARGIN;
  const maxY = vh - DOCK_LAYOUT_MARGIN;

  function buildRow(items){
    const present = items
      .map((item)=>{
        if(!item || !item.id){
          return {
            id: "",
            w: Math.max(0, Math.ceil(item && item.w ? item.w : 0)),
            h: Math.max(0, Math.ceil(item && item.h ? item.h : 0)),
            tipTop: 0
          };
        }
        const btn = dockControlById.get(item.id);
        if(!btn) return null;
        const m = getM(item.id);
        if(!m) return null;
        return { id: item.id, w: m.w, h: m.h, tipTop: m.tipTop || 0 };
      })
      .filter(Boolean);

    const rowW = present.reduce((sum, item)=> sum + item.w, 0) + (Math.max(0, present.length - 1) * g);
    const maxHalfH = present.reduce((max, item)=> Math.max(max, item.h * 0.5), 0);
    const hasTips = present.some((item)=> item.tipTop > 0);
    // Keep rows compact but leave a little headroom for hover labels.
    const up = maxHalfH + (hasTips ? 8 : 0);
    const down = maxHalfH;
    return { items: present, rowW, up, down, h: up + down };
  }

  // Target stack (top -> bottom):
  // language | colors | info
  // lock | speed | playback | contrast
  // full screen | menu | screenshot
  const row1 = buildRow([
    { id: "tabLanguageBtn" },
    { id: "tabColorsBtn" },
    { id: "tabInfoBtn" }
  ]);
  const row2 = buildRow([
    { id: "lockCompositionBtn" },
    { id: "tabSpeedBtn" },
    { id: "dockPlayback" },
    { id: "tabContrastBtn" }
  ]);
  const row3 = buildRow([
    { id: "fsBtn" },
    { id: "", w: menuW + DOCK_MENU_SPACER_EXTRA, h: menuH },
    { id: "screenshotBtn" }
  ]);

  const rows = [row1, row2, row3];
  const rowGapOptions = [4, 6, 8, 10, 12];

  function tryPreset(rowGap, shiftX = 0, shiftY = 0){
    const localRects = [];
    const localPos = [];

    const row3CenterY = anchorY + shiftY;
    const row2CenterY = row3CenterY - (row2.down + rowGap + row3.up);
    const row1CenterY = row2CenterY - (row1.down + rowGap + row2.up);
    const centers = [row1CenterY, row2CenterY, row3CenterY];

    // Keep whole stack visible before per-item checks.
    const topMost = row1CenterY - row1.up;
    const bottomMost = row3CenterY + row3.down;
    if(topMost < DOCK_LAYOUT_MARGIN || bottomMost > maxY){
      return null;
    }

    for(let r = 0; r < rows.length; r++){
      const row = rows[r];
      const centerY = centers[r];
      if(!row || !row.items.length) continue;

      const centerX = anchorX + shiftX;
      const maxX = Math.max(minX, vw - DOCK_LAYOUT_MARGIN - row.rowW);
      const startX = clamp(Math.round(centerX - (row.rowW * 0.5)), minX, maxX);

      let x = startX;
      for(const item of row.items){
        if(!item.id){
          x += item.w + g;
          continue;
        }
        const y = Math.round(centerY - (item.h * 0.5));
        // In preset mode, reserve body area (not tooltip area) to keep stack compact/clean.
        const rect = makeDockRect(Math.round(x), y, item.w, item.h, 0);
        if(!fitsDockRect(rect, vw, vh, obstacles, placed.concat(localRects))){
          return null;
        }
        localRects.push(rect);
        localPos.push({ id: item.id, x: Math.round(x), y });
        x += item.w + g;
      }
    }

    return { localRects, localPos };
  }

  let found = null;
  const shiftXOptions = [0, -14, 14, -28, 28, -42, 42, -56, 56];
  const shiftYOptions = [0, 8, 14, -8, 20, -14];
  for(const gap of rowGapOptions){
    for(const sx of shiftXOptions){
      for(const sy of shiftYOptions){
        found = tryPreset(gap, sx, sy);
        if(found) break;
      }
      if(found) break;
    }
    if(found) break;
  }
  if(!found) return placedIds;

  for(const pos of found.localPos){
    const btn = dockControlById.get(pos.id);
    if(!btn) continue;
    btn.classList.add("dockObject");
    btn.style.left = `${pos.x}px`;
    btn.style.top = `${pos.y}px`;
    placedIds.add(pos.id);
  }
  for(const rect of found.localRects){
    placed.push(rect);
  }
  return placedIds;
}

function placeBandedDockRows(vw, vh, obstacles, placed, measuresById){
  const placedIds = new Set();
  const getM = (id)=> measuresById.get(id) || measureDockControl(dockControlById.get(id));
  const menuRect = menuToggleBtn ? menuToggleBtn.getBoundingClientRect() : null;
  const menuW = Math.max(40, Math.ceil(menuRect ? menuRect.width : 68));
  const menuH = Math.max(24, Math.ceil(menuRect ? menuRect.height : 32));
  const gapX = DOCK_LAYOUT_GAP;
  const safe = getSceneSafeRect();
  const minTop = safe
    ? Math.max(DOCK_LAYOUT_MARGIN, Math.round(safe.bottom + UI_SAFE_GAP_PX + 6))
    : Math.round(vh * 0.58);

  function buildRow(items){
    const present = items
      .map((item)=>{
        if(!item || !item.id){
          return {
            id: "",
            w: Math.max(0, Math.ceil(item && item.w ? item.w : 0)),
            h: Math.max(0, Math.ceil(item && item.h ? item.h : 0)),
            tipTop: 0
          };
        }
        const btn = dockControlById.get(item.id);
        if(!btn) return null;
        const m = getM(item.id);
        if(!m) return null;
        return { id: item.id, w: m.w, h: m.h, tipTop: m.tipTop || 0 };
      })
      .filter(Boolean);
    const rowW = present.reduce((sum, item)=> sum + item.w, 0) + (Math.max(0, present.length - 1) * gapX);
    const maxHalfH = present.reduce((max, item)=> Math.max(max, item.h * 0.5), 0);
    const hasTips = present.some((item)=> item.tipTop > 0);
    const up = maxHalfH + (hasTips ? 8 : 0);
    const down = maxHalfH;
    return { items: present, rowW, up, down, h: up + down };
  }

  const row1 = buildRow([
    { id: "tabLanguageBtn" },
    { id: "tabColorsBtn" },
    { id: "tabInfoBtn" }
  ]);
  const row2 = buildRow([
    { id: "lockCompositionBtn" },
    { id: "tabSpeedBtn" },
    { id: "dockPlayback" },
    { id: "tabContrastBtn" }
  ]);
  const row3 = buildRow([
    { id: "fsBtn" },
    { id: "", w: menuW + DOCK_MENU_SPACER_EXTRA, h: menuH },
    { id: "screenshotBtn" }
  ]);

  const rows = [row1, row2, row3];
  const rowGapOptions = [4, 3, 2];
  const xShiftOptions = [0, -10, 10, -20, 20, -30, 30];

  function tryRows(rowGap, shiftX = 0){
    const localRects = [];
    const localPos = [];
    const anchorX = clamp(Math.round((menuRect ? (menuRect.left + (menuRect.width * 0.5)) : (vw * 0.5)) + shiftX), DOCK_LAYOUT_MARGIN, vw - DOCK_LAYOUT_MARGIN);

    const row3TargetCenter = menuRect
      ? Math.round(menuRect.top - 6 - row3.down)
      : Math.round(vh - DOCK_LAYOUT_MARGIN - row3.down - 36);
    const row3MinCenter = Math.round(minTop + row1.h + rowGap + row2.h + rowGap + row3.up);
    const row3MaxCenter = Math.round(vh - DOCK_LAYOUT_MARGIN - row3.down);
    if(row3MinCenter > row3MaxCenter) return null;

    const row3Center = clamp(row3TargetCenter, row3MinCenter, row3MaxCenter);
    const row2Center = row3Center - (row2.down + rowGap + row3.up);
    const row1Center = row2Center - (row1.down + rowGap + row2.up);
    const centers = [row1Center, row2Center, row3Center];

    for(let r = 0; r < rows.length; r++){
      const row = rows[r];
      const centerY = centers[r];
      const minX = DOCK_LAYOUT_MARGIN;
      const maxX = Math.max(minX, vw - DOCK_LAYOUT_MARGIN - row.rowW);
      const startX = clamp(Math.round(anchorX - (row.rowW * 0.5)), minX, maxX);
      let x = startX;

      for(const item of row.items){
        if(!item.id){
          x += item.w + gapX;
          continue;
        }
        const y = Math.round(centerY - (item.h * 0.5));
        const rect = makeDockRect(Math.round(x), y, item.w, item.h, 0);
        if(!fitsDockRect(rect, vw, vh, obstacles, placed.concat(localRects))){
          return null;
        }
        localRects.push(rect);
        localPos.push({ id: item.id, x: Math.round(x), y });
        x += item.w + gapX;
      }
    }
    return { localRects, localPos };
  }

  let found = null;
  for(const gap of rowGapOptions){
    for(const sx of xShiftOptions){
      found = tryRows(gap, sx);
      if(found) break;
    }
    if(found) break;
  }
  if(!found) return placedIds;

  for(const pos of found.localPos){
    const btn = dockControlById.get(pos.id);
    if(!btn) continue;
    btn.classList.add("dockObject");
    btn.style.left = `${pos.x}px`;
    btn.style.top = `${pos.y}px`;
    placedIds.add(pos.id);
  }
  for(const rect of found.localRects){
    placed.push(rect);
  }
  return placedIds;
}

function placeOpenDockCluster(anchorX, anchorY, vw, vh, obstacles, placed, measuresById, panelMeasure){
  const placedIds = new Set();
  const activePage = String(document.body.dataset.uiPage || "none");
  const getM = (id)=> measuresById.get(id) || measureDockControl(dockControlById.get(id));
  const menuRect = menuToggleBtn ? menuToggleBtn.getBoundingClientRect() : null;
  const menuW = Math.max(40, Math.ceil(menuRect ? menuRect.width : 68));
  const menuH = Math.max(24, Math.ceil(menuRect ? menuRect.height : 32));
  const g = DOCK_LAYOUT_GAP;
  const rowGap = 4;
  const panelGap = 6;

  function buildRow(items){
    const present = items
      .map((item)=>{
        if(!item || !item.id){
          return {
            id: "",
            w: Math.max(0, Math.ceil(item && item.w ? item.w : 0)),
            h: Math.max(0, Math.ceil(item && item.h ? item.h : 0)),
            tipTop: 0
          };
        }
        const btn = dockControlById.get(item.id);
        if(!btn) return null;
        const m = getM(item.id);
        if(!m) return null;
        return { id: item.id, w: m.w, h: m.h, tipTop: m.tipTop || 0 };
      })
      .filter(Boolean);

    const rowW = present.reduce((sum, item)=> sum + item.w, 0) + (Math.max(0, present.length - 1) * g);
    const maxHalfH = present.reduce((max, item)=> Math.max(max, item.h * 0.5), 0);
    const hasTips = present.some((item)=> item.tipTop > 0);
    const up = maxHalfH + (hasTips ? 8 : 0);
    const down = maxHalfH;
    return { items: present, rowW, up, down };
  }

  function placeRow(row, centerY){
    if(!row || !row.items.length) return { ok: true, top: centerY, byId: new Map() };
    const minX = DOCK_LAYOUT_MARGIN;
    const maxX = Math.max(minX, vw - DOCK_LAYOUT_MARGIN - row.rowW);
    const startX = clamp(Math.round(anchorX - (row.rowW * 0.5)), minX, maxX);
    let x = startX;
    const localRects = [];
    const localPos = [];
    const byId = new Map();
    for(const item of row.items){
      if(!item.id){
        x += item.w + g;
        continue;
      }
      const y = Math.round(centerY - (item.h * 0.5));
      const rect = makeDockRect(Math.round(x), y, item.w, item.h, 0);
      if(!fitsDockRect(rect, vw, vh, obstacles, placed.concat(localRects))){
        return { ok: false, top: y, byId: new Map() };
      }
      localRects.push(rect);
      localPos.push({ id: item.id, x: Math.round(x), y });
      byId.set(item.id, { x: Math.round(x), y, w: item.w, h: item.h });
      x += item.w + g;
    }
    for(const pos of localPos){
      const btn = dockControlById.get(pos.id);
      if(!btn) continue;
      btn.classList.add("dockObject");
      btn.style.left = `${pos.x}px`;
      btn.style.top = `${pos.y}px`;
      placedIds.add(pos.id);
    }
    for(const rect of localRects){
      placed.push(rect);
    }
    const rowTop = Math.round(centerY - row.up);
    return { ok: true, top: rowTop, byId };
  }

  const row1 = buildRow([
    { id: "tabLanguageBtn" },
    { id: "tabColorsBtn" },
    { id: "tabInfoBtn" }
  ]);
  const row2 = buildRow([
    { id: "lockCompositionBtn" },
    { id: "tabSpeedBtn" },
    { id: "dockPlayback" },
    { id: "tabContrastBtn" }
  ]);
  const row3 = buildRow([
    { id: "fsBtn" },
    { id: "", w: menuW + DOCK_MENU_SPACER_EXTRA, h: menuH },
    { id: "screenshotBtn" }
  ]);

  const row3CenterY = anchorY;
  const row2CenterY = row3CenterY - (row2.down + rowGap + row3.up);
  const row1CenterY = row2CenterY - (row1.down + rowGap + row2.up);

  const p3 = placeRow(row3, row3CenterY);
  if(!p3.ok) return { placedIds, panelPlaced: false };
  const p2 = placeRow(row2, row2CenterY);
  if(!p2.ok) return { placedIds, panelPlaced: false };
  const p1 = placeRow(row1, row1CenterY);
  if(!p1.ok) return { placedIds, panelPlaced: false };

  if(shouldUsePanelTileLayout(vw, vh, activePage)){
    const panelPlaced = placeOpenPanelTiles(anchorX, anchorY, vw, vh, obstacles, placed, {
      centerX: vw * 0.5,
      panelTopLimit: p1.top - panelGap
    });
    return { placedIds, panelPlaced };
  }

  if(!panelWrapEl || !panelMeasure || panelMeasure.w <= 0 || panelMeasure.h <= 0){
    return { placedIds, panelPlaced: false };
  }

  const panelAnchorX = vw * 0.5;
  const maxPanelLeft = Math.max(DOCK_LAYOUT_MARGIN, vw - DOCK_LAYOUT_MARGIN - panelMeasure.w);
  const panelBottom = p1.top - panelGap;
  const safe = getSceneSafeRect();
  const safeBottom = safe ? safe.bottom : (vh * 0.5);
  const minPanelY = Math.max(DOCK_LAYOUT_MARGIN, Math.round(safeBottom + UI_SAFE_GAP_PX + 6));
  const maxPanelY = Math.max(minPanelY, Math.round(panelBottom - panelMeasure.h));
  const centeredGapY = Math.round(minPanelY + ((maxPanelY - minPanelY) * 0.5));

  const yCandidates = [centeredGapY, maxPanelY, minPanelY];
  const xCandidates = [0, -16, 16, -32, 32, -48, 48];
  let panelRect = null;
  let panelX = 0;
  let panelY = centeredGapY;

  for(const yTry of yCandidates){
    for(const d of xCandidates){
      const x = clamp(Math.round(panelAnchorX - (panelMeasure.w * 0.5) + d), DOCK_LAYOUT_MARGIN, maxPanelLeft);
      const y = clamp(Math.round(yTry), DOCK_LAYOUT_MARGIN, Math.max(DOCK_LAYOUT_MARGIN, vh - DOCK_LAYOUT_MARGIN - panelMeasure.h));
      const rect = makeDockRect(x, y, panelMeasure.w, panelMeasure.h, 0);
      if(fitsDockRect(rect, vw, vh, obstacles, placed)){
        panelRect = rect;
        panelX = x;
        panelY = y;
        break;
      }
    }
    if(panelRect) break;
  }

  if(!panelRect){
    // Deterministic fallback: keep buttons stable, then find any legal spot for panel.
    const panelSpot = findDockSpot("__panel__", panelMeasure, panelAnchorX, Math.min(anchorY, maxPanelY), vw, vh, obstacles, placed, {
      stepX: DOCK_GRID_MIN_STEP_X,
      stepY: DOCK_GRID_MIN_STEP_Y,
      maxRing: DOCK_PANEL_MAX_RING
    });
    panelX = Math.round(panelSpot.x);
    panelY = Math.round(panelSpot.y);
    panelRect = panelSpot.rect;
  }

  panelWrapEl.style.left = `${panelX}px`;
  panelWrapEl.style.top = `${panelY}px`;
  panelWrapEl.style.bottom = "auto";
  panelWrapEl.style.transform = "none";
  obstacles.push(panelRect);
  placed.push(panelRect);
  return { placedIds, panelPlaced: true };
}

function layoutDockObjects(){
  if(!dockControlBtns.length) return;
  const { w: vw, h: vh } = getViewportSize();
  if(vw <= 0 || vh <= 0) return;
  clearPanelFloatingTiles();

  const menuRect = menuToggleBtn ? menuToggleBtn.getBoundingClientRect() : null;
  const anchorX = menuRect ? (menuRect.left + (menuRect.width * 0.5)) : (vw * 0.5);
  const anchorY = menuRect ? (menuRect.top + (menuRect.height * 0.5)) : (vh - 34);

  const obstacles = getDockObstacles();
  const placed = [];
  const measuresById = new Map();
  const order = getDockLayoutOrder();
  const activePage = String(document.body.dataset.uiPage || "none");
  const panelOpen = activePage !== "none";
  const panelRectMeasure = panelInnerEl ? panelInnerEl.getBoundingClientRect() : (panelWrapEl ? panelWrapEl.getBoundingClientRect() : null);
  const panelMeasure = panelWrapEl ? {
    w: Math.max(42, Math.ceil((panelRectMeasure && panelRectMeasure.width) || panelWrapEl.scrollWidth || 0)),
    h: Math.max(24, Math.ceil((panelRectMeasure && panelRectMeasure.height) || panelWrapEl.scrollHeight || 0)),
    tipTop: 0
  } : null;
  for(const id of order){
    const btn = dockControlById.get(id);
    if(!btn) continue;
    const m = measureDockControl(btn);
    measuresById.set(id, m);
  }

  if(shouldUseBandedMobileLayout(vw, vh)){
    const placedIds = placeBandedDockRows(vw, vh, obstacles, placed, measuresById);
    if(panelOpen){
      const safe = getSceneSafeRect();
      placeOpenPanelTiles(anchorX, anchorY, vw, vh, obstacles, placed, {
        centerX: vw * 0.5,
        panelTopLimit: safe ? Math.round(safe.top - 6) : Math.round(vh * 0.46)
      });
    }

    const layoutCfg = {
      stepX: DOCK_GRID_MIN_STEP_X,
      stepY: DOCK_GRID_MIN_STEP_Y,
      maxRing: DOCK_GRID_MAX_RING
    };
    for(const id of order){
      const btn = dockControlById.get(id);
      if(!btn) continue;
      if(placedIds.has(id)) continue;
      btn.classList.add("dockObject");
      const measure = measuresById.get(id) || measureDockControl(btn);
      const spot = findDockSpot(id, measure, anchorX, anchorY, vw, vh, obstacles, placed, layoutCfg);
      btn.style.left = `${Math.round(spot.x)}px`;
      btn.style.top = `${Math.round(spot.y)}px`;
      placed.push(spot.rect);
    }
    return;
  }

  const layoutCfg = {
    stepX: DOCK_GRID_MIN_STEP_X,
    stepY: DOCK_GRID_MIN_STEP_Y,
    maxRing: DOCK_GRID_MAX_RING
  };
  const presetPlacedIds = (!panelOpen)
    ? placePresetDockCluster(anchorX, anchorY, vw, vh, obstacles, placed, measuresById)
    : (placeOpenDockCluster(anchorX, anchorY, vw, vh, obstacles, placed, measuresById, panelMeasure).placedIds || new Set());

  for(const id of order){
    const btn = dockControlById.get(id);
    if(!btn) continue;
    if(presetPlacedIds.has(id)){
      continue;
    }
    btn.classList.add("dockObject");
    const measure = measuresById.get(id) || measureDockControl(btn);
    const spot = findDockSpot(id, measure, anchorX, anchorY, vw, vh, obstacles, placed, layoutCfg);
    btn.style.left = `${Math.round(spot.x)}px`;
    btn.style.top = `${Math.round(spot.y)}px`;
    placed.push(spot.rect);
  }
}

function scheduleDockLayout(){
  if(dockLayoutRaf) return;
  dockLayoutRaf = requestAnimationFrame(()=>{
    dockLayoutRaf = 0;
    layoutDockObjects();
  });
}

function applyDockConstellationState(){
  const activePageOpen = !!(document.body.dataset.uiPage && document.body.dataset.uiPage !== "none");
  const focusId = activePageOpen ? dockActiveBtnId : (dockHoverBtnId || dockActiveBtnId);
  [prevPoemBtn, pausePoemBtn, nextPoemBtn].filter(Boolean).forEach((btn)=>{
    btn.classList.remove("dockControl", "dockObject", "dock-shrink", "dock-focus", "dock-hover-focus", "dock-hover-shrink", "dock-tip-open");
    btn.style.left = "";
    btn.style.top = "";
  });
  dockControlBtns.forEach((btn)=>{
    btn.classList.add("dockControl", "dockObject");
    btn.classList.remove("dock-shrink", "dock-focus", "dock-hover-focus", "dock-hover-shrink", "dock-tip-open");

    if(!focusId) return;
    const isFocus = btn.id === focusId;
    if(dockHoverBtnId && !activePageOpen){
      btn.classList.add(isFocus ? "dock-hover-focus" : "dock-hover-shrink");
    }else{
      btn.classList.add(isFocus ? "dock-focus" : "dock-shrink");
    }
    if(dockHoverBtnId === btn.id && btn.dataset && btn.dataset.tip){
      btn.classList.add("dock-tip-open");
    }
  });

  if(menuToggleBtn){
    menuToggleBtn.classList.remove("dock-focus", "dock-hover-focus");
    if(focusId){
      if(dockHoverBtnId && focusId === "menuToggleBtn"){
        menuToggleBtn.classList.add("dock-hover-focus");
      }else if(focusId === "menuToggleBtn"){
        menuToggleBtn.classList.add("dock-focus");
      }
    }
  }
}

function syncMenuTogglePosition(){
  scheduleDockLayout();
}

function applyDockClickResponse(e){
  if(!e || typeof e.clientX !== "number" || typeof e.clientY !== "number") return;
  const el = e.currentTarget;
  if(!el || !el.getBoundingClientRect) return;
  const r = el.getBoundingClientRect();
  if(r.width <= 0 || r.height <= 0) return;

  scheduleDockLayout();
}

function setDockActiveButton(btnId){
  dockActiveBtnId = String(btnId || "");
  applyDockConstellationState();
  scheduleDockLayout();
}

/* ================= Dock placement ================= */
function placeDockForViewport(){
  if(!dockEl || !dockTopHostEl || !dockBottomHostEl) return;
  const target = dockBottomHostEl;
  const other = dockTopHostEl;
  if(dockEl.parentElement !== target){
    target.appendChild(dockEl);
  }
  // Prevent empty hosts from affecting layout.
  target.style.display = "";
  other.style.display = "none";
  scheduleDockLayout();
  scheduleUiSafeUpdate();
}

/* ================= Mobile UI pages ================= */
const UI_PAGES = ["none","language","info","contrast","colors","speed"];
let uiPage = "none";
function setTabPressed(btn, on){
  if(!btn) return;
  btn.classList.toggle("on", on);
  btn.setAttribute("aria-pressed", on ? "true" : "false");
  btn.setAttribute("aria-selected", on ? "true" : "false");
}
function assignMobileTabColors(){
  // Unified theme: controls match the live card color.
  applyButtonColors();
}
function setUiPage(next){
  const page = UI_PAGES.includes(next) ? next : "none";
  // Tap the active tab again to collapse back to "tabs only".
  const finalPage = (uiPage === page && page !== "none") ? "none" : page;
  uiPage = finalPage;
  document.body.dataset.uiPage = finalPage;
  setTabPressed(tabLanguageBtn, finalPage === "language");
  setTabPressed(tabInfoBtn, finalPage === "info");
  setTabPressed(tabContrastBtn, finalPage === "contrast");
  setTabPressed(tabColorsBtn, finalPage === "colors");
  setTabPressed(tabSpeedBtn, finalPage === "speed");
  if(finalPage === "language") setDockActiveButton("tabLanguageBtn");
  else if(finalPage === "info") setDockActiveButton("tabInfoBtn");
  else if(finalPage === "contrast") setDockActiveButton("tabContrastBtn");
  else if(finalPage === "colors") setDockActiveButton("tabColorsBtn");
  else if(finalPage === "speed") setDockActiveButton("tabSpeedBtn");
  else{
    dockHoverBtnId = "";
    setDockActiveButton("");
    // Reset any sticky focus state so closed state returns to the load layout.
    if(document.activeElement && typeof document.activeElement.blur === "function"){
      document.activeElement.blur();
    }
    requestAnimationFrame(()=> requestAnimationFrame(scheduleDockLayout));
  }

  // Recolor on every page switch.
  assignMobileTabColors();

  // Keep the sliding panel out of the phrase/card region (especially on mobile landscape).
  syncMenuTogglePosition();
  scheduleUiSafeUpdate();
}

/* ================= UI Safe Zone (Never Overlap Phrase/Card) ================= */
// The "safe zone" is the card (if enabled) or the phrase ink bounds (if card is off).
// We clamp the sliding panel max-height so it cannot rise into that zone.
const UI_SAFE_GAP_PX = 10;
let uiSafeRaf = 0;

function getSceneSafeRect(){
  const { w: vw, h: vh } = getViewportSize();
  if(vw <= 0 || vh <= 0) return null;

  const cardVisible = !!cardEl && (getComputedStyle(cardEl).display !== "none");

  let r = null;
  if(cardVisible){
    r = cardEl.getBoundingClientRect();
  }else{
    const ink = phraseInkBounds();
    if(ink) r = ink;
    else r = phraseEl.getBoundingClientRect();
  }
  if(!r || !Number.isFinite(r.top) || !Number.isFinite(r.bottom)) return null;

  const left = clamp(r.left, 0, vw);
  const right = clamp(r.right, 0, vw);
  const top = clamp(r.top, 0, vh);
  const bottom = clamp(r.bottom, 0, vh);
  return { left, right, top, bottom };
}

function rectsOverlap(a, b, gap=0){
  if(!a || !b) return false;
  return !(
    (a.right + gap) <= b.left ||
    (b.right + gap) <= a.left ||
    (a.bottom + gap) <= b.top ||
    (b.bottom + gap) <= a.top
  );
}

function updatePanelSafeMaxHeight(){
  if(!panelWrapEl) return;
  const open = document.body.dataset.uiPage && document.body.dataset.uiPage !== "none";
  if(!open){
    panelWrapEl.style.setProperty("--panelMaxH", "0px");
    scheduleDockLayout();
    return;
  }

  const { w: vw, h: vh } = getViewportSize();
  const activePage = String(document.body.dataset.uiPage || "none");
  if(shouldUsePanelTileLayout(vw, vh, activePage)){
    panelWrapEl.style.setProperty("--panelMaxH", "0px");
    scheduleDockLayout();
    return;
  }

  const desiredPanelH = Math.ceil((panelInnerEl ? panelInnerEl.scrollHeight : panelWrapEl.scrollHeight) + 2);
  const maxH = clamp(Math.max(0, desiredPanelH), 0, Math.max(0, Math.floor(vh - (DOCK_LAYOUT_MARGIN * 2))));
  panelWrapEl.style.setProperty("--panelMaxH", `${maxH}px`);
  scheduleDockLayout();
}

function scheduleUiSafeUpdate(){
  if(uiSafeRaf) return;
  uiSafeRaf = requestAnimationFrame(()=>{
    uiSafeRaf = 0;
    updatePanelSafeMaxHeight();
  });
}

/* ================= Scene Gestures (Drag / Pinch Scale) ================= */
const SCENE_ZOOM_MIN = 0.5;
const SCENE_ZOOM_MAX = 3.0;
let sceneZoom = 1;
const sceneGesture = {
  active: false,
  mode: "none",
  pointers: new Map(),
  startZoom: 1,
  startY: 0,
  startDist: 1
};

function setSceneZoom(next){
  const z = clamp(Number(next), SCENE_ZOOM_MIN, SCENE_ZOOM_MAX);
  if(!Number.isFinite(z)) return;
  if(Math.abs(z - sceneZoom) < 0.0005) return;
  sceneZoom = z;
  document.documentElement.style.setProperty("--sceneZoom", sceneZoom.toFixed(3));
  applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
}

function pointInRect(x, y, r){
  return !!r && x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
}

function getSceneGestureRect(){
  const cardShown = !!cardEl && getComputedStyle(cardEl).display !== "none";
  if(cardShown){
    return cardEl.getBoundingClientRect();
  }
  return phraseInkBounds() || phraseEl.getBoundingClientRect();
}

function isUiTarget(target){
  if(!target || !target.closest) return false;
  return !!target.closest("#titleBlock, #bar, #menuToggleBtn");
}

function refreshSceneGestureMode(){
  const points = Array.from(sceneGesture.pointers.values());
  if(points.length >= 2){
    const [a, b] = points;
    sceneGesture.mode = "pinch";
    sceneGesture.startDist = Math.max(1, Math.hypot(a.x - b.x, a.y - b.y));
    sceneGesture.startZoom = sceneZoom;
    return;
  }
  if(points.length === 1){
    sceneGesture.mode = "drag";
    sceneGesture.startY = points[0].y;
    sceneGesture.startZoom = sceneZoom;
    return;
  }
  sceneGesture.mode = "none";
  sceneGesture.active = false;
}

function onScenePointerDown(e){
  if(e.pointerType === "mouse" && e.button !== 0) return;
  if(isUiTarget(e.target)) return;

  const inScene = pointInRect(e.clientX, e.clientY, getSceneGestureRect());
  const allowSecondTouch = sceneGesture.active && sceneGesture.pointers.size === 1 && e.pointerType !== "mouse";
  if(!inScene && !allowSecondTouch) return;

  sceneGesture.active = true;
  sceneGesture.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
  refreshSceneGestureMode();
  if(e.target && typeof e.target.setPointerCapture === "function"){
    try{ e.target.setPointerCapture(e.pointerId); }catch(_){}
  }
  e.preventDefault();
}

function onScenePointerMove(e){
  if(!sceneGesture.pointers.has(e.pointerId)) return;
  sceneGesture.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

  if(sceneGesture.mode === "drag" && sceneGesture.pointers.size === 1){
    const p = sceneGesture.pointers.get(e.pointerId);
    const dy = p.y - sceneGesture.startY;
    const next = sceneGesture.startZoom * Math.exp(-dy / 220);
    setSceneZoom(next);
    e.preventDefault();
    return;
  }

  if(sceneGesture.pointers.size >= 2){
    const points = Array.from(sceneGesture.pointers.values());
    const dist = Math.max(1, Math.hypot(points[0].x - points[1].x, points[0].y - points[1].y));
    const next = sceneGesture.startZoom * (dist / sceneGesture.startDist);
    setSceneZoom(next);
    e.preventDefault();
  }
}

function onScenePointerEnd(e){
  if(!sceneGesture.pointers.has(e.pointerId)) return;
  sceneGesture.pointers.delete(e.pointerId);
  if(e.target && typeof e.target.releasePointerCapture === "function"){
    try{ e.target.releasePointerCapture(e.pointerId); }catch(_){}
  }
  refreshSceneGestureMode();
}

/* ================= Selection state ================= */
const sel = {
  parts: new Set(["description","person","action","location"]),
  bgColor: new Set(ALL_SWATCH_COLORS),
  fgColor: new Set(ALL_SWATCH_COLORS),
  bdColor: new Set(ALL_SWATCH_COLORS),
  borderEnabled: true,
  borderThickness: Number(bdThickEl.value)
};

/* ================= Vocab banks ================= */
/*
  Editing tips:
  - One entry per line.
  - Blank lines are fine.
  - Everything is lowercased + de-duped at runtime.
*/
function vocabLines(str){
  return uniq(
    str
      .split("\n")
      .map(s => String(s).replace(/\r/g, "").trim())
      .filter(Boolean)
      .map(s => s.toLowerCase())
  );
}

/* description (object) */
const DESC_OBJECT = vocabLines(`
brittle
woolen
velvety
ashen
antique
stately
baggy
bent
folded neatly
brassy
brilliant
bumpy
burnt
buttery
buzzing
charming
crumbly
crunchy
lightly crushed
drafty
dreamy
dusty
dimly lit
feathery
flashy
flavorful
fleshy
foamy
frosted
fruity
fried
furry
gentle
ghostly
gigantic
greasy
hard
jealous
joyful
jazzy
jiggly
leisurely
lively
messy
moldy
mysterious
nervous
oily
orderly
ornamental
painted
pearly
pillowy
poetic
poignant
polished
powdery
ribbed
rocky
salty
sandy
scrambled
sculpted
sculptural
slimy
slippery
smelly
smoggy
soft
stormy
strange
strappy
sweet
thick
thirsty
windy
worried
wrapped
sweaty
sunset
daybreak
elevated
elongated
smooth
curly
twisted
wiggly
burnished
reclusive
exploratory
introverted
dingy
patched
repaired
tarnished
melted
enlarged
moist
dewy
plump
buff
extended
compact
oversized
skimpy
malaise
ennui
weary
blas
detached
indifferent
futile
languid
listless
vivacious
zestful
vigorous
verve
lan
immersed
flowing
delighted
radiant
witty
buoyant
spontaneous
lighthearted
attentive
subtle
nuanced
deft
precise
perceptive
evocative
suggestive
sparkly
glittery
loud
silent
muffled
wet
damp
dry
cracked
spilt
spoiled
rotten
fresh
growing
withering
elegant
crude
muscular
lean
long
short
tall
slim
chubby
cute
ugly
beautiful
contrasting
hairy
bald
shaved
stubbly
rough
matte
glossy
refined
understated
restrained
poised
tailored
classical
grand
petite
considered
ritualistic
witchy
dried out
lumpy
mindful
civilized
unhurried
guarded
formal
discreet
reserved
confident
diaphanous
opalescent
iridescent
mother-of-pearl
inlaid
sunken
padded
carpeted
sullen
supple
undulating
ubiquitous
obsequious
dulcet
flickering
fugitive
insular
smoky
atonal
hushed
muted
esoteric
arcane
hermetic
cryptic
wistful
pensive
yearning
plaintive
ethereal
reflective
nostalgic
reminiscent
unspoken
unrequited
accepting
tempered
subdued
veiled
balanced
tasteful
delicate
poorly proportioned
gracefully arranged
lightly worn
tenderly handled
gently used
herringbone
stone
quartz
emerald
ruby
diamond encrusted
granite
marble
soapstone
soapy
tie-died
asymmetrical
unbalanced
effervescent
despondent
petulant
hedonistic
gluttonous
malnourished
overflowing
puffy
bloated
maladjusted
transparent
translucent
decaying
plaintive
rueful
unctuous
a sycophantic
anti-fascist
ossified
vermicular
serene
freshly repaired
compact
pocket-sized
distended
muscular
lithe
`);

/* description (person) */
const DESC_PERSON = vocabLines(`
retired
blonde
introverted
kleptomaniac
handsome
shaved
athletic
hedonistic
fastidious
lithe
chubby
skeletal
tattooed
blue collar

 tall
 pregnant
 short
 non-binary
 young
 youthful
 lanky
 failed
 transsexual
 old
 teenaged
 specialized
 infantile
 amateur
 professional
 skilled
 bumbling
 hapless
 feckless
 disgruntled
 irritated
 irate
 cranky
 clever
 gray-haired
 balding
 artistic
 eager
 dancing
 skanky
 female
 male
 new
 weary
 exhausted
 zippy
 jet-lagged
 quick-thinking
 frugal
 dehydrated
 desperate
 hateful
 generous
 incompetent
 gorgeous
 annoying
 witchy
 hairless
 excited
 well dressed
 elegant
 stylish
 chic
 uptight
 down-to-earth
 earthy
 foolish
 divorced
 unwed
 tiny
 slim
 curvy
 bloated
 dried out
 depressed
 unemployed
 slumped-over
 leggy
 tired
 glamorous
 lethargic
 crude
 illiterate
 educated
 scholarly
 pretentious
 humble
 rude
 betrayed
 stunned
 sober
 alcoholic
 paint splattered
 distraught
 gay
 sleepy
 heterosexual
 easygoing
 good natured
 creepy
 sweaty
 moody
 unhappy
 french
 italian
 greek
 greedy
 adventurous
 scandalized
 prudish
 high strung
 easy going
 tightly wound
 wounded
 injured
 indigenous
 red headed
 long haired
 short haired
 greasy
 obsessive
 introspective
 slimy
 dorky
 cool
 fresh-faced
 jaded
 surly
 over-dressed
 under-dressed
 scantily clad
 petulant
 bratty
 disgraced
 clueless
 unaware
 prickly
 shrewd
 punk rock
 hipster
 steampunk
 rockabilly
 jazzy
 funky
 broke
 barefoot
 sunburned
 naive
 idealistic
 optimistic
 pessimistic
 prospective
 potential
 future
 former
 recovering
 british
 underground
 indie
 popular
 famous
 infamous
 wealthy
 rich
 poor
 charming
 flashy
 glitzy
 spunky
 vivacious
 unpleasant
 uncomfortable
 awkward
 nerdy
 suave
 worldly
 inexperienced
 immature
 sophisticated
 snappy
 hilarious
 ridiculous
 blind
 deaf
 elite
 insular
 closed-minded
 bigoted
 insecure
 confident
 brassy
 feminine
 butch
 queer
 plus-sized
 petite
 primped
 overstimulated
 overwhelmed
 shy
 gen-x
 witty
 eccentric
 frazzled
 progressive
 conservative
 liberal
 right-wing
 left-wing
 leftist
 maoist
 communist
 socialist
 ribald
 erudite
 pacifist
 aggressive
 talkative
 quiet
 silent
  autistic
  neuro divergent
  virginal
  anarchist
  antifa
`);

/* object */
const OBJECTS = vocabLines(`
dish rack
drying rack
clothes line
shower head
kitchen sink
vanity mirror
hair brush
toilet paper
coffee mug
tea pot
tea bag
coffee maker
french press
percolator
frying pan
cutting board
crock pot
soupspoon
laundry basket
laundry hamper
trash can
mop bucket
broom
bed
mattress
bookshelf
bookcase
curtains
doorknob
window
lamp
lampshade
clock
wrist watch
cabinet
drawer
coffee table
ottoman
couch
love seat
chaise longue
cushion
throw pillow
duvet
comforter
bath tub
hot tub
jacuzzi
lipstick
lip gloss
blush
makeup
nail polish
perfume bottle
deodorant
hair clip
hair tie
high heels
tights
pantyhose
cardigan
turtleneck
necklace
bracelet
wedding band
ring
pendant
pizza box
mini fridge
refrigerator
oven
freezer
closet
hardwood floor
carpet
rug
upholstery
remote control
computer monitor
ipad
tablet
wardrobe
drapery
portrait
trophy
moving boxes
linen napkin
room service tray
soap
keyboard
printer
xerox machine
photocopier
cash register
envelope
notebook
dictionary
paperback book
workbench
sawhorse
chisel
paint brush
spray paint
ink wash
canvas
plywood
ladder
toolbox
tape measure
scissors
drill press
table saw
bandsaw
vacuum cleaner
hot glue gun
dental pick
drill
office cubicle
lecture hall
waiting room
doctor's office
library
gallery
museum
atm
seltzer
diner booth
martini
cocktail
wine glass
taqueria
dive bar
dance club
punk club
rave
comedy club
microphone
record store
playing cards
chess board
board game
video game
playstation
slot machine
grand piano
pipe organ
drum kit
synthesizer
bicycle
station wagon
hatchback
convertible
sports car
subaru forester
water slide
trailhead
switchback
mountain lodge
skis
baseball bat
harmonica
folded map
ticket stub
drinking glass
beer stein
high ball glass
ash tray
dust pan
chapstick
dining room table
end table
bedside table
night stand
foot rest
foot stool
step ladder
scaffolding
beer can
beer bottle
canned cocktail
mocktail
mojito
margarita
pilsner
lager
guinness
draft beer
ros wine
glass of blush
hot toddy
green juice
celery juice
pomegranate juice
carrot juice
tomato juice
noodles
legal pad
note pad
eye drops
bluetooth speaker
suv
mini-van
lawn mower
air conditioner
recycling bin
white glue
superglue
krazy glue
bouncy ball
bacon egg and cheese
bagel with cream cheese
peanut butter and jelly
hero sandwich
gyro
mission style burrito
enchiladas
t-shirt
tank top
scoop neck shirt
spaghetti strap tank top
undershirt
tube top
push-up bra
bralette
lace thong
lace underwear
lace bra
halter top
knit sweater
knitting needles
ball of yarn
cheeseburger
hamburger
big mac
fried chicken sandwich
grilled chicken sandwich
couscous
quinoa
grain bowl
paint bucket
side salad
caesar salad
greek salad
cucumber salad
seaweed salad
garlicky kale
rice bowl
mexican food
italian food
french food
japanese food
korean food
ham sandwich
ramen
bento box
japanese curry
chicken katsu
karaage
nashville hot fried chicken
pulled pork sandwich
pastrami on rye
egg salad
poached egg
hard boiled egg
soft boiled egg
fried rice
wicker basket
cross-body bag
denim skirt
handbag
shopping cart
purse
catchers mitt
baseball glove
fingerless gloves
driving gloves
steering wheel
gaming chair
rocking chair
vending machine
slate tile
granite counter tops
bulletin board
tie pin
name tag
sheriff's badge
bunk beds
futon
keg of beer
fur pelt
participation trophy
absinthe
fernet
aperol spritz
tequila shot
whisky sour
moo shu pork
propeller beanie
metal detector
geiger counter
nitrous oxide canister
baggie of ketamine
heroin spoon
bag of weed
mushroom chocolate
tab of acid
laser pointer
dvd player
hedge trimmer
weed whacker
dirt bike
chopper
pinwheel
solar panel
sprinter van
ford bronco
riding lawn mower
instruction manual
printed out pdf
roku tv
flip phone
trade paperback
dvd box set
blu-ray player
cd-rom
oled panel
circuit board
circuit breaker
portable fan
croquet mallet
croquette
sizzling fajita platter
bibimbap
wedge salad
director's chair
padded booth
straight jacket
hot dog cart
x-ray machine
samovar of coffee
electric kettle
air fryer
wine decanter
whoopie cushion
sound board
alarm bell
birdbath
birdcage
birdhouse
hourglass
sundial
pendulum
pocket watch
velvet rope
bank vault
water tower
traffic median
airport shuttle
dune buggy
dump truck
freight train
gondola
greenhouse
terrarium
record player
typewriter
ukulele
trombone
tambourine
saxophone
banjo
bagpipe
brownstone
townhouse
alleyway
dumpster
manhole cover
sewer
parking garage
parking lot
driveway
parachute
bungee cord
propeller
umbrella
cooler
cardboard box
tissue box
newspaper
tombstone
baby bottle
maxi pad
deck chair
neon sign
fidget spinner
pack of cigarettes
bow tie
christmas lights
shop vac
crushed cicodin
line of cocaine
hash pipe
opium tea
welding mask
latex mask
leather gloves
hairpiece
chunky heels
reading glasses
tap shoes
kitten heels
sensible pumps
strappy sandals
potted plant
succulent garden
old washing machine
`);

/* person */
const PERSONS = vocabLines(`
nun
painter
bathroom attendant
substitute teacher
step-dad

 art therapist
 couples therapist
 woodcarver
 athlete
 machinist
 woman
 man
 grandpa
 grandma
 step-mom
 day trader
 producer
 farmer
 sculptor
 architect
 refugee
 immigrant
 butt-head
 fascist
 singer
 roadie
 trucker
 journalist
 reporter
 newscaster
 podcaster
 politician
 bully
 jock
 straight guy
 guitar player
 piano player
 florist
 flautist
 jazz singer
 tech bro
 poet
 student
 brain surgeon
 intern
 novelist
 mayor
 police officer
 meter maid
 standup comic
 improv comic
 playwright
 jerk
 mother
 father
 person
 guy
 artist
 dancer
 performance artist
 gymnast
 pervert
 luddite
 dude
 bro
 stud
 babe
 model
 chef
 photographer
 shopkeep
 boat builder
 crane operator
 nurse
 hair stylist
 barber
 insurance broker
 ex-wife
 ex-husband
 businessman
 businesswoman
 masseuse
 waitress
 waiter
 flight attendant
 secretary
 bodega guy
 neighbor
 best friend
 acquaintance
 friend
 roommate
 housemate
 grad student
 coal miner
 chaperone
 dj
 middle manager
 employee
 art teacher
 gym teacher
 homosexual
 heterosexual
 insomniac
 homeowner
`);

/* action */
const ACTIONS = vocabLines(`
blowing in the wind
soaking wet
floating
stretched out
upside-down
broken
misaligned
rusted
left out overnight
cooling slightly
resting quietly
waiting in line
balanced on a ledge
caught in the rain
glowing softly
drying on a rack
spilling a little
sitting untouched
freshly unpacked
carefully stacked
sliding across a table
tucked into a drawer
leaning against a wall
half-finished
freshly cleaned
still warm
still damp
shaking slightly
humming faintly
flickering
dripping quietly
vibrating faintly
flickering softly
humming to itself
half submerged
zipping a suitcase slowly
resting against a window
opening the shutters
standing at the window while the city wakes
steaming
melting on a slice of warm toast
lighting a candle
blowing out a candle
gently dabbing perfume
people watching
caught in a summer rain
under dappled light
pressed into velvet
soaked in sweat
smudged at the edges
warped by heat
straining its seams
wrapped in tape
staining the counter
ringing slightly
treading mud onto the carpet
a little damp
glistening
knocked over
getting a tattoo
shoplifting
crushing garlic
slicing onions
wandering aimlessly
jogging first thing in the morning
pulled a muscle
picking a scab
popping a pimple
vibrating
flossing aggressively
sunbathing
polishing boots
making a smoothie
gesturing wildly
fidgeting anxiously
impatiently waiting
soul-searching
looking within
filled with an overwhelming sense of dread
overcome with malaise
suffering silently
dented on the corner
slightly angled
with a skewed perspective
shopping
bored
is smoking a cigarette
sucking on a vape pen
blowing smoke rings
doing kegels
effortlessly arranged
nonchalantly tossed aside
with chipped paint
wrapped in plastic
mounted to the wall
cast in bronze
buried in the back yard
stuck in mud
splayed apart
cast aside
smoldering
glistening
growing taller
getting shorter
shrinking
singing softly
touching itself
throwing a frisbee
playing mini golf
getting a haircut
floating
drying out in the sun
resigned to its fate
crunching the numbers
driving a tractor
buried under rubble
rescued from danger
stuck in a rut
approaching middle age
on its last legs
kicking back
searching for meaning
losing weight
rocking back and forth
self-soothing
comparison shopping
filled with jealousy
stuck in traffic
is getting annoyed
rolling downhill
putting its feet up
tapping lightly
scratching itself
masturbating furiously
committing perjury
serving on a jury
performing surgery
studying german
flipping through a magazine
wearing cutoffs
wearing a bikini
strutting its stuff
freak dancing
doing the macarena
twisting and turning
spinning in circles
pogo dancing
bouncing up and down
buying crypto
lip-syncing
covered in vaseline
lubed up
toweled dry
resting
taking a load off
emitting a high pitched sound
howling
hooting
smiling
frowning
weeping
grinning to itself
standing alone
looking out the window
staring into the middle-distance
losing interest
bored
grumpy
cranky
clingy
getting the ick
sitting on a balcony
left out in the cold
getting moldy
licking its wounds
sick of arguing
with nothing to say
keeping its head down
sobbing softly
caught crying
holding back tears
jacking off
committing fraud
on the run
in hiding
tucked into bed
hiding under the covers
stuck in a tree
carving marble
falling down
toppled over
perfectly posed
out of reach
sipping from a hip flask
doing a keg stand
dehydrated
a little damp
stewing in its own juices
marinating overnight
sitting under a heat lamp
under scrutiny
rollerblading
getting a vitamin drip
squeezing lemons
dancing in the moonlight
dancing in the rain
feeling dried out
meditating
doomscrolling
checking instagram
logging off
with a cracked screen
with a thick accent
tightly wound
carved from a block of wood
getting reupholstered
leaning back
dancing
covered in paint
in a bath robe
in a nightgown
with a bouquet of flowers
under a pile of clothes
cast aside
at the bottom of a well
in despair
overcome with happiness
proud of itself
with incredible skin
blemish-free
dewy-faced
doe eyed
feeling betrayed
got dumped
caught in the rip current
pulled out to see
overeating
binge drinking
hedonistically indulging
sailing east
riding a dirtbike
landing a kickflip
getting its nails done
getting its hair done
getting its eyebrows tweezed
feeling discouraged
lazily napping
faking an orgasm
practically melting
is ready for a change
is burning bridges
is mending fences
is pissed off
is being gently caressed
all scratched up
is getting wasted
feeling blue
is all tuckered out
is over it
is sitting on its side
is draped in silk
is getting encased in resin
is becoming oxidized
being ignored
getting chilly
working through something

singing acapella
feeling itself
touching itself
rubbing its neck
smoking a joint
vaping
chewing nicotine gum
revealing a mean streak
declaring love
proposing marriage
in a situationship
casually dating
still single
rolling a spliff
with a dark sense of humor
with a proclivity for the absurd
painting its nails
waxing its legs
hurling insults
tipping generously
ordering a drink
receiving electrolysis
strutting its stuff
pulling itself together
hiking its skirt up
flipping through a magazine
snooping through drawers
counting money
softly weeping
running its fingers through its hair
lightly tapping
impatiently waiting
extremely bored
pooping
farting
breaking wind
passing gas
getting sick
feeling nauseous
overheated
struggling with insomnia
mining bitcoin
updating its website
ignoring its text messages
online shopping
committing tax fraud
looking for a roommate
uncrossing its legs
drinking a cold glass of milk
preparing matcha tea
dicing onions
holding back tears
weeping
losing control
having a moment
loving life
really likes it
at peace
at rest
held at gunpoint
under arrest
protesting the genocide
using nonviolent resistance
maintaining control
feeling so gross
learning how to whistle
dimming the lights
doing pilates
doing downward dog
sitting on a milk crate
thinking about its dog
seeking forgiveness
delivering a message
facing dire consequences
charging its phone
looking around
snooping
violently scratching itself
sanding furniture
looking for its underwear
dripping wet
getting a boner
horny
doesn't smell great
pissed off
receiving communion
getting circumcised
learning about plants
making an omelette
eating french fries
drinking a martini
dropped a plate of spaghetti
knocked over a bottle of wine
slowly rotating
spinning out of control
rolling around in an office chair
checking its email
not thinking about the news
missing its mother
needs a haircut
lashing out
acting up
being rude
wide awake
unsteady on a ladder
wearing chunky heels
stretching its legs
nodding off
getting therapy
getting a manicure
getting a pedicure
having an orgasm
sneezing
can't stop laughing
having a breakdown
wandering around
running its fingers through cool water
splashing water on its face
a little drunk
with a brutal headache
getting cramps
bleeding
all scuffed up
reflecting on the past
filled with dread
filled with regret
sucking up
lost an earbud
having fun
really happy
walking through wet grass
braiding its hair
under a lot of pressure
blowing smoke rings
wading through dirty water
looking for survivors
voting
keeping its mouth shut
still hungry
waiting
resting
drifting off
fell down the stairs
shifting its weight
vibrating with anticipation
moving slowly
shifting a ball of energy
balancing
sitting
standing still
trying not to be seen
not making a sound
wiping away tears
shuffling around
stacking coins
imagining a smooth wet stone
gently kayaking
speaking softly
whispering
trying to stay hidden
found bedbugs
listening to the dripping water
looking for its keys
looking for meaning
giving up hope
got laid off
listless
listening
in shambles
ripped to shreds
cut down
doing improv
feeling discouraged
can't handle it anymore
tried its best
couldn't cut it
brainstorming
jotting down ideas
drawing
painting with watercolors
throwing dinner together
eating leftovers
meal prepping
doing the dishes
scrubbing behind the toilet
flipping a house
opening a restaurant
finally gave up
agreed to an open marriage
cheating
going off
keeping a secret
embarrassed
cashing a check
shaking its hair out
putting its hair up
under the influence
coming out of the closet
waiting for the bus
needs some help
not over it
doing its thing
finding itself
losing touch with itself
doing the best it can
going through a breakup
being ignored
feeling unheard
all alone
lost the spark
feeling a little hopeful
starting to cry
getting emotional
putting on makeup
acting unprofessional
blowing massive vape clouds
killing time
sinking into snow
rock climbing
smoking crack
grinding weed
looking for a lighter
taking ecstasy
doing a line of ketamine
taking a bump of cocaine
getting sober
quit drinking
wearing a tracksuit
wearing a mini skirt
trying out a new hat
experimenting
disappointing itself
feeling nostalgic
overcome with guilt
struggling
thriving
strumming a guitar
got too high
took a huge bong hit
wearing incredible jeans
wearing overalls
in a new outfit
in its best clothes
wearing the same old clothes
hasn't changed at all
noticing what's changed
has never been
being interrogated
looking for trouble
stressed out
panicking
under a tight deadline
reminiscing
thinking too hard
trying to figure things out
plucking hairs
plugging in the aux cord
feeling old
picking up trash
giving up
under water
clutching the hand rail
nearly fainted
blacked out
completely wasted
nicely toasted
feeling groovy
wearing a bikini
wearing slacks
trying on shoes
putting on eyeshadow
shaving
stretching out
bent backwards
laying on the floor
feeling doubt
unsure
taking a knee
eavesdropping
pressed against the wall
moisturizing
sulking
getting wet
setting the table
folding laundry
learning spanish
speaking in tongues
hiding
picking up on signals
taking a hint
feeling tense
dropping acid
sipping coffee
popped an advil
changing its tampon
picking its underwear
eating boogers
sauteing mushrooms
broiling a flounder
grilling hot dogs
eating beans out of the can
desperate for affection
looking for attention
disrespected
arms akimbo
rapping
recording a podcast
listening to the rain
watching the sunset
got up early to watch the sunrise
bodysurfing
playing hookie
placing a bet
wearing streetwear
looking through a microscope
styling an outfit
doing a photoshoot
smoking
chugging warm beer
watching asmr
playing tetris
breaking the rules
afraid of getting in trouble
breaking convention
pushing the boundaries
ordering lunch
eating a bagel
craving something sweet
deserves a treat
grabbing a slice
making friends
going through a break up
rekindling an old fling
had a one night stand
looking for love
ready for a change
happy enough
doing ok
feeling good
snacking
binge eating
hungry
oversharing
wearing cargo pants
wearing cutoffs
topless
bottomless
shirtless
naked
half-naked
worn out
drinking wine
flirting
wearing
smiling
unclogging a toilet
pulling hair out of the drain
frowning
crying
giggling
chatting
doing a cold plunge
talking shit
taking the train
taking out the trash
going to the bathroom
getting fingered
sucking dick
chewing gum
squinting
thirsty
lurking
dancing to house music
disassociating
journaling
preparing for surgery
getting worked up
getting yelled at
being tricked
wearing yoga pants
treating a burn
treading water
tending to a wound
kicking back
hanging out
loitering
staying late
up all night
getting hired
getting a promotion
being praised
getting dismissed
getting talked down to
getting cursed out
getting a perm
picking apples
running through water
jogging
running on a treadmill
skipping
climbing over the fence
cutting the cord
curled up
giving birth
working retail
getting picked on
being cyber bullied
roasting in the sun
all sticky
delivering a baby
ripening on the kitchen counter
squealing with delight
writhing in pain
celebrating the holidays
blowing out candles
can't hit the pinata
picking through the bulk bins
acting tough
plucking a harp
shaking maracas
scratching off a lottery ticket
playing powerball
buying a raffle ticket
being held accountable
facing the music
lightly casting a bedsheet across its bare mattress
eating alone
catching up with an old friend
left behind
looked upon fondly
beloved by everybody
thinking about giving up
better off alone
happy this way
feeling satisfied
unpacking boxes
looking for a hole in the air mattress
swapping out the air freshener on its rear view mirror
traveling with friends
fighting
tidying up
decluttering
dusting
with its eyes closed
smiling politely
being very theatrical
virtue signaling
spewing bullshit
clearly lying
telling the truth
unable to lie
learning a magic trick
feeling homesick
`);

/* location */
const LOCATIONS = vocabLines(`
in the bedroom
in the kitchen
in the bathroom
in the attic
on the balcony
in the basement
in the backyard
in the driveway
in the apartment
in a spare bedroom
in a long-unused childhood bedroom
in a steamy bathroom
on a balcony chair
in the living room
in the dining room
in a home office
in a craft room
in a pantry
in a soaking tub
in the office
in a cubicle
in a shoemaker's workshop
in the studio
in the lecture hall
in the waiting room
in the doctor's office
in the library
in a tv studio
in a corner office
in an open-plan office
in a ceramics studio
on a construction site
inside a movie studio
on a soundstage
inside a display case
by a printing press
at the beach
on the pier
in the swimming pool
on the sidewalk
sitting in a diner booth
at a dive bar
at the club
at a rave
at an open mic night
by the fire pit
at the farm stand
at the hardware store
on the trail
on a dirt road
at the trailhead
in the amusement park
in the arcade
in an airport lounge
at a rooftop bar
at a bus stop at dusk
on an empty train platform
at a foggy ferry terminal
stuck to the floor of a movie theater
at an art house theater
at a record store
at a used book store
at a department store
in a food court
inside a vacant motel
in a high-rise apartment building
at the top of the bleachers
buried in a shallow grave
in a cemetery
on a basketball court
on a tennis court
on a golf course
at a pumpkin patch
in a pet store
at a strip mall
at an outlet mall
while walking the runway show
in a cafeteria
in a city center
on the outskirts of town
at a beauty pageant
under the overpass
in the parking garage
in the parking lot
at the waterfront
by the water tower
in the alleyway
in a bog
at the catacombs
at the garbage dump
in an off-season seaside town
on an empty boardwalk
among folded deck chairs
outside a closed movie theater
in an empty museum gallery
in an obsolete shopping mall
in back stairwells
beneath a flickering neon sign
on stone steps
on cobblestone
near a courtyard fountain
under overgrown vines
in a vineyard
in a railroad dining car
in the back seat of a car
in the passenger seat of a car
in the driver's seat
in a walk-in freezer
in a breakfast nook
in a dressing room
in a wine bar
in a karaoke bar
in a bank vault
in a root cellar
in a wine cellar
in the trunk of a car
inside an overhead bin
in an airplane
in an airport
in a theme park
in a haunted house
in a renovated tenement building
at an amphitheater
at the acropolis
on a suspension bridge
at a dude ranch
at a rodeo
inside an automotive plant
in a med spa
in a day spa
in a steam room
on the casino floor
at a poker table
in a clown car
in a dune buggy
inside a black box theater
in an improv class
in gym class
in english class
at a book club
in an italian restaurant
in the mall of america
at the world trade center
at the eiffel tower
at the great wall of china
in times square
in soho
in dimes square
in williamsburg
in greenpoint
in bushwick
in a dorm room
at the foot of the bed
at a strip club
at a gay bar
on the upper east side
in chicago
at madison square garden
on the waterfront in portugal
in the south of france
among rolling hills
in tall grasses
on a mowed lawn
in carnegie hall
hanging out
in a loft space
at a pawn shop
at the bottom of a lake
at a beachfront bonfire
on the last day of school
while riding on the back of a horse

in a lady footlocker
on vacation
while lost in a wheat field
in bed
on the couch
lying in a hammock
face down in the mud
in a kitschy dive bar
in a rustic fishing village
near the old gas station
on the other side of town
in a sketchy town upstate
in the fiery pits hell
at the top of a ladder
in the penthouse
in an unfinished basement
at a construction site
in a cvs
in a walkable neighborhood
in a cramped studio apartment
in line at the pharmacy
in line for the bathroom
in solitary confinement
on a game show
on a tv show
in detention
while stuck in an airport
under the bed
frozen in a block of ice
while trapped underwater
up in a tree
with feet in the sand
in a saltwater pool
in an unlit attic
in a darkened movie theater
near the dollar store
across the street from an abandoned church
in a dingy bowling alley
under red lights
under a disco ball
on a bean bag chair
on a corduroy love seat
in an unpleasant post-modern apartment
on a first date
on a second date
on a third date
during its own wedding
while testifying in court
in the pelapenese
in a tourist trap
on the dance floor
while enveloped by a fog machine
skimming the headlines
in a cozy brownstone apartment
in a punk house
at a silent retreat
on the yucatan peninsula
on an artist's residency
in a writing workshop
in an unfinished housing development
within a sinister gated community
behind barbed wire fencing
locked in the trunk of a car
while being held hostage
inside a cramped submarine
in a same-sex relationship
in a polyamorous relationship
in a cul-de-sac
in the shadow of a mountain
at the campgrounds
at the top of a cherry picker
while trapped in an elevator
`);

/* ========================================================== */

const WORD_REPEAT_COOLDOWN = {
  "desc:object": 180,
  "desc:person": 180,
  "desc:mixed": 220,
  "obj": 260,
  "person": 220,
  "act": 320,
  "loc": 260
};
function pickDescriptorObject(){ return bagNextWithCooldown("desc:object", DESC_OBJECT, WORD_REPEAT_COOLDOWN["desc:object"]); }
function pickDescriptorPerson(){ return bagNextWithCooldown("desc:person", DESC_PERSON, WORD_REPEAT_COOLDOWN["desc:person"]); }
function pickDescriptorMixed(){ return bagNextWithCooldown("desc:mixed", DESC_OBJECT.concat(DESC_PERSON), WORD_REPEAT_COOLDOWN["desc:mixed"]); }
function pickDescriptor(useObj, usePerson){
  if(usePerson) return pickDescriptorPerson();
  if(useObj) return pickDescriptorObject();
  return pickDescriptorMixed();
}
function pickObject(){ return bagNextWithCooldown("obj", OBJECTS, WORD_REPEAT_COOLDOWN["obj"]); }
function pickPerson(){ return bagNextWithCooldown("person", PERSONS, WORD_REPEAT_COOLDOWN["person"]); }
function pickAction(){ return bagNextWithCooldown("act", ACTIONS, WORD_REPEAT_COOLDOWN["act"]); }
function pickLocation(){ return bagNextWithCooldown("loc", LOCATIONS, WORD_REPEAT_COOLDOWN["loc"]); }

/* ================= Phrase build ================= */
function safeStr(x){ return (x == null) ? "" : String(x).trim(); }
function formatPhraseText(p){
  if(clamp(Number(widthEl.value), 0, 100) === 0){
    return p.split(/\s+/).join("<br>");
  }
  return p;
}

function swapItPronounsForPerson(actionStr){
  let s = String(actionStr || "");
  if(!s) return s;

  // Escape hatch: wrap any text in ~...~ to protect it from pronoun swapping.
  // Example: "totally over ~it~" stays "totally over it".
  const locked = [];
  s = s.replace(/~([^~]+)~/g, (_, inner)=>{
    const token = `__LOCK_${locked.length}__`;
    locked.push(inner);
    return token;
  });

  // If a vocab line accidentally includes "it's" (possessive typo), treat it like "its"
  // so pronoun swapping still works.
  s = s.replace(/\bit[']s\b/g, "its");

  const female = Math.random() < 0.5;
  const map = female
    ? { it: "she", its: "her", itself: "herself" }
    : { it: "he", its: "his", itself: "himself" };

  // Avoid matching inside contractions like "it's".
  s = s.replace(/\b(itself|its|it)\b(?!')/g, (m)=> map[m] || m);

  // Restore protected text and remove the ~...~ wrappers.
  return s.replace(/__LOCK_(\d+)__/g, (_, i)=> locked[Number(i)] ?? "");
}

/* ================= Phrase non-repeat (persists across reloads) ================= */
// Keep a long memory so exact repeats stay rare even across days.
// Stored in localStorage; keep this large but not huge.
const RECENT_PHRASES_MAX = 6000;
const RECENT_PHRASES_KEY = "sculpture_poems_recent_phrases_v1";
let recentPhraseQueue = [];
let recentPhraseSet = new Set();
let recentPhraseCount = new Map();
let recentPhraseSaveTimer = null;

function loadRecentPhrases(){
  try{
    const raw = localStorage.getItem(RECENT_PHRASES_KEY);
    if(!raw) return;
    const arr = JSON.parse(raw);
    if(!Array.isArray(arr)) return;
    const clean = arr.map(x => String(x || "").trim()).filter(Boolean);
    recentPhraseQueue = clean.slice(-RECENT_PHRASES_MAX);
    recentPhraseSet = new Set(recentPhraseQueue);
    recentPhraseCount = new Map();
    for(const k of recentPhraseQueue){
      recentPhraseCount.set(k, (recentPhraseCount.get(k) || 0) + 1);
    }
  }catch(e){}
}

function scheduleSaveRecentPhrases(){
  if(recentPhraseSaveTimer) return;
  recentPhraseSaveTimer = window.setTimeout(()=>{
    recentPhraseSaveTimer = null;
    try{
      localStorage.setItem(
        RECENT_PHRASES_KEY,
        JSON.stringify(recentPhraseQueue.slice(-RECENT_PHRASES_MAX))
      );
    }catch(e){}
  }, 1200);
}

function rememberRecentPhrase(p){
  const s = String(p || "").trim();
  if(!s) return;
  recentPhraseQueue.push(s);
  recentPhraseSet.add(s);
  recentPhraseCount.set(s, (recentPhraseCount.get(s) || 0) + 1);
  while(recentPhraseQueue.length > RECENT_PHRASES_MAX){
    const old = recentPhraseQueue.shift();
    const nextCount = (recentPhraseCount.get(old) || 0) - 1;
    if(nextCount <= 0){
      recentPhraseCount.delete(old);
      recentPhraseSet.delete(old);
    }else{
      recentPhraseCount.set(old, nextCount);
    }
  }
  scheduleSaveRecentPhrases();
}

const RECENT_COLOR_COMBOS_MAX = 2800;
const RECENT_COLOR_COMBOS_KEY = "sculpture_poems_recent_color_combos_v1";
let recentColorComboQueue = [];
let recentColorComboSet = new Set();
let recentColorComboCount = new Map();
let recentColorComboSaveTimer = null;

function colorComboKey(bgHex, fgHex, bdHex){
  return `${normHex(bgHex)}|${normHex(fgHex)}|${normHex(bdHex)}`;
}

function loadRecentColorCombos(){
  try{
    const raw = localStorage.getItem(RECENT_COLOR_COMBOS_KEY);
    if(!raw) return;
    const arr = JSON.parse(raw);
    if(!Array.isArray(arr)) return;
    const clean = arr.map(x => String(x || "").trim()).filter(Boolean);
    recentColorComboQueue = clean.slice(-RECENT_COLOR_COMBOS_MAX);
    recentColorComboSet = new Set(recentColorComboQueue);
    recentColorComboCount = new Map();
    for(const k of recentColorComboQueue){
      recentColorComboCount.set(k, (recentColorComboCount.get(k) || 0) + 1);
    }
  }catch(e){}
}

function scheduleSaveRecentColorCombos(){
  if(recentColorComboSaveTimer) return;
  recentColorComboSaveTimer = window.setTimeout(()=>{
    recentColorComboSaveTimer = null;
    try{
      localStorage.setItem(
        RECENT_COLOR_COMBOS_KEY,
        JSON.stringify(recentColorComboQueue.slice(-RECENT_COLOR_COMBOS_MAX))
      );
    }catch(e){}
  }, 1200);
}

function rememberRecentColorCombo(bgHex, fgHex, bdHex){
  const key = colorComboKey(bgHex, fgHex, bdHex);
  if(!key) return;
  recentColorComboQueue.push(key);
  recentColorComboSet.add(key);
  recentColorComboCount.set(key, (recentColorComboCount.get(key) || 0) + 1);
  while(recentColorComboQueue.length > RECENT_COLOR_COMBOS_MAX){
    const old = recentColorComboQueue.shift();
    const nextCount = (recentColorComboCount.get(old) || 0) - 1;
    if(nextCount <= 0){
      recentColorComboCount.delete(old);
      recentColorComboSet.delete(old);
    }else{
      recentColorComboCount.set(old, nextCount);
    }
  }
  scheduleSaveRecentColorCombos();
}

function pickNextColorCombo(){
  const MAX_TRIES = 220;
  let fallback = null;

  for(let i=0; i<MAX_TRIES; i++){
    const bgBase = pickColorNonRepeating("bg", sel.bgColor, new Set()) || current.bgBase || "#ffffff";
    const fgBase = pickColorNonRepeating("fg", sel.fgColor, new Set([bgBase])) || current.fgBase || "#000000";
    const bdBase = pickColorNonRepeating("bd", sel.bdColor, new Set([bgBase, fgBase])) || current.bdBase || "#4d4d4d";
    const key = colorComboKey(bgBase, fgBase, bdBase);
    fallback = { bgBase, fgBase, bdBase };
    if(!recentColorComboCount.has(key)){
      rememberRecentColorCombo(bgBase, fgBase, bdBase);
      return fallback;
    }
  }

  if(fallback){
    rememberRecentColorCombo(fallback.bgBase, fallback.fgBase, fallback.bdBase);
    return fallback;
  }
  return {
    bgBase: current.bgBase || "#ffffff",
    fgBase: current.fgBase || "#000000",
    bdBase: current.bdBase || "#4d4d4d"
  };
}

function clonePhraseParts(parts){
  if(!parts || typeof parts !== "object") return null;
  return {
    desc: safeStr(parts.desc),
    obj: safeStr(parts.obj),
    person: safeStr(parts.person),
    actRaw: safeStr(parts.actRaw),
    locRaw: safeStr(parts.locRaw)
  };
}

function buildPhrasePartsSeed(partsSet){
  const useObj = partsSet.has("object");
  const usePerson = partsSet.has("person") && !useObj;
  return {
    desc: safeStr(pickDescriptor(useObj, usePerson)),
    obj: safeStr(pickObject()),
    person: safeStr(pickPerson()),
    actRaw: safeStr(pickAction()),
    locRaw: safeStr(pickLocation())
  };
}

function composePhraseFromParts(partsSet, partsData){
  const useDesc = partsSet.has("description");
  const useObj  = partsSet.has("object");
  const usePerson = partsSet.has("person") && !useObj;
  const useAct  = partsSet.has("action");
  const useLoc  = partsSet.has("location");
  if(!useDesc && !useObj && !usePerson && !useAct && !useLoc) return "";
  const p = clonePhraseParts(partsData) || {
    desc: "",
    obj: "",
    person: "",
    actRaw: "",
    locRaw: ""
  };

  const desc = useDesc ? p.desc : "";
  const obj = useObj ? p.obj : "";
  const person = usePerson ? p.person : "";
  let act = useAct ? p.actRaw : "";
  let loc = useLoc ? p.locRaw : "";

  // If object isn't present, pronouns in action/location can map to person pronouns.
  if(!useObj){
    if(useAct && act) act = swapItPronounsForPerson(act);
    if(useLoc && loc) loc = swapItPronounsForPerson(loc);
  }

  let out = "";
  if(useDesc && desc) out += desc + " ";
  if(useObj && obj) out += obj;
  if(usePerson && person) out += person;
  if(useAct && act) out += (out ? " " : "") + act;
  if(useLoc && loc) out += (out ? " " : "") + loc;
  return out.replace(/\s+/g," ").trim();
}

function buildPhrase(partsSet, opts = {}){
  const fromCurrent = !!opts.fromCurrent;
  const remember = opts.remember !== false;

  if(fromCurrent){
    const currentParts = clonePhraseParts(opts.partsData || current.phraseParts);
    if(currentParts){
      const out = composePhraseFromParts(partsSet, currentParts);
      if(out && remember) rememberRecentPhrase(out);
      current.phraseParts = currentParts;
      return out;
    }
  }

  let lastOut = "";
  let lastParts = null;
  const MAX_TRIES = 600;

  for(let tries=0; tries<MAX_TRIES; tries++){
    const partsData = buildPhrasePartsSeed(partsSet);
    const out = composePhraseFromParts(partsSet, partsData);
    if(!out) continue;
    lastOut = out;
    lastParts = partsData;

    if(!recentPhraseSet.has(out)){
      if(remember) rememberRecentPhrase(out);
      current.phraseParts = clonePhraseParts(partsData);
      return out;
    }
  }

  if(lastParts) current.phraseParts = clonePhraseParts(lastParts);
  if(lastOut && remember) rememberRecentPhrase(lastOut);
  return lastOut;
}

/* ================= Color selection ================= */
function unionColorsFrom(selectedValues){
  // Supports both palette names and direct hex colors.
  const vals = Array.from(selectedValues || [])
    .map(v => String(v || "").trim().toLowerCase())
    .filter(Boolean);

  const hexVals = vals
    .filter(v => /^#(?:[0-9a-f]{3}|[0-9a-f]{6})$/i.test(v))
    .sort();
  const palNames = vals
    .filter(v => !!PAL[v])
    .sort();

  let out = hexVals.slice();
  for(const n of palNames){
    const pal = PAL[n];
    if(pal && pal.length) out = out.concat(pal.map((c)=> String(c || "").trim().toLowerCase()));
  }
  return uniq(out);
}

function pickColorNonRepeating(key, paletteSet, excludeHexSet){
  const pool = unionColorsFrom(paletteSet);
  const basePool = pool;
  if(!basePool.length) return null;
  const avoid = new Set((excludeHexSet ? Array.from(excludeHexSet) : []).map(normHex));
  if(!avoid.size) return bagNext(key, basePool);

  // Important: we always draw from the same (stable) pool for this key so the shuffle bag
  // can complete a full cycle before repeating. If a draw hits an avoided color, we consume
  // it and keep going (so it can come back after the bag resets).
  const maxTries = Math.max(1, basePool.length);
  for(let i=0; i<maxTries; i++){
    const c = bagNext(key, basePool);
    if(!avoid.has(normHex(c))) return c;
  }
  // If everything is avoided, just return the next color anyway.
  return bagNext(key, basePool);
}

function consumeColorFromBag(key, paletteSet, targetHex){
  const pool = unionColorsFrom(paletteSet);
  const allPool = uniq(Object.values(PAL).flat());
  const basePool = pool.length ? pool : allPool;
  const targetN = normHex(targetHex);
  for(let i=0; i<basePool.length; i++){
    const c = bagNext(key, basePool);
    if(normHex(c) === targetN) return c;
  }
  return bagNext(key, basePool) || targetHex;
}

/* ================= Current frame ================= */
const current = {
  phrase: "",
  phraseParts: null,
  bgBase: "#F7C6D0",
  fgBase: "#231423",
  bdBase: "#231423"
};

const last = { phrase:"", bg:"", fg:"", bd:"" };
let timerId = null;
let isFirstFrame = true;
let isPaused = false;
let isCompositionLocked = false;

/* ================= Playback history ================= */
const HISTORY_MAX = 1000;
const sceneHistory = [];
let sceneIndex = -1;

function snapshotScene(){
  const palSnap = {};
  for(const name of COLOR_OPTS){
    palSnap[name] = palCycleIndex[name] ?? 0;
  }
  return {
    phrase: current.phrase,
    phraseParts: clonePhraseParts(current.phraseParts),
    bgBase: current.bgBase,
    fgBase: current.fgBase,
    bdBase: current.bdBase,
    palCycleIndex: palSnap
  };
}

function syncHistoryButtons(){
  if(prevPoemBtn) prevPoemBtn.disabled = sceneIndex <= 0;
}

function restoreSceneAt(index){
  if(index < 0 || index >= sceneHistory.length) return;
  const sc = sceneHistory[index];
  sceneIndex = index;

  current.phrase = String(sc.phrase || "");
  current.phraseParts = clonePhraseParts(sc.phraseParts);
  current.bgBase = String(sc.bgBase || current.bgBase);
  current.fgBase = String(sc.fgBase || current.fgBase);
  current.bdBase = String(sc.bdBase || current.bdBase);

  if(sc.palCycleIndex){
    for(const name of COLOR_OPTS){
      if(sc.palCycleIndex[name] != null) palCycleIndex[name] = sc.palCycleIndex[name];
    }
  }

  phraseEl.innerHTML = formatPhraseText(current.phrase);
  smartPhraseWidth();
  applyColorsLive();
  syncHistoryButtons();
}

function commitGeneratedScene(){
  const sc = snapshotScene();

  if(sceneIndex >= 0 && sceneIndex < sceneHistory.length - 1){
    sceneHistory.splice(sceneIndex + 1);
  }

  sceneHistory.push(sc);
  sceneIndex = sceneHistory.length - 1;

  if(sceneHistory.length > HISTORY_MAX){
    const drop = sceneHistory.length - HISTORY_MAX;
    sceneHistory.splice(0, drop);
    sceneIndex = Math.max(0, sceneIndex - drop);
  }

  syncHistoryButtons();
}

function syncPauseBtn(){
  if(!pausePoemBtn) return;
  pausePoemBtn.classList.toggle("paused", isPaused);
  pausePoemBtn.setAttribute("aria-pressed", isPaused ? "true" : "false");
  pausePoemBtn.setAttribute("aria-label", isPaused ? "play (space)" : "pause (space)");
  pausePoemBtn.dataset.tip = "pause";
}

function setPaused(paused){
  const next = !!paused;
  if(isPaused === next) return;
  isPaused = next;
  syncPauseBtn();
  if(isPaused){
    if(timerId) clearTimeout(timerId);
    timerId = null;
    return;
  }
  scheduleTick();
}

function togglePaused(){
  setPaused(!isPaused);
}

function syncCompositionLockBtn(){
  if(!lockCompositionBtn) return;
  lockCompositionBtn.classList.toggle("locked", isCompositionLocked);
  lockCompositionBtn.classList.toggle("on", isCompositionLocked);
  lockCompositionBtn.setAttribute("aria-pressed", isCompositionLocked ? "true" : "false");
  lockCompositionBtn.setAttribute("aria-label", isCompositionLocked ? "unlock composition" : "lock composition");
  lockCompositionBtn.dataset.tip = "lock";
}
function toggleCompositionLock(){
  isCompositionLocked = !isCompositionLocked;
  syncCompositionLockBtn();
}

function goPrevPoem(){
  if(sceneIndex <= 0) return;
  setPaused(true);
  restoreSceneAt(sceneIndex - 1);
}

function goNextPoem(){
  setPaused(true);
  // In lock mode, "forward" should always generate a new phrase
  // while preserving the current visual composition.
  if(isCompositionLocked){
    nextFrame();
    return;
  }
  if(sceneIndex < sceneHistory.length - 1){
    restoreSceneAt(sceneIndex + 1);
    return;
  }
  // At the end: generate a new one (manual step-forward).
  nextFrame();
}

function setCalmStart(){
  const palName = COLOR_OPTS[Math.floor(Math.random() * COLOR_OPTS.length)];
  const bg = lightestHexFromPalette(palName);
  const fg = darkestHexFromPalette(palName);
  current.bgBase = consumeColorFromBag("bg", sel.bgColor, bg);
  current.fgBase = consumeColorFromBag("fg", sel.fgColor, fg);
  current.bdBase = consumeColorFromBag("bd", sel.bdColor, fg);
  rememberRecentColorCombo(current.bgBase, current.fgBase, current.bdBase);
}

/* ================= UI builders ================= */
function syncSentenceStructureUI(){
  const container = document.getElementById("partsRow");
  if(container){
    Array.from(container.querySelectorAll(".ssBtn")).forEach((btn)=>{
      const name = String(btn.dataset.part || "").toLowerCase();
      const on = sel.parts.has(name);
      btn.classList.toggle("on", on);
      btn.setAttribute("aria-pressed", on ? "true" : "false");
    });
  }
}

function renderSentenceButtons(){
  const container = document.getElementById("partsRow");
  if(!container) return;
  container.innerHTML = "";

  for(const opt of PART_OPTS){
    const b = document.createElement("button");
    b.type = "button";
    b.className = "ssBtn";
    b.textContent = opt;
    b.dataset.part = opt;

    b.addEventListener("click", ()=>{
      if(opt === "object" && !sel.parts.has("object")){
        // Object poems shortcut: selecting object snaps to object + location.
        sel.parts = new Set(["object", "location"]);
        syncSentenceStructureUI();
        updatePhraseLive();
        showUI();
        return;
      }

      const isObjOrPerson = (opt === "object" || opt === "person");
      const enabling = !sel.parts.has(opt);
      if(isObjOrPerson && enabling){
        // Mutually exclusive: you can enable either object or person, but never both.
        if(opt === "object") sel.parts.delete("person");
        if(opt === "person") sel.parts.delete("object");
      }

      if(sel.parts.has(opt)) sel.parts.delete(opt); else sel.parts.add(opt);
      if(sel.parts.size === 0) sel.parts.add(opt);
      syncSentenceStructureUI();
      updatePhraseLive();
      showUI();
    });

    container.appendChild(b);
  }

  syncSentenceStructureUI();
}

function updatePhraseLive(){
  const p = buildPhrase(sel.parts, { fromCurrent: true, remember: false });
  current.phrase = p;
  phraseEl.innerHTML = formatPhraseText(current.phrase);
  last.phrase = current.phrase;
  smartPhraseWidth();
  applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
  commitGeneratedScene();
}

function refreshSentenceButtonColors(){
  document.querySelectorAll("#partsRow .ssBtn").forEach(btn=>{
    btn.style.removeProperty("--ssPal");
    btn.style.removeProperty("--ssBg");
  });
}

let colorScope = "bd"; // bg | fg | bd

function getColorScopeSet(scope = colorScope){
  if(scope === "fg") return sel.fgColor;
  if(scope === "bd") return sel.bdColor;
  return sel.bgColor;
}

function setColorScopeBtnState(btn, on){
  if(!btn) return;
  btn.classList.toggle("on", !!on);
  btn.setAttribute("aria-pressed", on ? "true" : "false");
}

function syncBulkColorButtons(){
  const setRef = getColorScopeSet(colorScope);
  const total = ALL_SWATCH_COLORS.length;
  setColorScopeBtnState(allOnBtn, setRef.size >= total);
  setColorScopeBtnState(allOffBtn, setRef.size === 0);
}

function getFirstSetColor(setRef, fallbackHex){
  if(setRef && setRef.size){
    const first = setRef.values().next().value;
    if(first) return String(first);
  }
  return String(fallbackHex || "#000000");
}

function ensureCurrentBaseColorsValid(){
  const bgSet = sel.bgColor;
  const fgSet = sel.fgColor;
  const bdSet = sel.bdColor;

  if(!bgSet.size){
    current.bgBase = "#ffffff";
  }else if(!bgSet.has(normHex(current.bgBase))){
    current.bgBase = getFirstSetColor(bgSet, current.bgBase);
  }

  if(!fgSet.size){
    current.fgBase = "#000000";
  }else if(!fgSet.has(normHex(current.fgBase))){
    current.fgBase = getFirstSetColor(fgSet, current.fgBase);
  }

  if(!bdSet.size){
    current.bdBase = "#4d4d4d";
  }else if(!bdSet.has(normHex(current.bdBase))){
    current.bdBase = getFirstSetColor(bdSet, current.bdBase);
  }
}

function syncColorScopeButtons(){
  setColorScopeBtnState(scopeBgBtn, colorScope === "bg");
  setColorScopeBtnState(scopeFgBtn, colorScope === "fg");
  setColorScopeBtnState(scopeBdBtn, colorScope === "bd");
  syncBulkColorButtons();
}

function setCurrentScopeAll(on){
  const setRef = getColorScopeSet(colorScope);
  if(on){
    setRef.clear();
    for(const hex of ALL_SWATCH_COLORS) setRef.add(hex);
    // Immediately restore a vivid base color for the active scope.
    if(colorScope === "bg"){
      const nextBg = pickColorNonRepeating("bg", sel.bgColor, new Set());
      current.bgBase = nextBg || getFirstSetColor(sel.bgColor, current.bgBase);
    }else if(colorScope === "fg"){
      const nextFg = pickColorNonRepeating("fg", sel.fgColor, new Set([current.bgBase]));
      current.fgBase = nextFg || getFirstSetColor(sel.fgColor, current.fgBase);
    }else{
      const nextBd = pickColorNonRepeating("bd", sel.bdColor, new Set([current.bgBase, current.fgBase]));
      current.bdBase = nextBd || getFirstSetColor(sel.bdColor, current.bdBase);
    }
  }else{
    setRef.clear();
  }
  ensureCurrentBaseColorsValid();
  applyColorsLive();
  syncAllSwatchSelection();
  syncBulkColorButtons();
}

function setColorScope(scope){
  const next = (scope === "fg" || scope === "bd") ? scope : "bg";
  colorScope = next;
  syncColorScopeButtons();
  syncAllSwatchSelection();
}

function syncAllSwatchSelection(){
  const setRef = getColorScopeSet(colorScope);
  document.querySelectorAll("#allColorsRow .swatch").forEach((btn)=>{
    const hex = normHex(btn.dataset.hex);
    btn.classList.toggle("on", setRef.has(hex));
  });
}

function renderAllSwatches(){
  const rowEl = document.getElementById("allColorsRow");
  if(!rowEl) return;
  rowEl.innerHTML = "";

  for(const hex of ALL_SWATCH_COLORS){
    const sw = document.createElement("button");
    sw.type = "button";
    sw.className = "swatch";
    sw.dataset.hex = hex;
    sw.style.setProperty("--fillCol", hex);

    sw.addEventListener("click", ()=>{
      const setRef = getColorScopeSet(colorScope);
      const on = setRef.has(hex);
      if(on){
        setRef.delete(hex);
      }else{
        setRef.add(hex);
      }
      ensureCurrentBaseColorsValid();
      applyColorsLive();
      syncAllSwatchSelection();
      syncBulkColorButtons();
    });

    rowEl.appendChild(sw);
  }

  setColorScope(colorScope);
}

function refreshSwatchColors(){
  document.querySelectorAll("#allColorsRow .swatch").forEach((sw)=>{
    const hex = normHex(sw.dataset.hex);
    sw.style.setProperty("--fillCol", hex);
  });
}

function applyButtonColors(){
  const cardLive = applyDimmer(current.bdBase, Number(bdBrightEl.value));
  const uiFg = getFgLiveHex() || "#000000";

  document.documentElement.style.setProperty("--cardUiBg", cardLive);
  document.documentElement.style.setProperty("--cardUiFg", uiFg);

  [
    prevPoemBtn, pausePoemBtn, nextPoemBtn,
    screenshotBtn, fsBtn, lockCompositionBtn,
    tabLanguageBtn, tabContrastBtn, tabColorsBtn, tabSpeedBtn, tabInfoBtn,
    scopeBgBtn, scopeFgBtn, scopeBdBtn, allOnBtn, allOffBtn,
    bdToggleBtn
  ].forEach((btn)=>{
    if(!btn) return;
    btn.style.setProperty("--btnBg", cardLive);
    btn.style.color = uiFg;
  });
  syncMenuToggleColor(cardLive, uiFg);
}

function syncMenuToggleColor(cardHex, fgHex){
  if(!menuToggleBtn) return;
  const bg = normHex(cardHex || current.bdBase || "#000000");
  const fg = normHex(fgHex || getFgLiveHex() || "#000000");
  menuToggleBtn.style.setProperty("--menuBg", bg);
  menuToggleBtn.style.setProperty("--menuFg", fg);
}

function syncSwatchHeaderWidths(){
  requestAnimationFrame(()=>{
    document.querySelectorAll(".swatchRow").forEach(row=>{
      const wrap = row.parentElement;
      const header = wrap ? wrap.querySelector(".swatchHeader") : null;
      const bright = wrap ? wrap.querySelector(".brightCtrl") : null;
      if(!header) return;
      const w = row.getBoundingClientRect().width;
      header.style.width = w > 0 ? `${w}px` : "auto";
      header.style.marginLeft = "auto";
      header.style.marginRight = "auto";
      row.style.marginLeft = "auto";
      row.style.marginRight = "auto";

      if(bright){
        bright.style.width = w > 0 ? `${w}px` : "auto";
        bright.style.marginLeft = "auto";
        bright.style.marginRight = "auto";
      }
    });
  });
}

function applySliderThumbColors(){
  sliderEls.forEach((el, i)=>{
    const palName = SLIDER_PALS[i % SLIDER_PALS.length];
    const pal = PAL[palName] || [];
    const offset = pal.length ? (i % pal.length) : 0;
    const col = paletteColor(palName, offset);
    el.style.setProperty("--thumbCol", col);
  });
}

function applyAccentColors(){
  refreshSwatchColors();
  refreshSentenceButtonColors();
  applySliderThumbColors();
  applyButtonColors();
}

/* ================= Type + layout ================= */
function applyTypeAndLayout(){
  const sizePct = clamp(Number(sizeEl.value), 0, 150);
  let scale = 0.02;
  if(sizePct > 0 && sizePct <= 100){
    scale = 0.02 + (1.6 - 0.02) * (sizePct / 100);
  }else if(sizePct > 100){
    scale = 1.6 + (3.5 - 1.6) * ((sizePct - 100) / 50);
  }
  document.documentElement.style.setProperty("--textScale", scale);
  sizeVal.textContent = `${Math.round(sizePct)}%`;

  const y = clamp(Number(yEl.value), 0, 100);
  document.documentElement.style.setProperty("--yPct", `${y}%`);
  yVal.textContent = `${Math.round(y)}%`;

  const w = clamp(Number(widthEl.value), 0, 100);
  widthVal.textContent = `${Math.round(w)}%`;

  smartPhraseWidth();
}

function phraseInkRects(){
  try{
    const r = document.createRange();
    r.selectNodeContents(phraseEl);
    return Array.from(r.getClientRects()).filter(x => x.width > 0 && x.height > 0);
  }catch(e){
    return [];
  }
}
function phraseInkBounds(){
  const rects = phraseInkRects();
  if(!rects.length) return null;
  let left = Infinity, right = -Infinity, top = Infinity, bottom = -Infinity;
  for(const r of rects){
    left = Math.min(left, r.left);
    right = Math.max(right, r.right);
    top = Math.min(top, r.top);
    bottom = Math.max(bottom, r.bottom);
  }
  if(!Number.isFinite(left) || !Number.isFinite(right) || !Number.isFinite(top) || !Number.isFinite(bottom)) return null;
  return { left, right, top, bottom, width: right - left, height: bottom - top };
}

function fitPhraseToBox(){
  if(Math.abs(sceneZoom - 1) > 0.001){
    // Keep manual drag/pinch zoom authoritative.
    applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
    return;
  }

  const sizePct = clamp(Number(sizeEl.value), 0, 150);
  if(sizePct <= 0){
    document.documentElement.style.setProperty("--fitScale", "1");
    applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
    return;
  }
  if(sizePct >= 150){
    document.documentElement.style.setProperty("--fitScale", "1");
    applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
    return;
  }
  const text = (phraseEl.textContent || "").trim();
  if(!text){
    document.documentElement.style.setProperty("--fitScale", "1");
    applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
    return;
  }

  document.documentElement.style.setProperty("--fitScale", "1");
  const rect = phraseInkBounds() || phraseEl.getBoundingClientRect();
  if(rect.width <= 0 || rect.height <= 0){
    document.documentElement.style.setProperty("--fitScale", "1");
    applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
    return;
  }

  const { w: vw, h: vh } = getViewportSize();
  const edgePad = getRootVarPx("--edgePad");
  const wVar = getRootVarVw("--phraseW");
  const widthPct = (wVar ? wVar : clamp(Number(widthEl.value), 1, 100)) / 100;

  const maxW = Math.min(vw * widthPct, vw - (edgePad * 2));
  const maxH = vh - (edgePad * 2);

  let scale = Math.min(maxW / rect.width, maxH / rect.height, 1);
  if(!Number.isFinite(scale) || scale <= 0) scale = 1;
  scale = clamp(scale, 0.01, 1);

  document.documentElement.style.setProperty("--fitScale", scale.toFixed(3));
  applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
}

function widenPhraseToAvoidOverfullLines(){
  // If a line is "overfull" (a word is wider than the box), browsers fall back to start-alignment
  // and our card bounds can be wrong. Clamp the box to at least the scroll width to keep it centered.
  const { w: vw } = getViewportSize();
  if(vw <= 0) return;

  // A couple passes handles cases where max-width / edge padding clamps the first widening attempt.
  for(let i=0; i<2; i++){
    const boxW = phraseEl.getBoundingClientRect().width;
    if(boxW <= 0) return;

    const scrollW = phraseEl.scrollWidth || 0;
    if(scrollW <= boxW + 0.5) return;

    const needVw = clamp(((scrollW + 2) / vw) * 100, 1, 100);
    const curVw = getRootVarVw("--phraseW") ?? clamp(Number(widthEl.value), 1, 100);
    const nextVw = clamp(Math.max(curVw, needVw), 1, 100);

    document.documentElement.style.setProperty("--phraseW", `${nextVw.toFixed(2)}vw`);
    if(nextVw >= 100){
      document.documentElement.style.setProperty("--edgePad", "0px");
      return;
    }
  }

  // If we're still overfull, the edge padding is clamping max-width; drop it.
  const boxW = phraseEl.getBoundingClientRect().width;
  const scrollW = phraseEl.scrollWidth || 0;
  if(scrollW > boxW + 0.5){
    document.documentElement.style.setProperty("--edgePad", "0px");
    document.documentElement.style.setProperty("--phraseW", "100vw");
  }
}

function phraseHasOverfullLine(){
  const boxW = phraseEl.getBoundingClientRect().width;
  if(boxW <= 0) return false;
  const scrollW = phraseEl.scrollWidth || 0;
  return scrollW > (boxW + 0.5);
}

function buildWidthSearchOrder(center, minW, maxW, step=1){
  const out = [];
  const seen = new Set();
  const push = (v)=>{
    const n = Math.round((v / step)) * step;
    const c = clamp(n, minW, maxW);
    const key = c.toFixed(3);
    if(seen.has(key)) return;
    seen.add(key);
    out.push(c);
  };
  push(center);
  for(let d = step; d <= (maxW - minW + step); d += step){
    push(center - d);
    push(center + d);
  }
  return out;
}

function getPhraseLineStats(){
  const lineRects = groupClientRectsIntoLines(phraseInkRects());
  if(!lineRects.length) return null;

  const widths = lineRects.map((r)=>Math.max(1, r.width));
  const maxW = Math.max(...widths);
  const minW = Math.min(...widths);
  const lastW = widths[widths.length - 1];
  const lastRatio = lastW / Math.max(1, maxW);

  const mean = widths.reduce((a,b)=>a+b, 0) / widths.length;
  const variance = widths.reduce((acc, w)=> acc + Math.pow(w - mean, 2), 0) / widths.length;
  const relStdDev = Math.sqrt(variance) / Math.max(1, mean);

  const renderedLines = getRenderedLinesForScreenshot();
  const lastLineText = renderedLines.length ? String(renderedLines[renderedLines.length - 1]).trim() : "";
  const lastWords = lastLineText ? lastLineText.split(/\s+/).filter(Boolean).length : 0;

  return {
    lineCount: widths.length,
    widths,
    maxW,
    minW,
    lastW,
    lastRatio,
    relStdDev,
    lastWords
  };
}

function scorePhraseLineBalance(stats){
  if(!stats) return Infinity;
  if(stats.lineCount <= 1) return 0;

  let score = 0;
  // Penalize very short final lines and true widows.
  score += Math.max(0, 0.66 - stats.lastRatio) * 5.5;
  if(stats.lastWords === 1) score += 2.6;
  else if(stats.lastWords === 2) score += 0.8;

  // Penalize uneven line distribution.
  score += stats.relStdDev * 2.0;

  // For two-line phrases, require stronger balance.
  if(stats.lineCount === 2 && stats.lastRatio < 0.78){
    score += (0.78 - stats.lastRatio) * 4.2;
  }
  return score;
}

function smartPhraseWidth(){
  const base = clamp(Number(widthEl.value), 0, 100);
  if(base === 0){
    document.documentElement.style.setProperty("--phraseW", "100vw");
    phraseEl.classList.add("oneWord");
    document.documentElement.style.setProperty("--edgePad", "0px");
    fitPhraseToBox();
    return;
  }
  phraseEl.classList.remove("oneWord");
  document.documentElement.style.setProperty("--phraseW", `${base}vw`);
  document.documentElement.style.setProperty("--edgePad", base >= 100 ? "0px" : "50px");
  document.documentElement.style.setProperty("--fitScale", "1");
  widenPhraseToAvoidOverfullLines();

  const text = (phraseEl.textContent || "").trim();
  if(!text){
    fitPhraseToBox();
    return;
  }

  const currentW = getRootVarVw("--phraseW") ?? base;
  const currentStats = getPhraseLineStats();
  if(!currentStats){
    fitPhraseToBox();
    return;
  }

  let bestW = currentW;
  let bestScore = scorePhraseLineBalance(currentStats);

  // Explore both narrower and wider widths to avoid one-word ragged last lines.
  const minSearchW = clamp(currentW - 14, 1, 100);
  const maxSearchW = clamp(Math.min(100, currentW + 14), 1, 100);
  const candidates = buildWidthSearchOrder(currentW, minSearchW, maxSearchW, 1);

  for(const candidateW of candidates){
    document.documentElement.style.setProperty("--phraseW", `${candidateW.toFixed(2)}vw`);
    if(phraseHasOverfullLine()) continue;

    const stats = getPhraseLineStats();
    if(!stats) continue;
    const score = scorePhraseLineBalance(stats);

    const strongWin = score < (bestScore - 0.08);
    const tieWin =
      Math.abs(score - bestScore) <= 0.08 &&
      Math.abs(candidateW - base) < Math.abs(bestW - base);
    if(strongWin || tieWin){
      bestScore = score;
      bestW = candidateW;
    }
  }

  document.documentElement.style.setProperty("--phraseW", `${bestW.toFixed(2)}vw`);
  fitPhraseToBox();
}

function groupClientRectsIntoLines(rects){
  const out = [];
  const sorted = rects.slice().sort((a,b)=> (a.top - b.top) || (a.left - b.left));
  const EPS = 2.0;
  for(const r of sorted){
    let line = null;
    for(const l of out){
      if(Math.abs(l.top - r.top) <= EPS){
        line = l;
        break;
      }
    }
    if(!line){
      out.push({ top: r.top, bottom: r.bottom, left: r.left, right: r.right });
    }else{
      line.top = Math.min(line.top, r.top);
      line.bottom = Math.max(line.bottom, r.bottom);
      line.left = Math.min(line.left, r.left);
      line.right = Math.max(line.right, r.right);
    }
  }
  return out
    .sort((a,b)=> a.top - b.top)
    .map(l => ({
      top: l.top,
      bottom: l.bottom,
      left: l.left,
      width: l.right - l.left,
      height: l.bottom - l.top
    }));
}

function getRenderedLinesForScreenshot(){
  const raw = String(phraseEl.textContent || "").replace(/\r/g, "");
  const text = raw.replace(/\s+/g, " ").trim();
  if(!text) return [];

  // "one word per line" mode
  if(clamp(Number(widthEl.value), 0, 100) === 0){
    return text.split(/\s+/).filter(Boolean);
  }

  // If the DOM contains <br> for any reason, trust it.
  if(phraseEl.querySelector("br")){
    return String(phraseEl.innerText || "")
      .replace(/\r/g, "")
      .split("\n")
      .map(s => s.trim())
      .filter(Boolean);
  }

  // Normal mode is a single text node (we set innerHTML to plain text).
  const node = phraseEl.firstChild;
  if(!node || node.nodeType !== Node.TEXT_NODE){
    return [text];
  }

  const words = [];
  const re = /\S+/g;
  let m;
  while((m = re.exec(node.data))){
    words.push({ word: m[0], start: m.index, end: m.index + m[0].length });
  }
  if(!words.length) return [text];

  const lines = [];
  const range = document.createRange();
  const EPS = 2.0;
  let curTop = null;
  let cur = [];

  for(const w of words){
    range.setStart(node, w.start);
    range.setEnd(node, w.end);
    const r = range.getBoundingClientRect();
    if(!r || r.width <= 0 || r.height <= 0) continue;
    if(curTop == null){
      curTop = r.top;
      cur.push(w.word);
      continue;
    }
    if(Math.abs(r.top - curTop) <= EPS){
      cur.push(w.word);
    }else{
      if(cur.length) lines.push(cur.join(" "));
      cur = [w.word];
      curTop = r.top;
    }
  }
  if(cur.length) lines.push(cur.join(" "));

  return lines.length ? lines : [text];
}

function takeScreenshot(){
  try{
    const { w: vw, h: vh } = getViewportSize();
    const dpr = Math.max(1, Math.round((window.devicePixelRatio || 1) * 100) / 100);

    const canvas = document.createElement("canvas");
    canvas.width = Math.max(1, Math.round(vw * dpr));
    canvas.height = Math.max(1, Math.round(vh * dpr));
    const ctx = canvas.getContext("2d");
    if(!ctx) return;
    ctx.scale(dpr, dpr);

    // Background
    ctx.fillStyle = getComputedStyle(document.body).backgroundColor || "#ffffff";
    ctx.fillRect(0, 0, vw, vh);

    // Card (if enabled)
    if(sel.borderEnabled && getComputedStyle(cardEl).display !== "none"){
      const r = cardEl.getBoundingClientRect();
      if(r.width > 0 && r.height > 0){
        ctx.fillStyle = getComputedStyle(cardEl).backgroundColor || "transparent";
        ctx.fillRect(r.left, r.top, r.width, r.height);
      }
    }

    // Text
    const lines = getRenderedLinesForScreenshot();
    if(lines.length){
      const cs = getComputedStyle(phraseEl);
      const fontSize = cs.fontSize || "48px";
      const fontWeight = cs.fontWeight || "600";
      const fontFamily = cs.fontFamily || "serif";
      const lineHeightPx = parseFloat(cs.lineHeight) || (parseFloat(fontSize) * 1.12);
      ctx.font = `${fontWeight} ${fontSize} ${fontFamily}`;
      ctx.fillStyle = cs.color || "#000000";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";

      const lineRects = groupClientRectsIntoLines(phraseInkRects());
      const n = Math.min(lines.length, lineRects.length);

      if(n > 0){
        for(let i=0; i<n; i++){
          const line = lines[i];
          const r = lineRects[i];
          ctx.fillText(line, r.left + (r.width / 2), r.top);
        }
        if(lines.length > n){
          const last = lineRects[lineRects.length - 1];
          const startY = (last ? last.bottom : (phraseEl.getBoundingClientRect().top));
          for(let i=n; i<lines.length; i++){
            ctx.fillText(lines[i], vw / 2, startY + ((i - n) * lineHeightPx));
          }
        }
      }else{
        const r = phraseEl.getBoundingClientRect();
        for(let i=0; i<lines.length; i++){
          ctx.fillText(lines[i], vw / 2, r.top + (i * lineHeightPx));
        }
      }
    }

    canvas.toBlob((blob)=>{
      if(!blob) return;
      const now = new Date();
      const dateStamp = `${now.getMonth() + 1}.${now.getDate()}.${now.getFullYear()}`;
      const pad2 = (n)=> String(n).padStart(2, "0");
      const dayKey = `${now.getFullYear()}-${pad2(now.getMonth() + 1)}-${pad2(now.getDate())}`;

      let n = 1;
      try{
        const k = `sculpture_poems_screenshot_counter_${dayKey}`;
        const prev = Math.floor(Number(localStorage.getItem(k) || "0"));
        n = (Number.isFinite(prev) && prev >= 0) ? (prev + 1) : 1;
        localStorage.setItem(k, String(n));
      }catch(e){
        window.__sculpturePoemsScreenshotN = (window.__sculpturePoemsScreenshotN || 0) + 1;
        n = window.__sculpturePoemsScreenshotN;
      }

      const a = document.createElement("a");
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = `Poem-${dateStamp}-${n}.png`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=> URL.revokeObjectURL(url), 1500);
    }, "image/png");
  }catch(e){}
}

function flashButtonOnce(btn, ms=140){
  if(!btn) return;
  btn.classList.add("on");
  window.setTimeout(()=> btn.classList.remove("on"), ms);
}
function snapScreenshot(){
  flashButtonOnce(screenshotBtn, 160);
  takeScreenshot();
}

/* Card behind phrase */
function applyCardStyle(colorHex){
  const t = sel.borderEnabled ? clamp(sel.borderThickness, 0, 1) : 0;
  if(!sel.borderEnabled || t <= 0){
    cardEl.style.display = "none";
    scheduleUiSafeUpdate();
    return;
  }
  cardEl.style.display = "block";
  cardEl.style.background = colorHex;

  const rect = phraseInkBounds() || phraseEl.getBoundingClientRect();
  if(rect.width <= 0 || rect.height <= 0){
    cardEl.style.display = "none";
    scheduleUiSafeUpdate();
    return;
  }

  const { w: vw, h: vh } = getViewportSize();
  const tAdj = Math.pow(t, 1.6);

  // Add a small base padding so the card doesn't feel cramped when hugging the ink.
  const fontPx = parseFloat(getComputedStyle(phraseEl).fontSize) || 0;
  const basePadX = clamp(fontPx * 0.40, 14, 36);
  const basePadY = clamp(fontPx * 0.26, 10, 28);

  const maxPadL = Math.max(0, rect.left);
  const maxPadR = Math.max(0, vw - rect.right);
  const maxPadT = Math.max(0, rect.top);
  const maxPadB = Math.max(0, vh - rect.bottom);

  // Keep the phrase centered inside the card as it grows: symmetric padding on each axis.
  const maxSymPadX = Math.min(maxPadL, maxPadR);
  const maxSymPadY = Math.min(maxPadT, maxPadB);

  const padX = Math.min(maxSymPadX, basePadX + (maxSymPadX * tAdj));
  const padY = Math.min(maxSymPadY, basePadY + (maxSymPadY * tAdj));

  cardEl.style.transform = "none";
  cardEl.style.left = `${Math.round(rect.left - padX)}px`;
  cardEl.style.top = `${Math.round(rect.top - padY)}px`;
  cardEl.style.width = `${Math.ceil(rect.width + (padX * 2))}px`;
  cardEl.style.height = `${Math.ceil(rect.height + (padY * 2))}px`;
  scheduleUiSafeUpdate();
}

function pctLabel(x){ return `${Math.round(clamp(Number(x),0,1)*100)}%`; }

/* ================= Speed mapping ================= */
const SPEED_MIN_S = 0.01;
const SPEED_MAX_S = 600;

function speedFromSlider(t){
  t = clamp(Number(t), 0, 1);
  const ratio = SPEED_MAX_S / SPEED_MIN_S;
  return SPEED_MIN_S * Math.pow(ratio, t);
}
function formatDuration(seconds){
  if(seconds < 0.1) return `${Math.round(seconds*1000)}ms`;
  if(seconds < 1) return `${seconds.toFixed(2)}s`;
  if(seconds < 60) return `${seconds.toFixed(seconds < 10 ? 2 : 1)}s`;
  const m = seconds / 60;
  if(m < 10) return `${m.toFixed(2)}m`;
  return `${m.toFixed(1)}m`;
}

/* ================= Visual apply ================= */
function applyColorsLive(){
  const bg = applyDimmer(current.bgBase, Number(bgBrightEl.value));
  current.bgLive = bg;
  let fg  = applyDimmer(current.fgBase, Number(fgBrightEl.value));
  let bd  = applyDimmer(current.bdBase, Number(bdBrightEl.value));

  if(!isCompositionLocked){
    if(bg.toLowerCase() === fg.toLowerCase()){
      const alt = pickColorNonRepeating("fg", sel.fgColor, new Set([current.bgBase]));
      if(alt) current.fgBase = alt;
      fg = applyDimmer(current.fgBase, Number(fgBrightEl.value));
    }
    if(bd.toLowerCase() === bg.toLowerCase()){
      const altB = pickColorNonRepeating("bd", sel.bdColor, new Set([current.bgBase, current.fgBase]));
      if(altB) current.bdBase = altB;
      bd = applyDimmer(current.bdBase, Number(bdBrightEl.value));
    }
  }

  document.body.style.background = bg;
  phraseEl.style.color = fg;
  current.fgLive = fg;
  current.bdLive = bd;

  applyCardStyle(bd);
  syncMenuToggleColor(bd, fg);

  // Update UI accents (swatches, buttons, slider dots) after background is applied.
  applyAccentColors();

  bgBrightVal.textContent = pctLabel(bgBrightEl.value);
  fgBrightVal.textContent = pctLabel(fgBrightEl.value);
  bdBrightVal.textContent = pctLabel(bdBrightEl.value);
  bdThickVal.textContent = `${Math.round(clamp(sel.borderThickness,0,1)*100)}%`;
}

/* ================= Border toggle button sync ================= */
function setBorderBtn(){
  bdToggleBtn.textContent = sel.borderEnabled ? "on" : "off";
  bdToggleBtn.classList.toggle("on", sel.borderEnabled);
  bdToggleBtn.setAttribute("aria-pressed", sel.borderEnabled ? "true" : "false");
}

/* ================= Fullscreen helpers ================= */
const fsApi = {
  request: document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen || document.documentElement.msRequestFullscreen,
  exit: document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen
};
function isFullscreen(){
  return !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
}
function syncFullscreenBtn(){
  if(!fsApi.request || !fsApi.exit){
    fsBtn.classList.add("disabled");
    fsBtn.setAttribute("aria-disabled", "true");
    return;
  }
  fsBtn.classList.remove("disabled");
  fsBtn.removeAttribute("aria-disabled");
  const on = isFullscreen();
  fsBtn.textContent = "full screen";
  fsBtn.classList.toggle("on", on);
  fsBtn.setAttribute("aria-pressed", on ? "true" : "false");
}

/* ================= Tick loop ================= */
function scheduleTick(){
  if(isPaused) return;
  if(timerId) clearTimeout(timerId);
  const seconds = speedFromSlider(speedEl.value);
  speedVal.textContent = formatDuration(seconds);
  timerId = setTimeout(()=>{
    nextFrame();
    scheduleTick();
  }, Math.max(10, Math.round(seconds*1000)));
}

/* ================= Frame generation ================= */
function nextFrame(){
  let p = buildPhrase(sel.parts);

  current.phrase = p;
  phraseEl.innerHTML = formatPhraseText(current.phrase);
  last.phrase = current.phrase;

  smartPhraseWidth();

  const wasFirst = isFirstFrame;
  if(isFirstFrame){
    isFirstFrame = false;
  }else if(!isCompositionLocked){
    const combo = pickNextColorCombo();
    current.bgBase = combo.bgBase || current.bgBase;
    current.fgBase = combo.fgBase || current.fgBase;
    current.bdBase = combo.bdBase || current.bdBase;
  }

  if(!isCompositionLocked && !wasFirst){
    advancePaletteCycle();
  }

  last.bg = current.bgBase;
  last.fg = current.fgBase;
  last.bd = current.bdBase;

  applyColorsLive();
  commitGeneratedScene();
}

/* ================= UI fade/auto-hide ================= */
let hideTimer = null;
const UI_HIDE_MS = 5000;
let menuFadeTimer = null;
const MENU_PEEK_MS = 5000;
function setMenuToggleState(open){
  if(!menuToggleBtn) return;
  menuToggleBtn.classList.toggle("on", !!open);
  menuToggleBtn.setAttribute("aria-pressed", open ? "true" : "false");
  if(open){
    menuToggleBtn.setAttribute("data-tip", "turn off");
  }else{
    menuToggleBtn.removeAttribute("data-tip");
  }
}
function scheduleMenuFade(){
  if(!menuToggleBtn) return;
  if(menuFadeTimer) clearTimeout(menuFadeTimer);
  menuFadeTimer = setTimeout(()=>{
    menuFadeTimer = null;
    if(!menuToggleBtn.classList.contains("on")){
      menuToggleBtn.classList.remove("show");
    }
  }, MENU_PEEK_MS);
}
function showMenuToggleBriefly(){
  if(!menuToggleBtn) return;
  menuToggleBtn.classList.add("show");
  scheduleMenuFade();
}
function scheduleHideUI(){
  if(hideTimer) clearTimeout(hideTimer);
  hideTimer = setTimeout(()=> hideUI(), UI_HIDE_MS);
}
function showUI(){
  uiWrapEl.classList.remove("hidden");
  setMenuToggleState(true);
  if(menuFadeTimer) clearTimeout(menuFadeTimer);
  menuFadeTimer = null;
  if(menuToggleBtn) menuToggleBtn.classList.add("show");
  syncMenuTogglePosition();
  scheduleUiSafeUpdate();
  scheduleHideUI();
}
function hideUI(showMenuPeek = true){
  if(hideTimer) clearTimeout(hideTimer);
  hideTimer = null;
  // Closing the UI always returns to the submenu layer (no slider/swatch page left open).
  if(uiPage !== "none"){
    setUiPage("none");
  }
  uiWrapEl.classList.add("hidden");
  setMenuToggleState(false);
  if(showMenuPeek){
    showMenuToggleBriefly();
  }else if(menuToggleBtn){
    if(menuFadeTimer) clearTimeout(menuFadeTimer);
    menuFadeTimer = null;
    menuToggleBtn.classList.remove("show");
  }
}
function toggleUI(){
  if(uiWrapEl.classList.contains("hidden")){
    showUI();
  }else{
    hideUI(false);
  }
}
function wakeMenuIfUiHidden(){
  if(!uiWrapEl.classList.contains("hidden")) return;
  showMenuToggleBriefly();
}
function keepUiAliveWhileMoving(){
  if(uiWrapEl.classList.contains("hidden")) return;
  scheduleHideUI();
}

/* ================= Events ================= */
// Safari sometimes fails to re-apply :hover styles immediately after a click when classes toggle.
// This adds a tiny "forceHover" class while the pointer is over the button to keep hover fills consistent.
(function initForceHoverFix(){
  if(!window.matchMedia) return;
  const canHover = window.matchMedia("(hover: hover) and (pointer: fine)").matches;
  if(!canHover) return;

  document.addEventListener("pointerdown", (e)=>{
    const btn = e.target && e.target.closest ? e.target.closest("button") : null;
    if(!btn) return;
    btn.classList.add("forceHover");

    const clear = ()=> btn.classList.remove("forceHover");
    btn.addEventListener("mouseleave", clear, {once:true});
    btn.addEventListener("pointercancel", clear, {once:true});
  }, true);
})();

window.addEventListener("pointerdown", onScenePointerDown, {passive:false});
window.addEventListener("pointermove", onScenePointerMove, {passive:false});
window.addEventListener("pointerup", onScenePointerEnd, {passive:false});
window.addEventListener("pointercancel", onScenePointerEnd, {passive:false});
window.addEventListener("mousemove", wakeMenuIfUiHidden, {passive:true});
window.addEventListener("touchstart", wakeMenuIfUiHidden, {passive:true});
window.addEventListener("mousemove", keepUiAliveWhileMoving, {passive:true});
window.addEventListener("pointermove", keepUiAliveWhileMoving, {passive:true});
window.addEventListener("touchmove", keepUiAliveWhileMoving, {passive:true});

dockControlBtns.forEach((btn)=>{
  btn.addEventListener("pointerenter", ()=>{
    dockHoverBtnId = btn.id;
    applyDockConstellationState();
  });
  btn.addEventListener("pointerleave", ()=>{
    if(dockHoverBtnId === btn.id){
      dockHoverBtnId = "";
      applyDockConstellationState();
    }
  });
  btn.addEventListener("focus", ()=>{
    dockHoverBtnId = btn.id;
    applyDockConstellationState();
  });
  btn.addEventListener("blur", ()=>{
    if(dockHoverBtnId === btn.id){
      dockHoverBtnId = "";
      applyDockConstellationState();
    }
  });
});
if(menuToggleBtn){
  menuToggleBtn.addEventListener("pointerenter", ()=>{
    dockHoverBtnId = "menuToggleBtn";
    applyDockConstellationState();
  });
  menuToggleBtn.addEventListener("pointerleave", ()=>{
    if(dockHoverBtnId === "menuToggleBtn"){
      dockHoverBtnId = "";
      applyDockConstellationState();
    }
  });
  menuToggleBtn.addEventListener("focus", ()=>{
    dockHoverBtnId = "menuToggleBtn";
    applyDockConstellationState();
  });
  menuToggleBtn.addEventListener("blur", ()=>{
    if(dockHoverBtnId === "menuToggleBtn"){
      dockHoverBtnId = "";
      applyDockConstellationState();
    }
  });
}

speedEl.addEventListener("input", ()=>{ scheduleTick(); showUI(); });
bgBrightEl.addEventListener("input", ()=>{ applyColorsLive(); showUI(); });
fgBrightEl.addEventListener("input", ()=>{ applyColorsLive(); showUI(); });
bdBrightEl.addEventListener("input", ()=>{ applyColorsLive(); showUI(); });

bdThickEl.addEventListener("input", ()=>{
  sel.borderThickness = clamp(Number(bdThickEl.value), 0, 1);
  applyColorsLive();
  showUI();
});

sizeEl.addEventListener("input", ()=>{ applyTypeAndLayout(); showUI(); });
yEl.addEventListener("input", ()=>{ applyTypeAndLayout(); applyColorsLive(); showUI(); });
widthEl.addEventListener("input", ()=>{
  if(clamp(Number(widthEl.value), 0, 100) === 0){
    phraseEl.innerHTML = formatPhraseText(current.phrase);
  }else{
    phraseEl.textContent = current.phrase;
  }
  applyTypeAndLayout();
  showUI();
});

bdToggleBtn.addEventListener("click", ()=>{
  sel.borderEnabled = !sel.borderEnabled;
  setBorderBtn();
  applyColorsLive();
  showUI();
});

fsBtn.addEventListener("click", async ()=>{
  setDockActiveButton("fsBtn");
  try{
    if(!fsApi.request || !fsApi.exit) return;
    if(fsBtn.classList.contains("disabled")) return;
    if(!isFullscreen()) await fsApi.request.call(document.documentElement);
    else await fsApi.exit.call(document);
  }catch(e){}
  syncFullscreenBtn();
  showUI();
});

document.addEventListener("fullscreenchange", syncFullscreenBtn);
document.addEventListener("webkitfullscreenchange", syncFullscreenBtn);

if(prevPoemBtn) prevPoemBtn.addEventListener("click", ()=>{ setDockActiveButton("dockPlayback"); goPrevPoem(); showUI(); });
if(pausePoemBtn) pausePoemBtn.addEventListener("click", ()=>{ setDockActiveButton("dockPlayback"); togglePaused(); showUI(); });
if(nextPoemBtn) nextPoemBtn.addEventListener("click", ()=>{ setDockActiveButton("dockPlayback"); goNextPoem(); showUI(); });
if(screenshotBtn) screenshotBtn.addEventListener("click", ()=>{ setDockActiveButton("screenshotBtn"); snapScreenshot(); showUI(); });
if(lockCompositionBtn) lockCompositionBtn.addEventListener("click", ()=>{ setDockActiveButton("lockCompositionBtn"); toggleCompositionLock(); showUI(); });
if(menuToggleBtn) menuToggleBtn.addEventListener("click", ()=>{ setDockActiveButton("menuToggleBtn"); toggleUI(); });
if(tabLanguageBtn) tabLanguageBtn.addEventListener("click", (e)=>{ applyDockClickResponse(e); setDockActiveButton("tabLanguageBtn"); setUiPage("language"); showUI(); });
if(tabInfoBtn) tabInfoBtn.addEventListener("click", (e)=>{ applyDockClickResponse(e); setDockActiveButton("tabInfoBtn"); setUiPage("info"); showUI(); });
if(tabContrastBtn) tabContrastBtn.addEventListener("click", (e)=>{ applyDockClickResponse(e); setDockActiveButton("tabContrastBtn"); setUiPage("contrast"); showUI(); });
if(tabColorsBtn) tabColorsBtn.addEventListener("click", (e)=>{ applyDockClickResponse(e); setDockActiveButton("tabColorsBtn"); setUiPage("colors"); showUI(); });
if(tabSpeedBtn) tabSpeedBtn.addEventListener("click", (e)=>{ applyDockClickResponse(e); setDockActiveButton("tabSpeedBtn"); setUiPage("speed"); showUI(); });
if(scopeBgBtn) scopeBgBtn.addEventListener("click", ()=>{ setColorScope("bg"); showUI(); });
if(scopeFgBtn) scopeFgBtn.addEventListener("click", ()=>{ setColorScope("fg"); showUI(); });
if(scopeBdBtn) scopeBdBtn.addEventListener("click", ()=>{ setColorScope("bd"); showUI(); });
if(allOnBtn) allOnBtn.addEventListener("click", ()=>{ setCurrentScopeAll(true); showUI(); });
if(allOffBtn) allOffBtn.addEventListener("click", ()=>{ setCurrentScopeAll(false); showUI(); });

window.addEventListener("keydown", (e)=>{
  if(e.repeat) return;
  const t = e.target;
  const tag = (t && t.tagName) ? String(t.tagName).toLowerCase() : "";
  const isTypingTarget =
    tag === "input" || tag === "textarea" || tag === "select" ||
    (t && t.isContentEditable);
  if(isTypingTarget) return;

  if(e.code === "Space"){
    e.preventDefault();
    setDockActiveButton("dockPlayback");
    togglePaused();
    showUI();
    return;
  }
  if(e.code === "ArrowLeft" || e.code === "ArrowUp"){
    e.preventDefault();
    setDockActiveButton("dockPlayback");
    goPrevPoem();
    showUI();
    return;
  }
  if(e.code === "ArrowRight" || e.code === "ArrowDown"){
    e.preventDefault();
    setDockActiveButton("dockPlayback");
    goNextPoem();
    showUI();
    return;
  }
  if(e.code === "KeyS"){
    e.preventDefault();
    snapScreenshot();
    showUI();
    return;
  }
});

/* ================= Start ================= */
(function init(){
  setViewportVars();
  document.documentElement.style.setProperty("--sceneZoom", "1");
  if(window.visualViewport){
    window.visualViewport.addEventListener("resize", setViewportVars, {passive:true});
    window.visualViewport.addEventListener("scroll", setViewportVars, {passive:true});
  }

  placeDockForViewport();
  // Start collapsed with submenu buttons visible and no adjustment panel open.
  setUiPage("none");

  loadRecentPhrases();
  loadRecentColorCombos();

  initPaletteCycles();
  renderSentenceButtons();

  renderAllSwatches();
  applyAccentColors();
  syncSwatchHeaderWidths();

  sel.borderEnabled = true;
  sel.borderThickness = clamp(Number(bdThickEl.value), 0, 1);

  setBorderBtn();
  applyTypeAndLayout();

  bgBrightVal.textContent = pctLabel(bgBrightEl.value);
  fgBrightVal.textContent = pctLabel(fgBrightEl.value);
  bdBrightVal.textContent = pctLabel(bdBrightEl.value);
  bdThickVal.textContent = `${Math.round(clamp(sel.borderThickness,0,1)*100)}%`;
  speedVal.textContent = formatDuration(speedFromSlider(speedEl.value));
  sizeVal.textContent = `${Math.round(clamp(Number(sizeEl.value),0,150))}%`;

  syncFullscreenBtn();
  syncPauseBtn();
  syncCompositionLockBtn();
  setCalmStart();
  const isCoarse = window.matchMedia("(pointer: coarse)").matches;
  if(isCoarse){
    bdThickEl.value = "0.30";
    sel.borderThickness = 0.30;
  }
  nextFrame();
  // Sync button colors with the live scene.
  assignMobileTabColors();
  scheduleTick();
  hideUI();
})();

window.addEventListener("resize", ()=>{
  setViewportVars();
  placeDockForViewport();
  syncMenuTogglePosition();
  applyTypeAndLayout();
  applyColorsLive();
  syncSwatchHeaderWidths();
  applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
});
</script>
</body>
</html>
