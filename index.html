
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#F7C6D0" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>Sculpture Poems</title>

  <style>
    :root{
      --fg: rgba(0,0,0,0.92);
      --ui: rgba(0,0,0,0.72);
      --ui3: rgba(0,0,0,0.20);
      --vh: 1vh;

      /* UI sizing (gold-standard) */
      --barH: clamp(175px, 21vh, 240px); /* slightly squished vertically */
      --barOffset: 40px; /* LOWER all UI by ~10px vs 50 (since barOffset raises UI up) */

      /* slight scale that doesn't break layout */
      --uiScale: 1.02;

      /* Phrase layout */
      --textScale: 1;
      --fitScale: 1;
      --yPct: 50%;
      --phraseW: 75vw;
      --edgePad: 50px;

      /* Sentence-structure pill sizing */
      --pillH: 16px;
      --pillPadX: 10px;
      --pillFont: 7.1px;

      /* Right-side action buttons (Card / Full screen) */
      --actionW: 86px;

      /* Swatches */
      --swOuter: 1px;
      --swRing: 4px;
      --swW: calc(var(--pillH) * 2);

      /* Global UI padding request */
      --uiPadX: 30px; /* narrower UI: +10px padding each side */

      /* Narrow UI lane (your mockup’s big move) */
      --uiMaxW: 1120px;
      --uiW: min(
        var(--uiMaxW),
        calc(
          100vw
          - (var(--uiPadX) * 2)
          - env(safe-area-inset-left, 0px)
          - env(safe-area-inset-right, 0px)
        )
      );

      /* Title placement (now part of UI + fades) */
      --titlePadTop: 18px; /* moved DOWN slightly */
    }

    *{ box-sizing:border-box; }

    html, body{
      margin:0; padding:0;
      width:100%;
      height:100%;
      overflow:hidden;
      background:#F7C6D0;
      font-family: "Times New Roman", Times, Georgia, serif;
      -webkit-text-size-adjust: 100%;
    }

    body{ min-height: calc(var(--vh, 1vh) * 100); }

    /* Stage above border, below UI */
    #stage{
      position: fixed;
      top:0; left:0;
      width:100vw;
      height: calc(var(--vh, 1vh) * 100);
      pointer-events:none;
      z-index: 20;
    }

    #phrase{
      position:absolute;
      left:50%;
      top: var(--yPct);
      transform: translate(-50%, -50%);
      user-select:none;

      text-align:center;
      width: 100vw;
      max-width: 100vw;
      z-index: 25;
    }

    #phraseText{
      display:block;
      margin-left: auto;
      margin-right: auto;
      font-weight: 650;
      font-size: calc(clamp(32px, 5vw, 92px) * var(--textScale) * var(--fitScale));
      line-height:1.12;
      letter-spacing:.2px;
      width: var(--phraseW);
      max-width: calc(100vw - (var(--edgePad) * 2));
      text-align:center;
      white-space: normal;
      overflow-wrap: normal;
      word-break: normal;
      hyphens: none;
    }

    /* Card behind phrase */
    #card{
      position:absolute;
      left:50%;
      top: var(--yPct);
      transform: translate(-50%, -50%);
      background: transparent;
      pointer-events: none;
      z-index: 10;
    }

    /* ===== UI wrapper (title + bar) ===== */
    #uiWrap{
      position: fixed;
      left:0; right:0;
      top:0; bottom:0;
      z-index: 30;
      pointer-events: none; /* bar re-enables */
      transition: opacity .18s ease, transform .18s ease;
    }
    #uiWrap.hidden{
      opacity:0;
      transform: translateY(10px);
    }
    #uiWrap.hidden #bar,
    #uiWrap.hidden #titleBlock{
      pointer-events: none;
    }

    /* ===== Title (inside uiWrap) ===== */
    #titleBlock{
      position: fixed;
      top: calc(env(safe-area-inset-top, 0px) + var(--titlePadTop));
      left: 0;
      right: 0;
      z-index: 40;
      pointer-events: auto;

      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 6px;

      width: var(--uiW);
      max-width: var(--uiMaxW);
      margin-left: auto;
      margin-right: auto;

      text-align:center;
      color: var(--ui);
    }
    #titleBlock .title{
      font-size: 15.5px;
      letter-spacing: .22em;
      text-transform: uppercase;
      line-height: 1;
      font-weight: 700;
    }
    #titleBlock .sub{
      font-size: 10.5px;
      letter-spacing: .11em;
      text-transform: uppercase;
      line-height: 1.2;
      font-weight: 560;
      opacity: .88;
    }
    /* Title is just the title/subtitle now; all controls live in the bottom dock. */
    #titleControls, #titleExtras{ display:none; }

    .lockBtn{
      height: calc(var(--pillH) + 1px);
      width: 34px; /* match playback icon pills */
      padding: 1px 0 0 0; /* +1px breathing room above the glyph */
      font-size: var(--pillFont);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      position: relative; /* tooltip anchor */
    }
    .lockBtn:hover{ filter: none; }

    .lockIcons{
      position: relative;
      width: 14px;
      height: 14px;
      display:inline-block;
      flex: 0 0 auto;
      opacity: 0.72;
    }
    .lockIcons .lockSvg{
      position:absolute;
      inset:0;
      transition: opacity 140ms ease;
    }
    .lockSvg{
      width: 14px;
      height: 14px;
      display:block;
      overflow: visible;
    }
    .lockBtn .lockSvg--open{ opacity: 1; }
    .lockBtn .lockSvg--closed{ opacity: 0; }
    .lockBtn.locked .lockSvg--open{ opacity: 0; }
    .lockBtn.locked .lockSvg--closed{ opacity: 1; }
    .lockBtn:not(.locked):hover .lockSvg--open{ opacity: 0; }
    .lockBtn:not(.locked):hover .lockSvg--closed{ opacity: 1; }
    .lockBtn.locked:hover .lockSvg--open{ opacity: 1; }
    .lockBtn.locked:hover .lockSvg--closed{ opacity: 0; }

    @media (hover: hover) and (pointer: fine){
      .lockBtn[data-tip]::after{
        content: attr(data-tip);
        position: absolute;
        left: 50%;
        top: calc(100% + 8px);
        transform: translate(-50%, -4px);
        color: var(--ui);
        font-size: 9px;
        letter-spacing: .10em;
        text-transform: uppercase;
        line-height: 1;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity .12s ease, transform .12s ease;
      }
      .lockBtn[data-tip]:hover::after{
        opacity: .9;
        transform: translate(-50%, 0);
      }
    }

    .iconBtn{
      width: 34px;
      height: var(--pillH);
      padding: 0;
      letter-spacing: 0;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border-color: var(--ui3);
      color: var(--ui);
      background: transparent;
      position: relative;
    }
    .iconBtn::before{
      content:"";
      position:absolute;
      inset:0;
      border-radius: inherit;
      background: var(--btnBg, transparent);
    }
    .iconBtn svg{
      width: 14px;
      height: 14px;
      display:block;
      position: relative;
      z-index: 1;
    }
    #pausePoemBtn .playIcon{ display:none; }
    #pausePoemBtn.paused .pauseIcon{ display:none; }
    #pausePoemBtn.paused .playIcon{ display:block; }
    .iconBtn:disabled{
      opacity: 0.35;
      cursor: default;
      background: transparent !important;
    }
    .iconBtn:hover{
      color: var(--ui);
      border-color: var(--ui3);
    }
    .iconBtn:hover::before,
    .iconBtn.forceHover::before{
      background: color-mix(in srgb, var(--btnBg) 70%, transparent);
      filter: none;
    }
    .iconBtn:active::before{
      background: color-mix(in srgb, var(--btnBg) 70%, transparent);
    }
    .iconBtn:disabled:hover{
      filter: none;
      color: var(--ui);
      border-color: var(--ui3);
    }
    .iconBtn:disabled:hover::before{ filter: none; }

    @media (hover: hover) and (pointer: fine){
      .iconBtn[data-tip]::after{
        content: attr(data-tip);
        position: absolute;
        left: 50%;
        bottom: calc(100% + 8px);
        transform: translate(-50%, 4px);
        color: var(--ui);
        font-size: 9px;
        letter-spacing: .10em;
        text-transform: uppercase;
        line-height: 1;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity .12s ease, transform .12s ease;
      }
      .iconBtn[data-tip]:hover::after{
        opacity: .9;
        transform: translate(-50%, 0);
      }
    }

    @media (hover: hover) and (pointer: fine){
      /* Dock button hover text (below the button). */
      .dockBtn[data-tip]{
        position: relative;
      }
      .dockBtn[data-tip]::after{
        content: attr(data-tip);
        position: absolute;
        left: 50%;
        top: calc(100% + 8px);
        transform: translate(-50%, -4px);
        color: var(--ui);
        font-size: 9px;
        letter-spacing: .10em;
        text-transform: uppercase;
        line-height: 1;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity .12s ease, transform .12s ease;
      }
      .dockBtn[data-tip]:hover::after{
        opacity: .9;
        transform: translate(-50%, 0);
      }
    }

    /* ===== Bottom Dock + Sliding Panel ===== */
    #bar{
      position: fixed;
      left:0; right:0;
      bottom: calc(env(safe-area-inset-bottom, 0px) + 16px);
      height: auto;

      padding-left: calc(env(safe-area-inset-left, 0px) + var(--uiPadX));
      padding-right: calc(env(safe-area-inset-right, 0px) + var(--uiPadX));
      padding-bottom: calc(8px + env(safe-area-inset-bottom, 0px));

      pointer-events:auto; /* clickable */
      background: transparent;

      max-height: calc(var(--vh, 1vh) * 100);
      overflow: visible;
    }

    .barInner{
      width: var(--uiW);
      max-width: var(--uiMaxW);
      margin-left: auto;
      margin-right: auto;

      display:flex;
      flex-direction:column;
      gap:0;
      height:auto;
      overflow: visible;

      transform: scale(var(--uiScale));
      transform-origin: bottom center;
    }

    #panelWrap{
      overflow: hidden;
      max-height: 0;
      opacity: 0;
      transform: translateY(14px);
      transition: max-height .22s ease, opacity .18s ease, transform .22s ease;
      pointer-events: none;
      margin-bottom: 0;
    }
    body[data-ui-page]:not([data-ui-page="none"]) #panelWrap{
      max-height: min(62vh, calc(var(--vh, 1vh) * 100 - 120px));
      opacity: 1;
      transform: translateY(-8px); /* pop-up a touch higher; dock stays put */
      pointer-events: auto;
      margin-bottom: 10px;
    }
    #panelInner{
      max-height: inherit;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      display:flex;
      flex-direction:column;
      gap: 10px;
      padding-top: 6px;
    }

    #dock{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 8px;
    }
    #dockPlayback{
      display:flex;
      gap: 10px;
      justify-content:center;
      align-items:center;
    }
    #dockMenu{
      display:flex;
      gap: 10px;
      justify-content:center;
      align-items:center;
      flex-wrap: wrap;
    }
    #dockBottom{
      display:flex;
      gap: 10px;
      justify-content:center;
      align-items:center;
      flex-wrap: wrap;
    }
    .dockBtn{
      height: var(--pillH);
      padding: 0 12px;
      font-size: var(--pillFont);
      min-width: 0;
    }

    .row{
      display:flex;
      gap:12px;
      align-items:flex-end;
      flex-wrap:nowrap;
      min-width:0;
    }
    .centerRow{
      justify-content: center;
      align-items: center;
      text-align: center;
    }

    /* centered 3 swatch sections */
    .colorsRow{
      justify-content: center;
      align-items:flex-end;
      gap: 28px;
      flex-wrap:nowrap;
    }
    /* (removed) vertical swatch column; colors page uses the 3-up row again */

    .grp{
      display:flex;
      flex-direction:column;
      gap:5px;
      min-width:0;
      flex: 0 1 360px;
    }
    .grp.words{
      flex: 0 0 auto;
      align-items: stretch;
    }

    .label{
      font-size: 9px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color: var(--ui);
      user-select:none;
      line-height:1;
      opacity:.82;
      display:block;
      white-space:nowrap;
    }
    .labelRow{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      min-width:0;
    }
    .val{
      font-size: 9px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color: var(--ui);
      opacity:.9;
      user-select:none;
      white-space:nowrap;
    }

    button{
      font: inherit;
      font-weight: 520;
      font-size: 7.1px;
      letter-spacing: .10em;
      text-transform: uppercase;
      color: var(--ui);
      background: transparent;
      border: 1px solid var(--ui3);
      border-radius: 999px;
      padding: 3.6px 6px;
      cursor: pointer;
      line-height: 1;
      user-select: none;
      white-space: nowrap;
      transition: transform .05s ease, border-color .15s ease, color .15s ease, background-color .15s ease;
      -webkit-tap-highlight-color: transparent;
    }
    button:active{ transform: translateY(1px); }
    button:hover{ color: var(--ui); border-color: var(--ui3); }

    /* When a button is "on", kill the outline entirely (keeps sliders unaffected). */
    button.on{ border-color: transparent !important; }
    button.on:hover{ border-color: transparent !important; }

    .colorBtn{
      background: var(--btnBg, transparent);
      border-color: var(--ui3);
      color: var(--ui);
    }
    .colorBtn:not(.on){
      background: transparent;
    }
    .colorBtn:not(.on):hover,
    .colorBtn.forceHover:not(.on){
      background: color-mix(in srgb, var(--btnBg) 50%, transparent);
      filter: none;
      color: var(--ui);
      border-color: var(--ui3);
    }
    .colorBtn.on:hover,
    .colorBtn.forceHover.on{
      background: color-mix(in srgb, var(--btnBg) 70%, transparent);
      filter: none;
      color: var(--ui);
      border-color: transparent;
    }
    .colorBtn:not(.on):active{
      /* Helps Safari apply the hover fill immediately on click. */
      background: color-mix(in srgb, var(--btnBg) 50%, transparent);
    }
    .colorBtn.on:active{
      background: color-mix(in srgb, var(--btnBg) 70%, transparent);
    }
    .colorBtn.disabled{
      opacity: 0.55;
      cursor: default;
      filter: none;
    }

    .btnGroup{
      display:flex;
      flex-wrap:wrap;
      gap:4.5px;
      align-items:center;
      min-width:0;
      overflow: visible;
    }
    .btnGroup.centered{ justify-content: center; }

    .actionSlot{
      display:flex;
      align-items:flex-end;
      justify-content:flex-end;
      margin-left:auto;
      flex: 0 0 auto;
      width: var(--actionW);
    }
    .actionGroup{
      display:flex;
      flex-direction: column;
      align-items:center;
      gap: 6px;
      width: var(--actionW);
    }
    .actionText{
      font-size: 9px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color: var(--ui);
      user-select:none;
      line-height:1;
      opacity:.82;
      white-space:nowrap;
      width: 100%;
      text-align: center;
      padding: 0 2px;
    }

    /* Center the "Sentence Structure" title while keeping the tiny on/off indicator on the right. */
    .grp.words .labelRow{
      position: relative;
      justify-content: flex-end;
      width: 100%;
    }
    .grp.words .labelRow .label{
      position:absolute;
      left:50%;
      transform: translateX(-50%);
    }
    .grp.words .labelRow .hoverVal{
      margin-left: auto;
    }
    .actionBtn{
      text-align:center;
      width: 100%;
      min-width: 0;
    }


    .ssBtn{
      height: var(--pillH);
      padding: 0 var(--pillPadX);
      border-radius: 999px;
      border: 1px solid transparent;
      font-weight: 520;
      font-size: var(--pillFont);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      color: var(--fg);
      background: transparent;
    }
    .ssBtn.on{
      background: var(--ssBg);
      color: var(--fg);
      border-color: transparent;
    }
    .ssBtn:not(.on){
      background: transparent;
      color: var(--ui);
      border-color: var(--ui3);
    }
    .ssBtn:not(.on):hover,
    .ssBtn.forceHover:not(.on){
      background: color-mix(in srgb, var(--ssBg) 50%, transparent);
      filter: none;
      color: var(--ui);
      border-color: var(--ui3);
    }
    .ssBtn.on:hover,
    .ssBtn.forceHover.on{
      background: color-mix(in srgb, var(--ssBg) 70%, transparent);
      filter: none;
      color: var(--ui);
      border-color: transparent;
    }
    .ssBtn:not(.on):active{
      background: color-mix(in srgb, var(--ssBg) 50%, transparent);
    }
    .ssBtn.on:active{
      background: color-mix(in srgb, var(--ssBg) 70%, transparent);
    }

    .sliderRow{
      display:flex;
      gap:12px;
      align-items:flex-end;
      flex-wrap:nowrap;
      min-width:0;
    }

    /* ===== Paged UI (Layout / Language / Colors / Speed) ===== */
    .uiPage{ display:none; }
    body[data-ui-page="layout"] .uiPage--layout{ display:block; }
    body[data-ui-page="language"] .uiPage--language{ display:block; }
    body[data-ui-page="colors"] .uiPage--colors{ display:block; }
    body[data-ui-page="speed"] .uiPage--speed{ display:block; }

    /* Layout panel: fixed 3-up grid like the reference screenshot (desktop),
       and it collapses into a single column on smaller screens. */
    .uiPage--layout{
      --layoutColW: 240px;
      --layoutGap: 70px;
      max-width: calc((var(--layoutColW) * 3) + (var(--layoutGap) * 2));
      margin-left: auto;
      margin-right: auto;
    }
    .uiPage--layout .layoutGridRow{
      display:grid;
      grid-template-columns: repeat(3, var(--layoutColW));
      gap: var(--layoutGap);
      justify-content: center;
      align-items: end;
    }
    .uiPage--layout .layoutActionRow{
      display:grid;
      grid-template-columns: repeat(3, var(--layoutColW));
      gap: var(--layoutGap);
      justify-content: center;
      align-items: end;
    }
    .uiPage--layout .layoutActionRow .actionGroup{
      justify-self: center;
    }
    /* Slightly tighter label typography so it doesn't collide. */
    .uiPage--layout .label,
    .uiPage--layout .val{
      font-size: 8px;
      letter-spacing: .07em;
    }

    @media(max-width: 860px){
      .uiPage--layout{
        max-width: min(520px, 100%);
        --layoutGap: 12px;
      }
      .uiPage--layout .layoutGridRow{
        grid-template-columns: 1fr;
      }
      .uiPage--layout .layoutActionRow{
        grid-template-columns: 1fr;
        gap: 10px;
      }
      .uiPage--layout .layoutActionRow .layoutActionSpacer{ display:none; }
    }

    /* Speed is intentionally narrow and centered. */
    .uiPage--speed .sliderRow{ justify-content: center; }
    .uiPage--speed .ctrl{ flex: 0 1 260px; }

    /* Dock buttons (below playback) start dim and brighten on hover/active. */
    #dockMenu .dockBtn,
    #dockBottom .dockBtn,
    #dockBottom .lockBtn{
      opacity: 0.58;
      transition: opacity .12s ease;
    }
    #dockMenu .dockBtn:hover,
    #dockBottom .dockBtn:hover,
    #dockBottom .lockBtn:hover,
    #dockMenu .dockBtn.on,
    #dockBottom .dockBtn.on,
    #dockBottom .lockBtn.on{
      opacity: 1;
    }
    .ctrl{
      flex: 1 1 0;
      display:flex;
      flex-direction:column;
      gap:3px;
      min-width:0;
    }
    input[type=range]{
      appearance:none;
      width:100%;
      height:16px;
      background:transparent;
      color: var(--thumbCol, var(--fg));
      margin:0;
      padding:0;
      touch-action: none;
    }
    input[type=range]::-webkit-slider-runnable-track{
      height:2px;
      background:var(--ui3);
      border-radius:999px;
    }
    input[type=range]::-moz-range-track{
      height:2px;
      background:var(--ui3);
      border-radius:999px;
    }
    input[type=range]::-webkit-slider-thumb{
      appearance:none;
      width:10px; height:10px;
      border-radius:50%;
      background: currentColor;
      margin-top:-4px;
      border: 1px solid var(--ui);
      box-sizing: border-box;
    }
    input[type=range]::-moz-range-thumb{
      width:10px; height:10px;
      border-radius:50%;
      background: currentColor;
      border: 1px solid var(--ui);
      box-sizing: border-box;
    }

    .swatchWrap{
      display:flex;
      flex-direction:column;
      gap:5px;
      width:100%;
      max-width:100%;
      align-items:center;
    }
    .swatchHeader{
      display:flex;
      justify-content: space-between;
      gap: 10px;
      align-items: baseline;
      width: fit-content;
    }
    .hoverVal{ min-width: 7ch; text-align: right; }

    .swatchRow{
      display:flex;
      flex-wrap:nowrap;
      gap: 10px;
      align-items:center;
      justify-content:center;
      min-width:0;
      max-width: 100%;
      width: fit-content;
    }

    #phraseText.oneWord{
      white-space: normal;
      width: 100%;
      max-width: 100%;
    }

    .swatch{
      width: var(--swW);
      height: var(--pillH);
      padding: 0;
      border-radius: 999px;
      border: var(--swOuter) solid var(--fg);
      background: transparent;
      box-shadow: none;
      cursor: pointer;
      transition: transform .05s ease, filter .12s ease, box-shadow .12s ease, background-color .12s ease;
    }
    .swatch:active{ transform: translateY(1px); }

    .swatch.on{
      background: var(--fillCol);
      box-shadow: inset 0 0 0 var(--swRing) var(--ringCol);
    }
    .swatch:not(.on):hover,
    .swatch.forceHover:not(.on){
      background: color-mix(in srgb, var(--fillCol) 50%, transparent);
      box-shadow: inset 0 0 0 var(--swRing) color-mix(in srgb, var(--ringCol) 50%, transparent);
      filter: none;
    }
    .swatch.on:hover,
    .swatch.forceHover.on{
      background: color-mix(in srgb, var(--fillCol) 70%, transparent);
      box-shadow: inset 0 0 0 var(--swRing) color-mix(in srgb, var(--ringCol) 70%, transparent);
      filter: none;
    }
    .swatch:not(.on):active{
      background: color-mix(in srgb, var(--fillCol) 50%, transparent);
      box-shadow: inset 0 0 0 var(--swRing) color-mix(in srgb, var(--ringCol) 50%, transparent);
    }
    .swatch.on:active{
      background: color-mix(in srgb, var(--fillCol) 70%, transparent);
      box-shadow: inset 0 0 0 var(--swRing) color-mix(in srgb, var(--ringCol) 70%, transparent);
    }

    @supports not (color-mix(in srgb, red 30%, transparent)){
      .swatch{
        background: transparent;
        box-shadow: none;
        opacity: 1;
      }
      .swatch.on{
        background: var(--fillCol);
        box-shadow: inset 0 0 0 var(--swRing) var(--ringCol);
      }
      .swatch:hover{
        background: var(--fillCol);
        box-shadow: inset 0 0 0 var(--swRing) var(--ringCol);
        opacity: 0.85;
      }

      .colorBtn:hover{ background: var(--btnBg, transparent); }
      .ssBtn:hover{ background: var(--ssBg); }
      .iconBtn:hover::before{ background: var(--btnBg, transparent); }
    }

@media (pointer: coarse){
  :root{
    --pillH: 18px;
    --pillPadX: 12px;
    --pillFont: 7.6px;
    --actionW: 94px;
  }
  button{ font-size: 7.4px; padding: 5px 8px; }
  .iconBtn{ width: 42px; height: var(--pillH); padding: 0; }
  .iconBtn svg{ width: 18px; height: 18px; }
  input[type=range]{ height: 22px; }
      input[type=range]::-webkit-slider-thumb{
        width:14px; height:14px;
        margin-top:-6px;
      }
      input[type=range]::-moz-range-thumb{
        width:14px; height:14px;
      }
    }

    @media(max-width: 980px){
      :root{
        --barH: clamp(240px, 34vh, 330px);
        --barOffset: 30px;
        --uiMaxW: 980px;
      }
      .row, .sliderRow{ flex-wrap:wrap; }
      .colorsRow{ flex-wrap:wrap; }
      .grp{ flex: 1 1 320px; }
      .swatchRow{ flex-wrap:wrap; }
    }

    @media(max-width: 640px){
      :root{
        --barH: clamp(260px, 40vh, 370px);
        --barOffset: 20px;
        --pillH: 15px;
        --swW: calc(var(--pillH) * 2);
        --uiMaxW: 620px;
        --titlePadTop: 16px;
      }
      #phraseText{ font-size: calc(clamp(28px, 7vw, 70px) * var(--textScale) * var(--fitScale)); }
      #titleBlock .title{ font-size: 14px; }
      #titleBlock .sub{ font-size: 10px; }
      button{ font-size: 6.8px; padding: 3.4px 5.3px; }
      .label, .val{ font-size: 8.5px; }
      .btnGroup{ gap:4px; }
      .swatchRow{ gap: 9px; flex-wrap:wrap; }
    }

    @media(max-width: 480px), (max-height: 720px){
      :root{
        --barH: clamp(210px, 30vh, 250px);
        --barOffset: 8px;
        --uiScale: 0.96;
        --uiPadX: 14px;
      }
      /* Bottom dock/panel manages its own scrolling (panelInner). */
      #titleBlock{ gap: 4px; }
      #titleBlock .title{ letter-spacing: .18em; }
      #titleBlock .sub{ letter-spacing: .08em; }
    }
  </style>
</head>

<body data-ui-page="none">
  <div id="stage">
    <div id="card" aria-hidden="true"></div>
    <div id="phrase" role="status" aria-live="polite">
      <span id="phraseText"></span>
    </div>
  </div>

  <!-- UI WRAP: title + bar (fades together) -->
  <div id="uiWrap">
    <div id="titleBlock">
      <div class="title">Sculpture Poems</div>
      <div class="sub">written by Margot DeMarco, arranged by ChatGPT</div>
    </div>

    <div id="bar">
      <div class="barInner">

        <!-- MOBILE PAGES -->
        <div id="panelWrap" aria-label="Submenu panel">
          <div id="panelInner">
            <section class="uiPage uiPage--language" aria-label="Language">
              <div class="row centerRow">
                <div class="grp words">
                  <div class="labelRow">
                    <div class="label">Sentence Structure</div>
                    <div class="val hoverVal" id="partsHover">&nbsp;</div>
                  </div>
                  <div class="btnGroup centered" id="partsRow"></div>
                </div>
              </div>
            </section>

            <section class="uiPage uiPage--speed" aria-label="Speed">
              <div class="sliderRow">
                <div class="ctrl">
                  <div class="labelRow"><div class="label">Speed</div><div class="val" id="speedVal">7.0s</div></div>
                  <input id="speedSlider" type="range" min="0" max="1" step="0.001" value="0.595">
                </div>
              </div>
            </section>

            <section class="uiPage uiPage--layout" aria-label="Layout">
              <div class="sliderRow layoutGridRow">
                <div class="ctrl">
                  <div class="labelRow"><div class="label">Background Brightness</div><div class="val" id="bgBrightVal">50%</div></div>
                  <input id="bgBrightSlider" type="range" min="0" max="1" step="0.001" value="0.50">
                </div>
                <div class="ctrl">
                  <div class="labelRow"><div class="label">Text Brightness</div><div class="val" id="fgBrightVal">0%</div></div>
                  <input id="fgBrightSlider" type="range" min="0" max="1" step="0.001" value="0.00">
                </div>
                <div class="ctrl">
                  <div class="labelRow"><div class="label">Card Brightness</div><div class="val" id="bdBrightVal">100%</div></div>
                  <input id="bdBrightSlider" type="range" min="0" max="1" step="0.001" value="1.00">
                </div>
              </div>

              <div class="sliderRow layoutGridRow">
                <div class="ctrl">
                  <div class="labelRow"><div class="label">Text Size</div><div class="val" id="sizeVal">40%</div></div>
                  <input id="sizeSlider" type="range" min="0" max="150" step="0.1" value="40">
                </div>
                <div class="ctrl">
                  <div class="labelRow"><div class="label">Height</div><div class="val" id="yVal">50%</div></div>
                  <input id="ySlider" type="range" min="0" max="100" step="0.01" value="50">
                </div>
                <div class="ctrl">
                  <div class="labelRow"><div class="label">Width</div><div class="val" id="widthVal">40%</div></div>
                  <input id="widthSlider" type="range" min="0" max="100" step="0.01" value="40">
                </div>
              </div>

              <div class="ctrl" style="display:none;">
                <div class="labelRow"><div class="label">Card Size</div><div class="val" id="bdThickVal">30%</div></div>
                <input id="bdThickSlider" type="range" min="0" max="1" step="0.001" value="0.30">
              </div>

              <div class="layoutActionRow">
                <div class="layoutActionSpacer" aria-hidden="true"></div>
                <div class="actionGroup" aria-label="Card">
                  <div class="actionText">Card</div>
                  <button id="bdToggleBtn" type="button" class="colorBtn actionBtn" aria-pressed="true">On</button>
                </div>
                <div class="actionGroup" aria-label="Full screen">
                  <div class="actionText">Full screen</div>
                  <button id="fsBtn" type="button" class="colorBtn actionBtn" aria-pressed="false">Off</button>
                </div>
              </div>
            </section>

            <section class="uiPage uiPage--colors" aria-label="Colors">
              <div class="row colorsRow">
                <div class="grp">
                  <div class="swatchWrap">
                    <div class="swatchHeader">
                      <div class="label">Background Colors</div>
                      <div class="val hoverVal" id="bgHover">&nbsp;</div>
                    </div>
                    <div class="swatchRow" id="bgColorsRow"></div>
                  </div>
                </div>
                <div class="grp">
                  <div class="swatchWrap">
                    <div class="swatchHeader">
                      <div class="label">Text Colors</div>
                      <div class="val hoverVal" id="fgHover">&nbsp;</div>
                    </div>
                    <div class="swatchRow" id="fgColorsRow"></div>
                  </div>
                </div>
                <div class="grp">
                  <div class="swatchWrap">
                    <div class="swatchHeader">
                      <div class="label">Card Colors</div>
                      <div class="val hoverVal" id="bdHover">&nbsp;</div>
                    </div>
                    <div class="swatchRow" id="bdColorsRow"></div>
                  </div>
                </div>
              </div>
            </section>
          </div>
        </div>

        <div id="dock" aria-label="Buttons">
          <div id="dockPlayback" aria-label="Playback controls">
            <button id="prevPoemBtn" type="button" class="iconBtn" aria-label="Previous poem (Left arrow)" data-tip="back">
              <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path d="M15 6l-6 6 6 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
            <button id="pausePoemBtn" type="button" class="iconBtn" aria-label="Pause (Space)" aria-pressed="false" data-tip="play/pause">
              <svg class="pauseIcon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path d="M7 6h3v12H7zM14 6h3v12h-3z" fill="currentColor"/>
              </svg>
              <svg class="playIcon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path d="M9 7l10 5-10 5V7z" fill="currentColor"/>
              </svg>
            </button>
            <button id="nextPoemBtn" type="button" class="iconBtn" aria-label="Next poem (Right arrow)" data-tip="forward">
              <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path d="M9 6l6 6-6 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
          </div>

          <div id="dockMenu" aria-label="Menus">
            <button id="tabLayoutBtn" type="button" class="colorBtn dockBtn" aria-pressed="false">Layout</button>
            <button id="tabLanguageBtn" type="button" class="colorBtn dockBtn" aria-pressed="false">Language</button>
            <button id="tabColorsBtn" type="button" class="colorBtn dockBtn" aria-pressed="false">Colors</button>
            <button id="tabSpeedBtn" type="button" class="colorBtn dockBtn" aria-pressed="false">Speed</button>
          </div>

          <div id="dockBottom" aria-label="Utilities">
            <button id="screenshotBtn" type="button" class="colorBtn dockBtn" aria-label="Screenshot (S)" data-tip="take pic">Screenshot</button>
            <button id="lockCompositionBtn" type="button" class="colorBtn lockBtn" aria-label="Lock composition" aria-pressed="false" data-tip="lock composition">
              <span class="lockIcons" aria-hidden="true">
                <svg class="lockSvg lockSvg--open" viewBox="0 0 24 24" focusable="false" aria-hidden="true">
                  <rect x="5" y="10" width="14" height="12" rx="1.5" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
                  <path d="M7 10V7 Q7 2 12 2 Q17 2 17 7 V10" transform="translate(34 -1) scale(-1 1)" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <rect x="9" y="15" width="6" height="2" fill="currentColor"/>
                </svg>
                <svg class="lockSvg lockSvg--closed" viewBox="0 0 24 24" focusable="false" aria-hidden="true">
                  <rect x="5" y="10" width="14" height="12" rx="1.5" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
                  <path d="M7 10V7 Q7 2 12 2 Q17 2 17 7 V10" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <rect x="11" y="14" width="2" height="5" fill="currentColor"/>
                </svg>
              </span>
            </button>
          </div>
        </div>

      </div>
    </div>
  </div>

<script>
/* ================= Helpers ================= */
function uniq(arr){
  const s = new Set();
  for(const x of arr){
    const v = String(x ?? "").trim().replace(/\s+/g," ");
    const v2 = v.toLowerCase();
    if(v2) s.add(v2);
  }
  return Array.from(s);
}
function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
function lerp(a,b,t){ return a + (b-a)*t; }

function shuffleInPlace(a){
  for(let i=a.length-1;i>0;i--){
    const j = (Math.random()*(i+1))|0;
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}

function setViewportVars(){
  const vv = window.visualViewport;
  const h = (vv ? vv.height : window.innerHeight) * 0.01;
  document.documentElement.style.setProperty("--vh", `${h}px`);
}

function getViewportSize(){
  const vv = window.visualViewport;
  return {
    w: vv ? vv.width : window.innerWidth,
    h: vv ? vv.height : window.innerHeight
  };
}

function parsePx(val){
  const n = Number(String(val || "").replace("px","").trim());
  return Number.isFinite(n) ? n : 0;
}
function getRootVarPx(name){
  return parsePx(getComputedStyle(document.documentElement).getPropertyValue(name));
}
function getRootVarVw(name){
  const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  if(v.endsWith("vw")) return Number(v.replace("vw","").trim());
  const n = Number(v);
  return Number.isFinite(n) ? n : null;
}

/* ================= Non-repeating shuffle bags ================= */
const BAGS = new Map();
function bagNext(key, pool){
  const cleanPool = uniq(pool);
  if(!cleanPool.length) return null;

  const sig = cleanPool.join("␟");
  const prev = BAGS.get(key);

  if(!prev || prev._sig !== sig){
    const arr = cleanPool.slice();
    shuffleInPlace(arr);
    BAGS.set(key, { arr, i: 0, _sig: sig });
  }
  const bag = BAGS.get(key);
  if(bag.i >= bag.arr.length){
    shuffleInPlace(bag.arr);
    bag.i = 0;
  }
  const out = bag.arr[bag.i];
  bag.i++;
  return out;
}

/* ================= Palettes ================= */
const PAL = {
  circus: ["#FF6AD5","#FF8A00","#FF4D1A","#C85AE0","#FF007A"],
  beachy: ["#BDE8FF","#8FB2CF","#CBE7FF","#445F86","#74A8E8"],
  fleshy: ["#F7D59B","#F6B77D","#B7852F","#F7B59D","#E1780A"],
  future: ["#9EDB00","#C86AD6","#F8C6A4","#B23A2B","#7FB1D9"],
  retro:  ["#DDE6B7","#00AEB0","#D85A10","#B10D33","#F6A623"],
  earthy: ["#A7B827","#D79A16","#536A00","#6F8A1A","#806200"]
};

/* ================= Color helpers ================= */
function hexToRgb(hex){
  const h = hex.replace("#","").trim();
  const full = h.length === 3 ? h.split("").map(c=>c+c).join("") : h;
  const n = parseInt(full,16);
  return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
}
function rgbToHex(r,g,b){
  const to = (v)=> v.toString(16).padStart(2,"0");
  return "#" + to(r) + to(g) + to(b);
}
function rgbToHsl(r,g,b){
  r/=255; g/=255; b/=255;
  const max = Math.max(r,g,b), min = Math.min(r,g,b);
  let h=0, s=0;
  const l = (max+min)/2;
  const d = max-min;
  if(d !== 0){
    s = d / (1 - Math.abs(2*l - 1));
    switch(max){
      case r: h = ((g-b)/d) % 6; break;
      case g: h = (b-r)/d + 2; break;
      case b: h = (r-g)/d + 4; break;
    }
    h *= 60;
    if(h < 0) h += 360;
  }
  return {h, s, l};
}
function hslToRgb(h,s,l){
  const c = (1 - Math.abs(2*l - 1)) * s;
  const x = c * (1 - Math.abs(((h/60) % 2) - 1));
  const m = l - c/2;
  let rp=0,gp=0,bp=0;

  if(0<=h && h<60){ rp=c; gp=x; bp=0; }
  else if(60<=h && h<120){ rp=x; gp=c; bp=0; }
  else if(120<=h && h<180){ rp=0; gp=c; bp=x; }
  else if(180<=h && h<240){ rp=0; gp=x; bp=c; }
  else if(240<=h && h<300){ rp=x; gp=0; bp=c; }
  else { rp=c; gp=0; bp=x; }

  return { r: Math.round((rp+m)*255), g: Math.round((gp+m)*255), b: Math.round((bp+m)*255) };
}
function setHsl(hex, h, s, l){
  const out = hslToRgb(h, s, l);
  return rgbToHex(out.r,out.g,out.b);
}

/* brightness dimmer */
function applyDimmer(hex, sliderVal){
  const t = clamp(Number(sliderVal), 0, 1);
  const {r,g,b} = hexToRgb(hex);
  let {h,s,l} = rgbToHsl(r,g,b);

  if(Math.abs(t - 0.5) < 1e-6) return hex;

  if(t < 0.5){
    const k = (0.5 - t) / 0.5;
    const lMul = lerp(1.0, 0.42, k);
    l = clamp(l * lMul, 0.08, 0.90);
    s = clamp(s * lerp(1.0, 1.10, k), 0.18, 0.98);
  }else{
    const k = (t - 0.5) / 0.5;
    l = clamp(l + (1 - l) * (0.33 * k), 0.08, 0.92);
    s = clamp(s * lerp(1.0, 1.28, k), 0.18, 0.98);
  }
  return setHsl(hex, h, s, l);
}

function lightestHexFromPalette(palName){
  const pal = PAL[palName] || [];
  let best = pal[0] || "#ffffff";
  let bestL = -1;
  for(const hex of pal){
    const {r,g,b} = hexToRgb(hex);
    const {l} = rgbToHsl(r,g,b);
    if(l > bestL){
      bestL = l;
      best = hex;
    }
  }
  return best;
}
function darkestHexFromPalette(palName){
  const pal = PAL[palName] || [];
  let best = pal[0] || "#000000";
  let bestL = 2;
  for(const hex of pal){
    const {r,g,b} = hexToRgb(hex);
    const {l} = rgbToHsl(r,g,b);
    if(l < bestL){
      bestL = l;
      best = hex;
    }
  }
  return best;
}

/* ================= Controls ================= */
const PART_OPTS = ["description","object","person","action","location"];
const COLOR_OPTS = ["earthy","beachy","fleshy","retro","future","circus"];
const SLIDER_PALS = ["circus","beachy","fleshy","retro","future","earthy","circus","beachy"];
const palCycleIndex = {};
const swatchRowOffset = { bg: 0, fg: 0, bd: 0 };
const titleCtrlTheme = { prev: "beachy", pause: "fleshy", next: "circus" };

function initPaletteCycles(){
  for(const name of COLOR_OPTS) palCycleIndex[name] = 0;
  const palLen = (PAL[COLOR_OPTS[0]] || []).length || 5;
  swatchRowOffset.bg = Math.floor(Math.random() * palLen);
  swatchRowOffset.fg = Math.floor(Math.random() * palLen);
  swatchRowOffset.bd = Math.floor(Math.random() * palLen);

  // Title transport controls: pick 3 different palettes so the buttons don't match.
  const picks = COLOR_OPTS.slice();
  shuffleInPlace(picks);
  titleCtrlTheme.prev = picks[0] || "beachy";
  titleCtrlTheme.pause = picks[1] || picks[0] || "fleshy";
  titleCtrlTheme.next = picks[2] || picks[0] || "circus";
}
function paletteColor(name, offset=0){
  const pal = PAL[name] || [];
  if(!pal.length) return "#000000";
  const idx = palCycleIndex[name] ?? 0;
  return pal[(idx + offset) % pal.length];
}
function normHex(hex){
  return String(hex || "").trim().toLowerCase();
}
function getBgLiveHex(){
  // Prefer the actual rendered background; fall back to what we'd compute right now.
  const live = normHex(current.bgLive);
  if(live) return live;
  return normHex(applyDimmer(current.bgBase, Number(bgBrightEl.value)));
}
function paletteColorAvoid(palName, offset=0, avoidHex=""){
  const pal = PAL[palName] || [];
  if(!pal.length) return "#000000";
  const avoid = normHex(avoidHex);
  const idx = palCycleIndex[palName] ?? 0;
  if(!avoid) return pal[(idx + offset) % pal.length];

  for(let i=0; i<pal.length; i++){
    const c = pal[(idx + offset + i) % pal.length];
    if(normHex(c) !== avoid) return c;
  }
  return pal[(idx + offset) % pal.length];
}

function nudgeHex(hex, lDelta=0.07){
  const {r,g,b} = hexToRgb(hex);
  let {h,s,l} = rgbToHsl(r,g,b);
  l = clamp(l + lDelta, 0, 1);
  return setHsl(hex, h, s, l);
}

function pickUniquePaletteColor(palName, startOffset, usedNormSet, avoidHex=""){
  const pal = PAL[palName] || [];
  if(!pal.length) return "#000000";
  const avoid = normHex(avoidHex);
  const idx = palCycleIndex[palName] ?? 0;

  // First pass: avoid background + avoid already-used colors.
  for(let i=0; i<pal.length; i++){
    const c = pal[(idx + startOffset + i) % pal.length];
    const cn = normHex(c);
    if(cn === avoid) continue;
    if(usedNormSet && usedNormSet.has(cn)) continue;
    if(usedNormSet) usedNormSet.add(cn);
    return c;
  }

  // Second pass: if the only remaining option matches background, nudge it so it's not identical.
  for(let i=0; i<pal.length; i++){
    const c = pal[(idx + startOffset + i) % pal.length];
    const cn = normHex(c);
    if(usedNormSet && usedNormSet.has(cn)) continue;
    const out = (cn === avoid) ? nudgeHex(c, 0.06) : c;
    if(usedNormSet) usedNormSet.add(normHex(out));
    return out;
  }

  // Fallback: any unused color from any palette (nudged if needed).
  return pickUniqueAnyColor(usedNormSet, avoidHex);
}

function pickUniqueAnyColor(usedNormSet, avoidHex=""){
  const avoid = normHex(avoidHex);
  for(const palName of COLOR_OPTS){
    const pal = PAL[palName] || [];
    const idx = palCycleIndex[palName] ?? 0;
    for(let i=0; i<pal.length; i++){
      const c = pal[(idx + i) % pal.length];
      const cn = normHex(c);
      if(cn === avoid) continue;
      if(usedNormSet && usedNormSet.has(cn)) continue;
      if(usedNormSet) usedNormSet.add(cn);
      return c;
    }
  }
  // Absolute last resort: re-use a color, nudged.
  const first = (PAL[COLOR_OPTS[0]] || [])[0] || "#000000";
  const out = nudgeHex(first, 0.09);
  if(usedNormSet) usedNormSet.add(normHex(out));
  return out;
}

function pickRingColor(palName, startOffset, avoidHex="", fillHex=""){
  const pal = PAL[palName] || [];
  if(!pal.length) return "#cccccc";
  const idx = palCycleIndex[palName] ?? 0;
  const avoid = normHex(avoidHex);
  const fillN = normHex(fillHex);
  for(let i=0; i<pal.length; i++){
    const c = pal[(idx + startOffset + i) % pal.length];
    const cn = normHex(c);
    if(cn === fillN) continue;
    if(cn === avoid) continue;
    return c;
  }
  return pal[(idx + startOffset) % pal.length];
}
function advancePaletteCycle(){
  for(const name of COLOR_OPTS){
    const pal = PAL[name] || [];
    if(!pal.length) continue;
    palCycleIndex[name] = (palCycleIndex[name] + 1) % pal.length;
  }
}

/* ================= DOM refs ================= */
const phraseEl = document.getElementById("phraseText");
const uiWrapEl = document.getElementById("uiWrap");
const barEl = document.getElementById("bar");
const cardEl = document.getElementById("card");

const speedEl = document.getElementById("speedSlider");
const bgBrightEl = document.getElementById("bgBrightSlider");
const fgBrightEl = document.getElementById("fgBrightSlider");
const bdBrightEl = document.getElementById("bdBrightSlider");

const sizeEl  = document.getElementById("sizeSlider");
const yEl     = document.getElementById("ySlider");
const widthEl = document.getElementById("widthSlider");

const bdThickEl = document.getElementById("bdThickSlider");
const bdToggleBtn = document.getElementById("bdToggleBtn");
const fsBtn = document.getElementById("fsBtn");
const prevPoemBtn = document.getElementById("prevPoemBtn");
const pausePoemBtn = document.getElementById("pausePoemBtn");
const nextPoemBtn = document.getElementById("nextPoemBtn");
const screenshotBtn = document.getElementById("screenshotBtn");
const lockCompositionBtn = document.getElementById("lockCompositionBtn");
const tabLayoutBtn = document.getElementById("tabLayoutBtn");
const tabLanguageBtn = document.getElementById("tabLanguageBtn");
const tabColorsBtn = document.getElementById("tabColorsBtn");
const tabSpeedBtn = document.getElementById("tabSpeedBtn");

const speedVal = document.getElementById("speedVal");
const bgBrightVal = document.getElementById("bgBrightVal");
const fgBrightVal = document.getElementById("fgBrightVal");
const bdBrightVal = document.getElementById("bdBrightVal");
const sizeVal = document.getElementById("sizeVal");
const yVal = document.getElementById("yVal");
const widthVal = document.getElementById("widthVal");
const bdThickVal = document.getElementById("bdThickVal");

/* hover labels */
const bgHover = document.getElementById("bgHover");
const fgHover = document.getElementById("fgHover");
const bdHover = document.getElementById("bdHover");
const partsHover = document.getElementById("partsHover");

const sliderEls = [
  speedEl, bgBrightEl, fgBrightEl, bdBrightEl,
  bdThickEl, sizeEl, yEl, widthEl
];

/* ================= Mobile UI pages ================= */
const UI_PAGES = ["none","layout","language","colors","speed"];
let uiPage = "none";
const mobilePagerMQ = window.matchMedia ? window.matchMedia("(max-width: 820px)") : null;

function isMobilePaged(){
  return !!(mobilePagerMQ && mobilePagerMQ.matches);
}
function syncMobilePagedClass(){
  document.body.classList.toggle("isMobilePaged", isMobilePaged());
}
function setTabPressed(btn, on){
  if(!btn) return;
  btn.classList.toggle("on", on);
  btn.setAttribute("aria-pressed", on ? "true" : "false");
  btn.setAttribute("aria-selected", on ? "true" : "false");
}
function assignMobileTabColors(){
  // Change colors on each page switch; avoid matching the live background.
  const bgAvoid = getBgLiveHex();
  const exclude = new Set([bgAvoid]);

  const pool = new Set(COLOR_OPTS);
  const b1 = pickColorNonRepeating("tabs", pool, exclude) || paletteColorAvoid("retro", 0, bgAvoid);
  exclude.add(normHex(b1));
  const b2 = pickColorNonRepeating("tabs", pool, exclude) || paletteColorAvoid("fleshy", 1, bgAvoid);
  exclude.add(normHex(b2));
  const b3 = pickColorNonRepeating("tabs", pool, exclude) || paletteColorAvoid("future", 2, bgAvoid);
  exclude.add(normHex(b3));
  const b4 = pickColorNonRepeating("tabs", pool, exclude) || paletteColorAvoid("circus", 3, bgAvoid);
  exclude.add(normHex(b4));
  const b5 = pickColorNonRepeating("tabs", pool, exclude) || paletteColorAvoid("earthy", 4, bgAvoid);
  exclude.add(normHex(b5));
  const b6 = pickColorNonRepeating("tabs", pool, exclude) || paletteColorAvoid("beachy", 0, bgAvoid);

  if(tabLayoutBtn) tabLayoutBtn.style.setProperty("--btnBg", b1);
  if(tabLanguageBtn) tabLanguageBtn.style.setProperty("--btnBg", b2);
  if(tabColorsBtn) tabColorsBtn.style.setProperty("--btnBg", b3);
  if(tabSpeedBtn) tabSpeedBtn.style.setProperty("--btnBg", b4);
  if(screenshotBtn) screenshotBtn.style.setProperty("--btnBg", b5);
  if(lockCompositionBtn) lockCompositionBtn.style.setProperty("--btnBg", b6);
}
function setUiPage(next){
  const page = UI_PAGES.includes(next) ? next : "none";
  // Tap the active tab again to collapse back to "tabs only".
  const finalPage = (uiPage === page && page !== "none") ? "none" : page;
  uiPage = finalPage;
  document.body.dataset.uiPage = finalPage;
  setTabPressed(tabLayoutBtn, finalPage === "layout");
  setTabPressed(tabLanguageBtn, finalPage === "language");
  setTabPressed(tabColorsBtn, finalPage === "colors");
  setTabPressed(tabSpeedBtn, finalPage === "speed");

  // Recolor on every page switch.
  assignMobileTabColors();
}

/* ================= Selection state ================= */
const sel = {
  parts: new Set(["description","person","action","location"]),
  bgColor: new Set(COLOR_OPTS),
  fgColor: new Set(COLOR_OPTS),
  bdColor: new Set(COLOR_OPTS),
  borderEnabled: true,
  borderThickness: Number(bdThickEl.value)
};

/* ================= Vocab banks ================= */
/*
  Editing tips:
  - One entry per line.
  - Blank lines are fine.
  - Everything is lowercased + de-duped at runtime.
*/
function vocabLines(str){
  return uniq(
    str
      .split("\n")
      .map(s => String(s).replace(/\r/g, "").trim())
      .filter(Boolean)
      .map(s => s.toLowerCase())
  );
}

/* description (object) */
const DESC_OBJECT = vocabLines(`
brittle
woolen
velvety
ashen
antique
stately
baggy
bent
folded neatly
brassy
brilliant
bumpy
burnt
buttery
buzzing
charming
crumbly
crunchy
lightly crushed
drafty
dreamy
dusty
dimly lit
feathery
flashy
flavorful
fleshy
foamy
frosted
fruity
fried
furry
gentle
ghostly
gigantic
greasy
hard
jealous
joyful
jazzy
jiggly
leisurely
lively
messy
moldy
mysterious
nervous
oily
orderly
ornamental
painted
pearly
pillowy
poetic
poignant
polished
powdery
ribbed
rocky
salty
sandy
scrambled
sculpted
sculptural
slimy
slippery
smelly
smoggy
soft
stormy
strange
strappy
sweet
thick
thirsty
windy
worried
wrapped
sweaty
sunset
daybreak
elevated
elongated
smooth
curly
twisted
wiggly
burnished
reclusive
exploratory
introverted
dingy
patched
repaired
tarnished
melted
enlarged
moist
dewy
plump
buff
extended
compact
oversized
skimpy
malaise
ennui
weary
blasé
detached
indifferent
futile
languid
listless
vivacious
zestful
vigorous
verve
élan
immersed
flowing
delighted
radiant
witty
buoyant
spontaneous
lighthearted
attentive
subtle
nuanced
deft
precise
perceptive
evocative
suggestive
sparkly
glittery
loud
silent
muffled
wet
damp
dry
cracked
spilt
spoiled
rotten
fresh
growing
withering
elegant
crude
muscular
lean
long
short
tall
slim
chubby
cute
ugly
beautiful
contrasting
hairy
bald
shaved
stubbly
rough
matte
glossy
refined
understated
restrained
poised
tailored
classical
grand
petite
considered
ritualistic
witchy
dried out
lumpy
mindful
civilized
unhurried
guarded
formal
discreet
reserved
confident
diaphanous
opalescent
iridescent
mother-of-pearl
inlaid
sunken
padded
carpeted
sullen
supple
undulating
ubiquitous
obsequious
dulcet
flickering
fugitive
insular
smoky
atonal
hushed
muted
esoteric
arcane
hermetic
cryptic
wistful
pensive
yearning
plaintive
ethereal
reflective
nostalgic
reminiscent
unspoken
unrequited
accepting
tempered
subdued
veiled
balanced
tasteful
delicate
poorly proportioned
gracefully arranged
lightly worn
tenderly handled
gently used
herringbone
stone
quartz
emerald
ruby
diamond encrusted
granite
marble
soapstone
soapy
tie-died
asymmetrical
unbalanced
effervescent
despondent
petulant
hedonistic
gluttonous
malnourished
overflowing
puffy
bloated
maladjusted
transparent
translucent
decaying
plaintive
rueful
unctuous
a sycophantic
anti-fascist
ossified
vermicular
serene
freshly repaired
compact
pocket-sized
distended
muscular
lithe
`);

/* description (person) */
const DESC_PERSON = vocabLines(`
retired
blonde
introverted
kleptomaniac
handsome
shaved
athletic
hedonistic
fastidious
lithe
chubby
skeletal
tattooed
blue collar

 tall
 pregnant
 short
 non-binary
 young
 youthful
 lanky
 failed
 transsexual
 old
 teenaged
 specialized
 infantile
 amateur
 professional
 skilled
 bumbling
 hapless
 feckless
 disgruntled
 irritated
 irate
 cranky
 clever
 gray-haired
 balding
 artistic
 eager
 dancing
 skanky
 female
 male
 new
 weary
 exhausted
 zippy
 jet-lagged
 quick-thinking
 frugal
 dehydrated
 desperate
 hateful
 generous
 incompetent
 gorgeous
 annoying
 witchy
 hairless
 excited
 well dressed
 elegant
 stylish
 chic
 uptight
 down-to-earth
 earthy
 foolish
 divorced
 unwed
 tiny
 slim
 curvy
 bloated
 dried out
 depressed
 unemployed
 slumped-over
 leggy
 tired
 glamorous
 lethargic
 crude
 illiterate
 educated
 scholarly
 pretentious
 humble
 rude
 betrayed
 stunned
 sober
 alcoholic
 paint splattered
 distraught
 gay
 sleepy
 heterosexual
 easygoing
 good natured
 creepy
 sweaty
 moody
 unhappy
 french
 italian
 greek
 greedy
 adventurous
 scandalized
 prudish
 high strung
 easy going
 tightly wound
 wounded
 injured
 indigenous
 red headed
 long haired
 short haired
 greasy
 obsessive
 introspective
 slimy
 dorky
 cool
 fresh-faced
 jaded
 surly
 over-dressed
 under-dressed
 scantily clad
 petulant
 bratty
 disgraced
 clueless
 unaware
 prickly
 shrewd
 punk rock
 hipster
 steampunk
 rockabilly
 jazzy
 funky
 broke
 barefoot
 sunburned
 naive
 idealistic
 optimistic
 pessimistic
 prospective
 potential
 future
 former
 recovering
 british
 underground
 indie
 popular
 famous
 infamous
 wealthy
 rich
 poor
 charming
 flashy
 glitzy
 spunky
 vivacious
 unpleasant
 uncomfortable
 awkward
 nerdy
 suave
 worldly
 inexperienced
 immature
 sophisticated
 snappy
 hilarious
 ridiculous
 blind
 deaf
 elite
 insular
 closed-minded
 bigoted
 insecure
 confident
 brassy
 feminine
 butch
 queer
 plus-sized
 petite
 primped
 overstimulated
 overwhelmed
 shy
 gen-x
 witty
 eccentric
 frazzled
 progressive
 conservative
 liberal
 right-wing
 left-wing
 leftist
 maoist
 communist
 socialist
 ribald
 erudite
 pacifist
 aggressive
 talkative
 quiet
 silent
  autistic
  neuro divergent
  virginal
  anarchist
  antifa
`);

/* object */
const OBJECTS = vocabLines(`
dish rack
drying rack
clothes line
shower head
kitchen sink
vanity mirror
hair brush
toilet paper
coffee mug
tea pot
tea bag
coffee maker
french press
percolator
frying pan
cutting board
crock pot
soupspoon
laundry basket
laundry hamper
trash can
mop bucket
broom
bed
mattress
bookshelf
bookcase
curtains
doorknob
window
lamp
lampshade
clock
wrist watch
cabinet
drawer
coffee table
ottoman
couch
love seat
chaise longue
cushion
throw pillow
duvet
comforter
bath tub
hot tub
jacuzzi
lipstick
lip gloss
blush
makeup
nail polish
perfume bottle
deodorant
hair clip
hair tie
high heels
tights
pantyhose
cardigan
turtleneck
necklace
bracelet
wedding band
ring
pendant
pizza box
mini fridge
refrigerator
oven
freezer
closet
hardwood floor
carpet
rug
upholstery
remote control
computer monitor
ipad
tablet
wardrobe
drapery
portrait
trophy
moving boxes
linen napkin
room service tray
soap
keyboard
printer
xerox machine
photocopier
cash register
envelope
notebook
dictionary
paperback book
workbench
sawhorse
chisel
paint brush
spray paint
ink wash
canvas
plywood
ladder
toolbox
tape measure
scissors
drill press
table saw
bandsaw
vacuum cleaner
hot glue gun
dental pick
drill
office cubicle
lecture hall
waiting room
doctor's office
library
gallery
museum
atm
seltzer
diner booth
martini
cocktail
wine glass
taqueria
dive bar
dance club
punk club
rave
comedy club
microphone
record store
playing cards
chess board
board game
video game
playstation
slot machine
grand piano
pipe organ
drum kit
synthesizer
bicycle
station wagon
hatchback
convertible
sports car
subaru forester
water slide
trailhead
switchback
mountain lodge
skis
baseball bat
harmonica
folded map
ticket stub
drinking glass
beer stein
high ball glass
ash tray
dust pan
chapstick
dining room table
end table
bedside table
night stand
foot rest
foot stool
step ladder
scaffolding
beer can
beer bottle
canned cocktail
mocktail
mojito
margarita
pilsner
lager
guinness
draft beer
rosé wine
glass of blush
hot toddy
green juice
celery juice
pomegranate juice
carrot juice
tomato juice
noodles
legal pad
note pad
eye drops
bluetooth speaker
suv
mini-van
lawn mower
air conditioner
recycling bin
white glue
superglue
krazy glue
bouncy ball
bacon egg and cheese
bagel with cream cheese
peanut butter and jelly
hero sandwich
gyro
mission style burrito
enchiladas
t-shirt
tank top
scoop neck shirt
spaghetti strap tank top
undershirt
tube top
push-up bra
bralette
lace thong
lace underwear
lace bra
halter top
knit sweater
knitting needles
ball of yarn
cheeseburger
hamburger
big mac
fried chicken sandwich
grilled chicken sandwich
couscous
quinoa
grain bowl
paint bucket
side salad
caesar salad
greek salad
cucumber salad
seaweed salad
garlicky kale
rice bowl
mexican food
italian food
french food
japanese food
korean food
ham sandwich
ramen
bento box
japanese curry
chicken katsu
karaage
nashville hot fried chicken
pulled pork sandwich
pastrami on rye
egg salad
poached egg
hard boiled egg
soft boiled egg
fried rice
wicker basket
cross-body bag
denim skirt
handbag
shopping cart
purse
catchers mitt
baseball glove
fingerless gloves
driving gloves
steering wheel
gaming chair
rocking chair
vending machine
slate tile
granite counter tops
bulletin board
tie pin
name tag
sheriff's badge
bunk beds
futon
keg of beer
fur pelt
participation trophy
absinthe
fernet
aperol spritz
tequila shot
whisky sour
moo shu pork
propeller beanie
metal detector
geiger counter
nitrous oxide canister
baggie of ketamine
heroin spoon
bag of weed
mushroom chocolate
tab of acid
laser pointer
dvd player
hedge trimmer
weed whacker
dirt bike
chopper
pinwheel
solar panel
sprinter van
ford bronco
riding lawn mower
instruction manual
printed out pdf
roku tv
flip phone
trade paperback
dvd box set
blu-ray player
cd-rom
oled panel
circuit board
circuit breaker
portable fan
croquet mallet
croquette
sizzling fajita platter
bibimbap
wedge salad
director's chair
padded booth
straight jacket
hot dog cart
x-ray machine
samovar of coffee
electric kettle
air fryer
wine decanter
whoopie cushion
sound board
alarm bell
birdbath
birdcage
birdhouse
hourglass
sundial
pendulum
pocket watch
velvet rope
bank vault
water tower
traffic median
airport shuttle
dune buggy
dump truck
freight train
gondola
greenhouse
terrarium
record player
typewriter
ukulele
trombone
tambourine
saxophone
banjo
bagpipe
brownstone
townhouse
alleyway
dumpster
manhole cover
sewer
parking garage
parking lot
driveway
parachute
bungee cord
propeller
umbrella
cooler
cardboard box
tissue box
newspaper
tombstone
baby bottle
maxi pad
deck chair
neon sign
fidget spinner
pack of cigarettes
bow tie
christmas lights
shop vac
crushed cicodin
line of cocaine
hash pipe
opium tea
welding mask
latex mask
leather gloves
hairpiece
chunky heels
reading glasses
tap shoes
kitten heels
sensible pumps
strappy sandals
potted plant
succulent garden
old washing machine
`);

/* person */
const PERSONS = vocabLines(`
nun
painter
bathroom attendant
substitute teacher
step-dad

 art therapist
 couples therapist
 woodcarver
 athlete
 machinist
 woman
 man
 grandpa
 grandma
 step-mom
 day trader
 producer
 farmer
 sculptor
 architect
 refugee
 immigrant
 butt-head
 fascist
 singer
 roadie
 trucker
 journalist
 reporter
 newscaster
 podcaster
 politician
 bully
 jock
 straight guy
 guitar player
 piano player
 florist
 flautist
 jazz singer
 tech bro
 poet
 student
 brain surgeon
 intern
 novelist
 mayor
 police officer
 meter maid
 standup comic
 improv comic
 playwright
 jerk
 mother
 father
 person
 guy
 artist
 dancer
 performance artist
 gymnast
 pervert
 luddite
 dude
 bro
 stud
 babe
 model
 chef
 photographer
 shopkeep
 boat builder
 crane operator
 nurse
 hair stylist
 barber
 insurance broker
 ex-wife
 ex-husband
 businessman
 businesswoman
 masseuse
 waitress
 waiter
 flight attendant
 secretary
 bodega guy
 neighbor
 best friend
 acquaintance
 friend
 roommate
 housemate
 grad student
 coal miner
 chaperone
 dj
 middle manager
 employee
 art teacher
 gym teacher
 homosexual
 heterosexual
 insomniac
 homeowner
`);

/* action */
const ACTIONS = vocabLines(`
blowing in the wind
soaking wet
floating
stretched out
upside-down
broken
misaligned
rusted
left out overnight
cooling slightly
resting quietly
waiting in line
balanced on a ledge
caught in the rain
glowing softly
drying on a rack
spilling a little
sitting untouched
freshly unpacked
carefully stacked
sliding across a table
tucked into a drawer
leaning against a wall
half-finished
freshly cleaned
still warm
still damp
shaking slightly
humming faintly
flickering
dripping quietly
vibrating faintly
flickering softly
humming to itself
half submerged
zipping a suitcase slowly
resting against a window
opening the shutters
standing at the window while the city wakes
steaming
melting on a slice of warm toast
lighting a candle
blowing out a candle
gently dabbing perfume
people watching
caught in a summer rain
under dappled light
pressed into velvet
soaked in sweat
smudged at the edges
warped by heat
straining its seams
wrapped in tape
staining the counter
ringing slightly
treading mud onto the carpet
a little damp
glistening
knocked over
getting a tattoo
shoplifting
crushing garlic
slicing onions
wandering aimlessly
jogging first thing in the morning
pulled a muscle
picking a scab
popping a pimple
vibrating
flossing aggressively
sunbathing
polishing boots
making a smoothie
gesturing wildly
fidgeting anxiously
impatiently waiting
soul-searching
looking within
filled with an overwhelming sense of dread
overcome with malaise
suffering silently
dented on the corner
slightly angled
with a skewed perspective
shopping
bored
is smoking a cigarette
sucking on a vape pen
blowing smoke rings
doing kegels
effortlessly arranged
nonchalantly tossed aside
with chipped paint
wrapped in plastic
mounted to the wall
cast in bronze
buried in the back yard
stuck in mud
splayed apart
cast aside
smoldering
glistening
growing taller
getting shorter
shrinking
singing softly
touching itself
throwing a frisbee
playing mini golf
getting a haircut
floating
drying out in the sun
resigned to its fate
crunching the numbers
driving a tractor
buried under rubble
rescued from danger
stuck in a rut
approaching middle age
on its last legs
kicking back
searching for meaning
losing weight
rocking back and forth
self-soothing
comparison shopping
filled with jealousy
stuck in traffic
is getting annoyed
rolling downhill
putting its feet up
tapping lightly
scratching itself
masturbating furiously
committing perjury
serving on a jury
performing surgery
studying german
flipping through a magazine
wearing cutoffs
wearing a bikini
strutting its stuff
freak dancing
doing the macarena
twisting and turning
spinning in circles
pogo dancing
bouncing up and down
buying crypto
lip-syncing
covered in vaseline
lubed up
toweled dry
resting
taking a load off
emitting a high pitched sound
howling
hooting
smiling
frowning
weeping
grinning to itself
standing alone
looking out the window
staring into the middle-distance
losing interest
bored
grumpy
cranky
clingy
getting the ick
sitting on a balcony
left out in the cold
getting moldy
licking its wounds
sick of arguing
with nothing to say
keeping its head down
sobbing softly
caught crying
holding back tears
jacking off
committing fraud
on the run
in hiding
tucked into bed
hiding under the covers
stuck in a tree
carving marble
falling down
toppled over
perfectly posed
out of reach
sipping from a hip flask
doing a keg stand
dehydrated
a little damp
stewing in its own juices
marinating overnight
sitting under a heat lamp
under scrutiny
rollerblading
getting a vitamin drip
squeezing lemons
dancing in the moonlight
dancing in the rain
feeling dried out
meditating
doomscrolling
checking instagram
logging off
with a cracked screen
with a thick accent
tightly wound
carved from a block of wood
getting reupholstered
leaning back
dancing
covered in paint
in a bath robe
in a nightgown
with a bouquet of flowers
under a pile of clothes
cast aside
at the bottom of a well
in despair
overcome with happiness
proud of itself
with incredible skin
blemish-free
dewy-faced
doe eyed
feeling betrayed
got dumped
caught in the rip current
pulled out to see
overeating
binge drinking
hedonistically indulging
sailing east
riding a dirtbike
landing a kickflip
getting its nails done
getting its hair done
getting its eyebrows tweezed
feeling discouraged
lazily napping
faking an orgasm
practically melting
is ready for a change
is burning bridges
is mending fences
is pissed off
is being gently caressed
all scratched up
is getting wasted
feeling blue
is all tuckered out
is over it
is sitting on its side
is draped in silk
is getting encased in resin
is becoming oxidized
being ignored
getting chilly
working through something

singing acapella
feeling itself
touching itself
rubbing its neck
smoking a joint
vaping
chewing nicotine gum
revealing a mean streak
declaring love
proposing marriage
in a situationship
casually dating
still single
rolling a spliff
with a dark sense of humor
with a proclivity for the absurd
painting its nails
waxing its legs
hurling insults
tipping generously
ordering a drink
receiving electrolysis
strutting its stuff
pulling itself together
hiking its skirt up
flipping through a magazine
snooping through drawers
counting money
softly weeping
running its fingers through its hair
lightly tapping
impatiently waiting
extremely bored
pooping
farting
breaking wind
passing gas
getting sick
feeling nauseous
overheated
struggling with insomnia
mining bitcoin
updating its website
ignoring its text messages
online shopping
committing tax fraud
looking for a roommate
uncrossing its legs
drinking a cold glass of milk
preparing matcha tea
dicing onions
holding back tears
weeping
losing control
having a moment
loving life
really likes it
at peace
at rest
held at gunpoint
under arrest
protesting the genocide
using nonviolent resistance
maintaining control
feeling so gross
learning how to whistle
dimming the lights
doing pilates
doing downward dog
sitting on a milk crate
thinking about its dog
seeking forgiveness
delivering a message
facing dire consequences
charging its phone
looking around
snooping
violently scratching itself
sanding furniture
looking for its underwear
dripping wet
getting a boner
horny
doesn't smell great
pissed off
receiving communion
getting circumcised
learning about plants
making an omelette
eating french fries
drinking a martini
dropped a plate of spaghetti
knocked over a bottle of wine
slowly rotating
spinning out of control
rolling around in an office chair
checking its email
not thinking about the news
missing its mother
needs a haircut
lashing out
acting up
being rude
wide awake
unsteady on a ladder
wearing chunky heels
stretching its legs
nodding off
getting therapy
getting a manicure
getting a pedicure
having an orgasm
sneezing
can't stop laughing
having a breakdown
wandering around
running its fingers through cool water
splashing water on its face
a little drunk
with a brutal headache
getting cramps
bleeding
all scuffed up
reflecting on the past
filled with dread
filled with regret
sucking up
lost an earbud
having fun
really happy
walking through wet grass
braiding its hair
under a lot of pressure
blowing smoke rings
wading through dirty water
looking for survivors
voting
keeping its mouth shut
still hungry
waiting
resting
drifting off
fell down the stairs
shifting its weight
vibrating with anticipation
moving slowly
shifting a ball of energy
balancing
sitting
standing still
trying not to be seen
not making a sound
wiping away tears
shuffling around
stacking coins
imagining a smooth wet stone
gently kayaking
speaking softly
whispering
trying to stay hidden
found bedbugs
listening to the dripping water
looking for its keys
looking for meaning
giving up hope
got laid off
listless
listening
in shambles
ripped to shreds
cut down
doing improv
feeling discouraged
can't handle it anymore
tried its best
couldn't cut it
brainstorming
jotting down ideas
drawing
painting with watercolors
throwing dinner together
eating leftovers
meal prepping
doing the dishes
scrubbing behind the toilet
flipping a house
opening a restaurant
finally gave up
agreed to an open marriage
cheating
going off
keeping a secret
embarrassed
cashing a check
shaking its hair out
putting its hair up
under the influence
coming out of the closet
waiting for the bus
needs some help
not over it
doing its thing
finding itself
losing touch with itself
doing the best it can
going through a breakup
being ignored
feeling unheard
all alone
lost the spark
feeling a little hopeful
starting to cry
getting emotional
putting on makeup
acting unprofessional
blowing massive vape clouds
killing time
sinking into snow
rock climbing
smoking crack
grinding weed
looking for a lighter
taking ecstasy
doing a line of ketamine
taking a bump of cocaine
getting sober
quit drinking
wearing a tracksuit
wearing a mini skirt
trying out a new hat
experimenting
disappointing itself
feeling nostalgic
overcome with guilt
struggling
thriving
strumming a guitar
got too high
took a huge bong hit
wearing incredible jeans
wearing overalls
in a new outfit
in its best clothes
wearing the same old clothes
hasn't changed at all
noticing what's changed
has never been
being interrogated
looking for trouble
stressed out
panicking
under a tight deadline
reminiscing
thinking too hard
trying to figure things out
plucking hairs
plugging in the aux cord
feeling old
picking up trash
giving up
under water
clutching the hand rail
nearly fainted
blacked out
completely wasted
nicely toasted
feeling groovy
wearing a bikini
wearing slacks
trying on shoes
putting on eyeshadow
shaving
stretching out
bent backwards
laying on the floor
feeling doubt
unsure
taking a knee
eavesdropping
pressed against the wall
moisturizing
sulking
getting wet
setting the table
folding laundry
learning spanish
speaking in tongues
hiding
picking up on signals
taking a hint
feeling tense
dropping acid
sipping coffee
popped an advil
changing its tampon
picking its underwear
eating boogers
sauteing mushrooms
broiling a flounder
grilling hot dogs
eating beans out of the can
desperate for affection
looking for attention
disrespected
arms akimbo
rapping
recording a podcast
listening to the rain
watching the sunset
got up early to watch the sunrise
bodysurfing
playing hookie
placing a bet
wearing streetwear
looking through a microscope
styling an outfit
doing a photoshoot
smoking
chugging warm beer
watching asmr
playing tetris
breaking the rules
afraid of getting in trouble
breaking convention
pushing the boundaries
ordering lunch
eating a bagel
craving something sweet
deserves a treat
grabbing a slice
making friends
going through a break up
rekindling an old fling
had a one night stand
looking for love
ready for a change
happy enough
doing ok
feeling good
snacking
binge eating
hungry
oversharing
wearing cargo pants
wearing cutoffs
topless
bottomless
shirtless
naked
half-naked
worn out
drinking wine
flirting
wearing
smiling
unclogging a toilet
pulling hair out of the drain
frowning
crying
giggling
chatting
doing a cold plunge
talking shit
taking the train
taking out the trash
going to the bathroom
getting fingered
sucking dick
chewing gum
squinting
thirsty
lurking
dancing to house music
disassociating
journaling
preparing for surgery
getting worked up
getting yelled at
being tricked
wearing yoga pants
treating a burn
treading water
tending to a wound
kicking back
hanging out
loitering
staying late
up all night
getting hired
getting a promotion
being praised
getting dismissed
getting talked down to
getting cursed out
getting a perm
picking apples
running through water
jogging
running on a treadmill
skipping
climbing over the fence
cutting the cord
curled up
giving birth
working retail
getting picked on
being cyber bullied
roasting in the sun
all sticky
delivering a baby
ripening on the kitchen counter
squealing with delight
writhing in pain
celebrating the holidays
blowing out candles
can't hit the pinata
picking through the bulk bins
acting tough
plucking a harp
shaking maracas
scratching off a lottery ticket
playing powerball
buying a raffle ticket
being held accountable
facing the music
lightly casting a bedsheet across its bare mattress
eating alone
catching up with an old friend
left behind
looked upon fondly
beloved by everybody
thinking about giving up
better off alone
happy this way
feeling satisfied
unpacking boxes
looking for a hole in the air mattress
swapping out the air freshener on its rear view mirror
traveling with friends
fighting
tidying up
decluttering
dusting
with its eyes closed
smiling politely
being very theatrical
virtue signaling
spewing bullshit
clearly lying
telling the truth
unable to lie
learning a magic trick
feeling homesick
`);

/* location */
const LOCATIONS = vocabLines(`
in the bedroom
in the kitchen
in the bathroom
in the attic
on the balcony
in the basement
in the backyard
in the driveway
in the apartment
in a spare bedroom
in a long-unused childhood bedroom
in a steamy bathroom
on a balcony chair
in the living room
in the dining room
in a home office
in a craft room
in a pantry
in a soaking tub
in the office
in a cubicle
in a shoemaker's workshop
in the studio
in the lecture hall
in the waiting room
in the doctor's office
in the library
in a tv studio
in a corner office
in an open-plan office
in a ceramics studio
on a construction site
inside a movie studio
on a soundstage
inside a display case
by a printing press
at the beach
on the pier
in the swimming pool
on the sidewalk
sitting in a diner booth
at a dive bar
at the club
at a rave
at an open mic night
by the fire pit
at the farm stand
at the hardware store
on the trail
on a dirt road
at the trailhead
in the amusement park
in the arcade
in an airport lounge
at a rooftop bar
at a bus stop at dusk
on an empty train platform
at a foggy ferry terminal
stuck to the floor of a movie theater
at an art house theater
at a record store
at a used book store
at a department store
in a food court
inside a vacant motel
in a high-rise apartment building
at the top of the bleachers
buried in a shallow grave
in a cemetery
on a basketball court
on a tennis court
on a golf course
at a pumpkin patch
in a pet store
at a strip mall
at an outlet mall
while walking the runway show
in a cafeteria
in a city center
on the outskirts of town
at a beauty pageant
under the overpass
in the parking garage
in the parking lot
at the waterfront
by the water tower
in the alleyway
in a bog
at the catacombs
at the garbage dump
in an off-season seaside town
on an empty boardwalk
among folded deck chairs
outside a closed movie theater
in an empty museum gallery
in an obsolete shopping mall
in back stairwells
beneath a flickering neon sign
on stone steps
on cobblestone
near a courtyard fountain
under overgrown vines
in a vineyard
in a railroad dining car
in the back seat of a car
in the passenger seat of a car
in the driver's seat
in a walk-in freezer
in a breakfast nook
in a dressing room
in a wine bar
in a karaoke bar
in a bank vault
in a root cellar
in a wine cellar
in the trunk of a car
inside an overhead bin
in an airplane
in an airport
in a theme park
in a haunted house
in a renovated tenement building
at an amphitheater
at the acropolis
on a suspension bridge
at a dude ranch
at a rodeo
inside an automotive plant
in a med spa
in a day spa
in a steam room
on the casino floor
at a poker table
in a clown car
in a dune buggy
inside a black box theater
in an improv class
in gym class
in english class
at a book club
in an italian restaurant
in the mall of america
at the world trade center
at the eiffel tower
at the great wall of china
in times square
in soho
in dimes square
in williamsburg
in greenpoint
in bushwick
in a dorm room
at the foot of the bed
at a strip club
at a gay bar
on the upper east side
in chicago
at madison square garden
on the waterfront in portugal
in the south of france
among rolling hills
in tall grasses
on a mowed lawn
in carnegie hall
hanging out
in a loft space
at a pawn shop
at the bottom of a lake
at a beachfront bonfire
on the last day of school
while riding on the back of a horse

in a lady footlocker
on vacation
while lost in a wheat field
in bed
on the couch
lying in a hammock
face down in the mud
in a kitschy dive bar
in a rustic fishing village
near the old gas station
on the other side of town
in a sketchy town upstate
in the fiery pits hell
at the top of a ladder
in the penthouse
in an unfinished basement
at a construction site
in a cvs
in a walkable neighborhood
in a cramped studio apartment
in line at the pharmacy
in line for the bathroom
in solitary confinement
on a game show
on a tv show
in detention
while stuck in an airport
under the bed
frozen in a block of ice
while trapped underwater
up in a tree
with feet in the sand
in a saltwater pool
in an unlit attic
in a darkened movie theater
near the dollar store
across the street from an abandoned church
in a dingy bowling alley
under red lights
under a disco ball
on a bean bag chair
on a corduroy love seat
in an unpleasant post-modern apartment
on a first date
on a second date
on a third date
during its own wedding
while testifying in court
in the pelapenese
in a tourist trap
on the dance floor
while enveloped by a fog machine
skimming the headlines
in a cozy brownstone apartment
in a punk house
at a silent retreat
on the yucatan peninsula
on an artist's residency
in a writing workshop
in an unfinished housing development
within a sinister gated community
behind barbed wire fencing
locked in the trunk of a car
while being held hostage
inside a cramped submarine
in a same-sex relationship
in a polyamorous relationship
in a cul-de-sac
in the shadow of a mountain
at the campgrounds
at the top of a cherry picker
while trapped in an elevator
`);

/* ========================================================== */

function pickDescriptorObject(){ return bagNext("desc:object", DESC_OBJECT); }
function pickDescriptorPerson(){ return bagNext("desc:person", DESC_PERSON); }
function pickDescriptorMixed(){ return bagNext("desc:mixed", DESC_OBJECT.concat(DESC_PERSON)); }
function pickDescriptor(useObj, usePerson){
  if(usePerson) return pickDescriptorPerson();
  if(useObj) return pickDescriptorObject();
  return pickDescriptorMixed();
}
function pickObject(){ return bagNext("obj", OBJECTS); }
function pickPerson(){ return bagNext("person", PERSONS); }
function pickAction(){ return bagNext("act", ACTIONS); }
function pickLocation(){ return bagNext("loc", LOCATIONS); }

/* ================= Phrase build ================= */
function safeStr(x){ return (x == null) ? "" : String(x).trim(); }
function formatPhraseText(p){
  if(clamp(Number(widthEl.value), 0, 100) === 0){
    return p.split(/\s+/).join("<br>");
  }
  return p;
}

function swapItPronounsForPerson(actionStr){
  let s = String(actionStr || "");
  if(!s) return s;

  // If a vocab line accidentally includes "it's" (possessive typo), treat it like "its"
  // so pronoun swapping still works.
  s = s.replace(/\bit[’']s\b/g, "its");

  const female = Math.random() < 0.5;
  const map = female
    ? { it: "she", its: "her", itself: "herself" }
    : { it: "he", its: "his", itself: "himself" };

  // Avoid matching inside contractions like "it's".
  return s.replace(/\b(itself|its|it)\b(?!')/g, (m)=> map[m] || m);
}

/* ================= Phrase non-repeat (persists across reloads) ================= */
// Keep a long memory so exact repeats stay rare even across days.
// Stored in localStorage; keep this large but not huge.
const RECENT_PHRASES_MAX = 6000;
const RECENT_PHRASES_KEY = "sculpture_poems_recent_phrases_v1";
let recentPhraseQueue = [];
let recentPhraseSet = new Set();
let recentPhraseSaveTimer = null;

function loadRecentPhrases(){
  try{
    const raw = localStorage.getItem(RECENT_PHRASES_KEY);
    if(!raw) return;
    const arr = JSON.parse(raw);
    if(!Array.isArray(arr)) return;
    const clean = arr.map(x => String(x || "").trim()).filter(Boolean);
    recentPhraseQueue = clean.slice(-RECENT_PHRASES_MAX);
    recentPhraseSet = new Set(recentPhraseQueue);
  }catch(e){}
}

function scheduleSaveRecentPhrases(){
  if(recentPhraseSaveTimer) return;
  recentPhraseSaveTimer = window.setTimeout(()=>{
    recentPhraseSaveTimer = null;
    try{
      localStorage.setItem(
        RECENT_PHRASES_KEY,
        JSON.stringify(recentPhraseQueue.slice(-RECENT_PHRASES_MAX))
      );
    }catch(e){}
  }, 1200);
}

function rememberRecentPhrase(p){
  const s = String(p || "").trim();
  if(!s) return;
  recentPhraseQueue.push(s);
  recentPhraseSet.add(s);
  while(recentPhraseQueue.length > RECENT_PHRASES_MAX){
    const old = recentPhraseQueue.shift();
    recentPhraseSet.delete(old);
  }
  scheduleSaveRecentPhrases();
}

function buildPhrase(partsSet){
  const useDesc = partsSet.has("description");
  const useObj  = partsSet.has("object");
  const usePerson = partsSet.has("person") && !useObj;
  const useAct  = partsSet.has("action");
  const useLoc  = partsSet.has("location");
  if(!useDesc && !useObj && !usePerson && !useAct && !useLoc) return "";

  let lastOut = "";
  const MAX_TRIES = 600;

  for(let tries=0; tries<MAX_TRIES; tries++){
    const desc = useDesc ? safeStr(pickDescriptor(useObj, usePerson)) : "";
    const obj  = useObj ? safeStr(pickObject()) : "";
    const person = usePerson ? safeStr(pickPerson()) : "";
    let act  = useAct ? safeStr(pickAction()) : "";
    let loc  = useLoc ? safeStr(pickLocation()) : "";

    // If "object" isn't present in the sentence (person is on OR both person+object are off),
    // treat "it/its/itself" anywhere in the phrase like a person pronoun swap.
    if(!useObj){
      if(useAct && act) act = swapItPronounsForPerson(act);
      if(useLoc && loc) loc = swapItPronounsForPerson(loc);
    }

    let out = "";
    if(useDesc && desc) out += desc + " ";
    if(useObj && obj) out += obj;
    if(usePerson && person) out += person;
    if(useAct && act) out += (out ? " " : "") + act;
    if(useLoc && loc) out += (out ? " " : "") + loc;

    out = out.replace(/\s+/g," ").trim();
    if(!out) continue;
    lastOut = out;

    if(!recentPhraseSet.has(out)){
      rememberRecentPhrase(out);
      return out;
    }
  }

  if(lastOut) rememberRecentPhrase(lastOut);
  return lastOut;
}

/* ================= Color selection ================= */
function unionColorsFrom(selectedPaletteNames){
  // Sort so the color pool order is stable even if a Set's insertion order changes,
  // which prevents the shuffle bag from resetting and causing early repeats.
  const names = Array.from(selectedPaletteNames).sort();
  let out = [];
  for(const n of names){
    const pal = PAL[n];
    if(pal && pal.length) out = out.concat(pal);
  }
  return uniq(out);
}

function pickColorNonRepeating(key, paletteSet, excludeHexSet){
  const pool = unionColorsFrom(paletteSet);
  const allPool = uniq(Object.values(PAL).flat());
  const basePool = pool.length ? pool : allPool;
  const avoid = new Set((excludeHexSet ? Array.from(excludeHexSet) : []).map(normHex));
  if(!avoid.size) return bagNext(key, basePool);

  // Important: we always draw from the same (stable) pool for this key so the shuffle bag
  // can complete a full cycle before repeating. If a draw hits an avoided color, we consume
  // it and keep going (so it can come back after the bag resets).
  const maxTries = Math.max(1, basePool.length);
  for(let i=0; i<maxTries; i++){
    const c = bagNext(key, basePool);
    if(!avoid.has(normHex(c))) return c;
  }
  // If everything is avoided, just return the next color anyway.
  return bagNext(key, basePool);
}

function consumeColorFromBag(key, paletteSet, targetHex){
  const pool = unionColorsFrom(paletteSet);
  const allPool = uniq(Object.values(PAL).flat());
  const basePool = pool.length ? pool : allPool;
  for(let i=0; i<basePool.length; i++){
    const c = bagNext(key, basePool);
    if(c === targetHex) return c;
  }
  return targetHex;
}

/* ================= Current frame ================= */
const current = {
  phrase: "",
  bgBase: "#F7C6D0",
  fgBase: "#231423",
  bdBase: "#231423"
};

const last = { phrase:"", bg:"", fg:"", bd:"" };
let timerId = null;
let isFirstFrame = true;
let isPaused = false;
let isCompositionLocked = false;

/* ================= Playback history ================= */
const HISTORY_MAX = 1000;
const sceneHistory = [];
let sceneIndex = -1;

function snapshotScene(){
  const palSnap = {};
  for(const name of COLOR_OPTS){
    palSnap[name] = palCycleIndex[name] ?? 0;
  }
  return {
    phrase: current.phrase,
    bgBase: current.bgBase,
    fgBase: current.fgBase,
    bdBase: current.bdBase,
    palCycleIndex: palSnap
  };
}

function syncHistoryButtons(){
  if(prevPoemBtn) prevPoemBtn.disabled = sceneIndex <= 0;
}

function restoreSceneAt(index){
  if(index < 0 || index >= sceneHistory.length) return;
  const sc = sceneHistory[index];
  sceneIndex = index;

  current.phrase = String(sc.phrase || "");
  current.bgBase = String(sc.bgBase || current.bgBase);
  current.fgBase = String(sc.fgBase || current.fgBase);
  current.bdBase = String(sc.bdBase || current.bdBase);

  if(sc.palCycleIndex){
    for(const name of COLOR_OPTS){
      if(sc.palCycleIndex[name] != null) palCycleIndex[name] = sc.palCycleIndex[name];
    }
  }

  phraseEl.innerHTML = formatPhraseText(current.phrase);
  smartPhraseWidth();
  applyColorsLive();
  syncHistoryButtons();
}

function commitGeneratedScene(){
  const sc = snapshotScene();

  if(sceneIndex >= 0 && sceneIndex < sceneHistory.length - 1){
    sceneHistory.splice(sceneIndex + 1);
  }

  sceneHistory.push(sc);
  sceneIndex = sceneHistory.length - 1;

  if(sceneHistory.length > HISTORY_MAX){
    const drop = sceneHistory.length - HISTORY_MAX;
    sceneHistory.splice(0, drop);
    sceneIndex = Math.max(0, sceneIndex - drop);
  }

  syncHistoryButtons();
}

function syncPauseBtn(){
  if(!pausePoemBtn) return;
  pausePoemBtn.classList.toggle("paused", isPaused);
  pausePoemBtn.setAttribute("aria-pressed", isPaused ? "true" : "false");
  pausePoemBtn.setAttribute("aria-label", isPaused ? "Play (Space)" : "Pause (Space)");
  pausePoemBtn.dataset.tip = isPaused ? "play" : "pause";
}

function setPaused(paused){
  const next = !!paused;
  if(isPaused === next) return;
  isPaused = next;
  syncPauseBtn();
  if(isPaused){
    if(timerId) clearTimeout(timerId);
    timerId = null;
    return;
  }
  scheduleTick();
}

function togglePaused(){
  setPaused(!isPaused);
}

function syncCompositionLockBtn(){
  if(!lockCompositionBtn) return;
  lockCompositionBtn.classList.toggle("locked", isCompositionLocked);
  lockCompositionBtn.classList.toggle("on", isCompositionLocked);
  lockCompositionBtn.setAttribute("aria-pressed", isCompositionLocked ? "true" : "false");
  lockCompositionBtn.setAttribute("aria-label", isCompositionLocked ? "Unlock composition" : "Lock composition");
  lockCompositionBtn.dataset.tip = isCompositionLocked ? "unlock composition" : "lock composition";
}
function toggleCompositionLock(){
  isCompositionLocked = !isCompositionLocked;
  syncCompositionLockBtn();
}

function goPrevPoem(){
  if(sceneIndex <= 0) return;
  setPaused(true);
  restoreSceneAt(sceneIndex - 1);
}

function goNextPoem(){
  setPaused(true);
  if(sceneIndex < sceneHistory.length - 1){
    restoreSceneAt(sceneIndex + 1);
    return;
  }
  // At the end: generate a new one (manual step-forward).
  nextFrame();
}

function setCalmStart(){
  const palName = COLOR_OPTS[Math.floor(Math.random() * COLOR_OPTS.length)];
  const bg = lightestHexFromPalette(palName);
  const fg = darkestHexFromPalette(palName);
  current.bgBase = consumeColorFromBag("bg", sel.bgColor, bg);
  current.fgBase = consumeColorFromBag("fg", sel.fgColor, fg);
  current.bdBase = consumeColorFromBag("bd", sel.bdColor, fg);
}

/* ================= UI builders ================= */
function renderSentenceButtons(){
  const container = document.getElementById("partsRow");
  container.innerHTML = "";
  let stickyLabel = "";

  function setPartsHoverText(t){
    if(!partsHover) return;
    if(t){
      partsHover.textContent = String(t).toLowerCase();
    }else{
      partsHover.innerHTML = "&nbsp;";
    }
  }

  const partToPal = {
    description: "earthy",
    object: "circus",
    // Person shares the "slot" with object; keep it in the same palette unless you want it distinct.
    person: "circus",
    action: "future",
    location: "retro"
  };

  for(const opt of PART_OPTS){
    const b = document.createElement("button");
    b.type = "button";
    b.className = "ssBtn";
    b.textContent = opt;

    const palName = partToPal[opt];
    const bg = paletteColorAvoid(palName, 0, getBgLiveHex());
    b.style.setProperty("--ssPal", palName);
    b.style.setProperty("--ssBg", bg);

    if(sel.parts.has(opt)) b.classList.add("on");

    b.addEventListener("click", ()=>{
      const isObjOrPerson = (opt === "object" || opt === "person");
      const enabling = !sel.parts.has(opt);
      if(isObjOrPerson && enabling){
        // Mutually exclusive: you can enable either object or person, but never both.
        if(opt === "object") sel.parts.delete("person");
        if(opt === "person") sel.parts.delete("object");
      }

      if(sel.parts.has(opt)) sel.parts.delete(opt); else sel.parts.add(opt);
      if(sel.parts.size === 0) sel.parts.add(opt);

      Array.from(container.children).forEach(btn=>{
        const name = btn.textContent;
        btn.classList.toggle("on", sel.parts.has(name));
      });

      stickyLabel = sel.parts.has(opt) ? "on" : "off";
      setPartsHoverText(stickyLabel);
    });

    container.appendChild(b);
  }

  container.addEventListener("mouseover", (e)=>{
    const btn = e.target.closest(".ssBtn");
    if(!btn) return;
    const name = btn.textContent;
    if(!name) return;
    // Show the action (what clicking will do).
    setPartsHoverText(sel.parts.has(name) ? "off" : "on");
  });
  container.addEventListener("mouseleave", ()=>{
    setPartsHoverText(stickyLabel);
  });
}

function refreshSentenceButtonColors(){
  const bgAvoid = getBgLiveHex();
  document.querySelectorAll("#partsRow .ssBtn").forEach(btn=>{
    const pal = btn.style.getPropertyValue("--ssPal").trim() || "earthy";
    btn.style.setProperty("--ssBg", paletteColorAvoid(pal, 0, bgAvoid));
  });
}

function palettePair(name, offset=0){
  const pal = PAL[name] || [];
  if(!pal.length) return { fill: "#999999", ring: "#cccccc" };
  const bgAvoid = getBgLiveHex();
  const fill = paletteColorAvoid(name, offset, bgAvoid);
  const ring = paletteColorAvoid(name, offset + 2, bgAvoid);
  return { fill, ring };
}

function renderSwatchRow(rowEl, hoverEl, setRef, rowKey){
  rowEl.innerHTML = "";
  if(rowKey) rowEl.dataset.row = rowKey;
  let stickyLabel = "";

  function setHoverText(t){
    if(t){
      hoverEl.textContent = String(t).toLowerCase();
    }else{
      hoverEl.innerHTML = "&nbsp;";
    }
  }

  for(const name of COLOR_OPTS){
    const offset = swatchRowOffset[rowKey] || 0;
    const {fill, ring} = palettePair(name, offset);
    const sw = document.createElement("button");
    sw.type = "button";
    sw.className = "swatch" + (setRef.has(name) ? " on" : "");
    sw.dataset.name = name;
    sw.style.setProperty("--fillCol", fill);
    sw.style.setProperty("--ringCol", ring);

    sw.addEventListener("click", ()=>{
      if(setRef.has(name)) setRef.delete(name); else setRef.add(name);
      if(setRef.size === 0) setRef.add(name);

      Array.from(rowEl.querySelectorAll(".swatch")).forEach(btn=>{
        btn.classList.toggle("on", setRef.has(btn.dataset.name));
      });

      const nowOn = setRef.has(name);
      stickyLabel = `${name} ${nowOn ? "on" : "off"}`;
      setHoverText(stickyLabel);
    });

    rowEl.appendChild(sw);
  }

  rowEl.addEventListener("mouseover", (e)=>{
    const sw = e.target.closest(".swatch");
    if(!sw) return;
    setHoverText(sw.dataset.name || "");
  });
  rowEl.addEventListener("mouseleave", ()=>{
    setHoverText(stickyLabel);
  });
}

function refreshSwatchColors(){
  document.querySelectorAll(".swatch").forEach(sw=>{
    const name = sw.dataset.name;
    const row = sw.closest(".swatchRow")?.dataset.row || "bg";
    const offset = swatchRowOffset[row] || 0;
    const {fill, ring} = palettePair(name, offset);
    sw.style.setProperty("--fillCol", fill);
    sw.style.setProperty("--ringCol", ring);
  });
}

function applyButtonColors(){
  const bgAvoid = getBgLiveHex();

  // Card + fullscreen buttons
  if(bdToggleBtn) bdToggleBtn.style.setProperty("--btnBg", paletteColorAvoid("circus", 0, bgAvoid));
  if(fsBtn) fsBtn.style.setProperty("--btnBg", paletteColorAvoid("fleshy", 1, bgAvoid));

  // Playback buttons (3 different palettes chosen on init)
  if(prevPoemBtn) prevPoemBtn.style.setProperty("--btnBg", paletteColorAvoid(titleCtrlTheme.prev, 0, bgAvoid));
  if(pausePoemBtn) pausePoemBtn.style.setProperty("--btnBg", paletteColorAvoid(titleCtrlTheme.pause, 0, bgAvoid));
  if(nextPoemBtn) nextPoemBtn.style.setProperty("--btnBg", paletteColorAvoid(titleCtrlTheme.next, 0, bgAvoid));
}

function syncSwatchHeaderWidths(){
  requestAnimationFrame(()=>{
    document.querySelectorAll(".swatchRow").forEach(row=>{
      const header = row.parentElement.querySelector(".swatchHeader");
      if(!header) return;
      const w = row.getBoundingClientRect().width;
      header.style.width = w > 0 ? `${w}px` : "auto";
      header.style.marginLeft = "auto";
      header.style.marginRight = "auto";
      row.style.marginLeft = "auto";
      row.style.marginRight = "auto";
    });
  });
}

function applySliderThumbColors(){
  sliderEls.forEach((el, i)=>{
    const palName = SLIDER_PALS[i % SLIDER_PALS.length];
    const pal = PAL[palName] || [];
    const offset = pal.length ? (i % pal.length) : 0;
    const col = paletteColor(palName, offset);
    el.style.setProperty("--thumbCol", col);
  });
}

function syncActionButtonWidths(){
  requestAnimationFrame(()=>{
    const btnW1 = bdToggleBtn ? bdToggleBtn.getBoundingClientRect().width : 0;
    const btnW2 = fsBtn ? fsBtn.getBoundingClientRect().width : 0;

    const grp1 = bdToggleBtn ? bdToggleBtn.closest(".actionGroup") : null;
    const grp2 = fsBtn ? fsBtn.closest(".actionGroup") : null;
    const lbl1 = grp1 ? grp1.querySelector(".actionText") : null;
    const lbl2 = grp2 ? grp2.querySelector(".actionText") : null;
    const lblW1 = lbl1 ? Math.max(lbl1.scrollWidth || 0, lbl1.getBoundingClientRect().width || 0) : 0;
    const lblW2 = lbl2 ? Math.max(lbl2.scrollWidth || 0, lbl2.getBoundingClientRect().width || 0) : 0;

    const w = Math.ceil(Math.max(btnW1, btnW2, lblW1, lblW2) + 6); // small buffer to avoid clipping
    if(w > 0){
      if(bdToggleBtn) bdToggleBtn.style.width = `${w}px`;
      if(fsBtn) fsBtn.style.width = `${w}px`;
      if(grp1) grp1.style.width = `${w}px`;
      if(grp2) grp2.style.width = `${w}px`;
    }
  });
}

function applyAccentColors(){
  refreshSwatchColors();
  refreshSentenceButtonColors();
  applySliderThumbColors();
  applyButtonColors();
}

/* ================= Type + layout ================= */
function applyTypeAndLayout(){
  const sizePct = clamp(Number(sizeEl.value), 0, 150);
  let scale = 0.02;
  if(sizePct > 0 && sizePct <= 100){
    scale = 0.02 + (1.6 - 0.02) * (sizePct / 100);
  }else if(sizePct > 100){
    scale = 1.6 + (3.5 - 1.6) * ((sizePct - 100) / 50);
  }
  document.documentElement.style.setProperty("--textScale", scale);
  sizeVal.textContent = `${Math.round(sizePct)}%`;

  const y = clamp(Number(yEl.value), 0, 100);
  document.documentElement.style.setProperty("--yPct", `${y}%`);
  yVal.textContent = `${Math.round(y)}%`;

  const w = clamp(Number(widthEl.value), 0, 100);
  widthVal.textContent = `${Math.round(w)}%`;

  smartPhraseWidth();
}

function phraseInkRects(){
  try{
    const r = document.createRange();
    r.selectNodeContents(phraseEl);
    return Array.from(r.getClientRects()).filter(x => x.width > 0 && x.height > 0);
  }catch(e){
    return [];
  }
}
function phraseInkBounds(){
  const rects = phraseInkRects();
  if(!rects.length) return null;
  let left = Infinity, right = -Infinity, top = Infinity, bottom = -Infinity;
  for(const r of rects){
    left = Math.min(left, r.left);
    right = Math.max(right, r.right);
    top = Math.min(top, r.top);
    bottom = Math.max(bottom, r.bottom);
  }
  if(!Number.isFinite(left) || !Number.isFinite(right) || !Number.isFinite(top) || !Number.isFinite(bottom)) return null;
  return { left, right, top, bottom, width: right - left, height: bottom - top };
}

function fitPhraseToBox(){
  const sizePct = clamp(Number(sizeEl.value), 0, 150);
  if(sizePct <= 0){
    document.documentElement.style.setProperty("--fitScale", "1");
    applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
    return;
  }
  if(sizePct >= 150){
    document.documentElement.style.setProperty("--fitScale", "1");
    applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
    return;
  }
  const text = (phraseEl.textContent || "").trim();
  if(!text){
    document.documentElement.style.setProperty("--fitScale", "1");
    applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
    return;
  }

  document.documentElement.style.setProperty("--fitScale", "1");
  const rect = phraseInkBounds() || phraseEl.getBoundingClientRect();
  if(rect.width <= 0 || rect.height <= 0){
    document.documentElement.style.setProperty("--fitScale", "1");
    applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
    return;
  }

  const { w: vw, h: vh } = getViewportSize();
  const edgePad = getRootVarPx("--edgePad");
  const wVar = getRootVarVw("--phraseW");
  const widthPct = (wVar ? wVar : clamp(Number(widthEl.value), 1, 100)) / 100;

  const maxW = Math.min(vw * widthPct, vw - (edgePad * 2));
  const maxH = vh - (edgePad * 2);

  let scale = Math.min(maxW / rect.width, maxH / rect.height, 1);
  if(!Number.isFinite(scale) || scale <= 0) scale = 1;
  scale = clamp(scale, 0.01, 1);

  document.documentElement.style.setProperty("--fitScale", scale.toFixed(3));
  applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
}

function widenPhraseToAvoidOverfullLines(){
  // If a line is "overfull" (a word is wider than the box), browsers fall back to start-alignment
  // and our card bounds can be wrong. Clamp the box to at least the scroll width to keep it centered.
  const { w: vw } = getViewportSize();
  if(vw <= 0) return;

  // A couple passes handles cases where max-width / edge padding clamps the first widening attempt.
  for(let i=0; i<2; i++){
    const boxW = phraseEl.getBoundingClientRect().width;
    if(boxW <= 0) return;

    const scrollW = phraseEl.scrollWidth || 0;
    if(scrollW <= boxW + 0.5) return;

    const needVw = clamp(((scrollW + 2) / vw) * 100, 1, 100);
    const curVw = getRootVarVw("--phraseW") ?? clamp(Number(widthEl.value), 1, 100);
    const nextVw = clamp(Math.max(curVw, needVw), 1, 100);

    document.documentElement.style.setProperty("--phraseW", `${nextVw.toFixed(2)}vw`);
    if(nextVw >= 100){
      document.documentElement.style.setProperty("--edgePad", "0px");
      return;
    }
  }

  // If we're still overfull, the edge padding is clamping max-width; drop it.
  const boxW = phraseEl.getBoundingClientRect().width;
  const scrollW = phraseEl.scrollWidth || 0;
  if(scrollW > boxW + 0.5){
    document.documentElement.style.setProperty("--edgePad", "0px");
    document.documentElement.style.setProperty("--phraseW", "100vw");
  }
}

function smartPhraseWidth(){
  const base = clamp(Number(widthEl.value), 0, 100);
  if(base === 0){
    document.documentElement.style.setProperty("--phraseW", "100vw");
    phraseEl.classList.add("oneWord");
    document.documentElement.style.setProperty("--edgePad", "0px");
    fitPhraseToBox();
    return;
  }
  phraseEl.classList.remove("oneWord");
  document.documentElement.style.setProperty("--phraseW", `${base}vw`);
  document.documentElement.style.setProperty("--edgePad", base >= 100 ? "0px" : "50px");
  document.documentElement.style.setProperty("--fitScale", "1");
  widenPhraseToAvoidOverfullLines();

  const text = (phraseEl.textContent || "").trim();
  if(!text){
    fitPhraseToBox();
    return;
  }

  // Don't auto-widen very small widths (it causes jitter / flicker).
  if(base < 25){
    fitPhraseToBox();
    return;
  }

  const rects = phraseInkRects();
  if(!rects.length){
    fitPhraseToBox();
    return;
  }
  const last = rects[rects.length - 1];
  const maxW = Math.max(1, ...rects.map(r=>r.width));
  const ratio = last.width / maxW;
  if(ratio >= 0.40 || rects.length < 2){
    fitPhraseToBox();
    return;
  }

  const maxExtra = 10;
  let w = base;
  for(let i=1; i<=maxExtra; i++){
    w = Math.min(base + i, 100);
    document.documentElement.style.setProperty("--phraseW", `${w}vw`);
    const rectsNow = phraseInkRects();
    if(!rectsNow.length) break;
    const lastNow = rectsNow[rectsNow.length - 1];
    const maxWNow = Math.max(1, ...rectsNow.map(r=>r.width));
    const ratioNow = lastNow.width / maxWNow;
    if(ratioNow >= 0.40) break;
  }
  fitPhraseToBox();
}

function groupClientRectsIntoLines(rects){
  const out = [];
  const sorted = rects.slice().sort((a,b)=> (a.top - b.top) || (a.left - b.left));
  const EPS = 2.0;
  for(const r of sorted){
    let line = null;
    for(const l of out){
      if(Math.abs(l.top - r.top) <= EPS){
        line = l;
        break;
      }
    }
    if(!line){
      out.push({ top: r.top, bottom: r.bottom, left: r.left, right: r.right });
    }else{
      line.top = Math.min(line.top, r.top);
      line.bottom = Math.max(line.bottom, r.bottom);
      line.left = Math.min(line.left, r.left);
      line.right = Math.max(line.right, r.right);
    }
  }
  return out
    .sort((a,b)=> a.top - b.top)
    .map(l => ({
      top: l.top,
      bottom: l.bottom,
      left: l.left,
      width: l.right - l.left,
      height: l.bottom - l.top
    }));
}

function getRenderedLinesForScreenshot(){
  const raw = String(phraseEl.textContent || "").replace(/\r/g, "");
  const text = raw.replace(/\s+/g, " ").trim();
  if(!text) return [];

  // "one word per line" mode
  if(clamp(Number(widthEl.value), 0, 100) === 0){
    return text.split(/\s+/).filter(Boolean);
  }

  // If the DOM contains <br> for any reason, trust it.
  if(phraseEl.querySelector("br")){
    return String(phraseEl.innerText || "")
      .replace(/\r/g, "")
      .split("\n")
      .map(s => s.trim())
      .filter(Boolean);
  }

  // Normal mode is a single text node (we set innerHTML to plain text).
  const node = phraseEl.firstChild;
  if(!node || node.nodeType !== Node.TEXT_NODE){
    return [text];
  }

  const words = [];
  const re = /\S+/g;
  let m;
  while((m = re.exec(node.data))){
    words.push({ word: m[0], start: m.index, end: m.index + m[0].length });
  }
  if(!words.length) return [text];

  const lines = [];
  const range = document.createRange();
  const EPS = 2.0;
  let curTop = null;
  let cur = [];

  for(const w of words){
    range.setStart(node, w.start);
    range.setEnd(node, w.end);
    const r = range.getBoundingClientRect();
    if(!r || r.width <= 0 || r.height <= 0) continue;
    if(curTop == null){
      curTop = r.top;
      cur.push(w.word);
      continue;
    }
    if(Math.abs(r.top - curTop) <= EPS){
      cur.push(w.word);
    }else{
      if(cur.length) lines.push(cur.join(" "));
      cur = [w.word];
      curTop = r.top;
    }
  }
  if(cur.length) lines.push(cur.join(" "));

  return lines.length ? lines : [text];
}

function takeScreenshot(){
  try{
    const { w: vw, h: vh } = getViewportSize();
    const dpr = Math.max(1, Math.round((window.devicePixelRatio || 1) * 100) / 100);

    const canvas = document.createElement("canvas");
    canvas.width = Math.max(1, Math.round(vw * dpr));
    canvas.height = Math.max(1, Math.round(vh * dpr));
    const ctx = canvas.getContext("2d");
    if(!ctx) return;
    ctx.scale(dpr, dpr);

    // Background
    ctx.fillStyle = getComputedStyle(document.body).backgroundColor || "#ffffff";
    ctx.fillRect(0, 0, vw, vh);

    // Card (if enabled)
    if(sel.borderEnabled && getComputedStyle(cardEl).display !== "none"){
      const r = cardEl.getBoundingClientRect();
      if(r.width > 0 && r.height > 0){
        ctx.fillStyle = getComputedStyle(cardEl).backgroundColor || "transparent";
        ctx.fillRect(r.left, r.top, r.width, r.height);
      }
    }

    // Text
    const lines = getRenderedLinesForScreenshot();
    if(lines.length){
      const cs = getComputedStyle(phraseEl);
      const fontSize = cs.fontSize || "48px";
      const fontWeight = cs.fontWeight || "600";
      const fontFamily = cs.fontFamily || "serif";
      const lineHeightPx = parseFloat(cs.lineHeight) || (parseFloat(fontSize) * 1.12);
      ctx.font = `${fontWeight} ${fontSize} ${fontFamily}`;
      ctx.fillStyle = cs.color || "#000000";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";

      const lineRects = groupClientRectsIntoLines(phraseInkRects());
      const n = Math.min(lines.length, lineRects.length);

      if(n > 0){
        for(let i=0; i<n; i++){
          const line = lines[i];
          const r = lineRects[i];
          ctx.fillText(line, r.left + (r.width / 2), r.top);
        }
        if(lines.length > n){
          const last = lineRects[lineRects.length - 1];
          const startY = (last ? last.bottom : (phraseEl.getBoundingClientRect().top));
          for(let i=n; i<lines.length; i++){
            ctx.fillText(lines[i], vw / 2, startY + ((i - n) * lineHeightPx));
          }
        }
      }else{
        const r = phraseEl.getBoundingClientRect();
        for(let i=0; i<lines.length; i++){
          ctx.fillText(lines[i], vw / 2, r.top + (i * lineHeightPx));
        }
      }
    }

    canvas.toBlob((blob)=>{
      if(!blob) return;
      const now = new Date();
      const dateStamp = `${now.getMonth() + 1}.${now.getDate()}.${now.getFullYear()}`;
      const pad2 = (n)=> String(n).padStart(2, "0");
      const dayKey = `${now.getFullYear()}-${pad2(now.getMonth() + 1)}-${pad2(now.getDate())}`;

      let n = 1;
      try{
        const k = `sculpture_poems_screenshot_counter_${dayKey}`;
        const prev = Math.floor(Number(localStorage.getItem(k) || "0"));
        n = (Number.isFinite(prev) && prev >= 0) ? (prev + 1) : 1;
        localStorage.setItem(k, String(n));
      }catch(e){
        window.__sculpturePoemsScreenshotN = (window.__sculpturePoemsScreenshotN || 0) + 1;
        n = window.__sculpturePoemsScreenshotN;
      }

      const a = document.createElement("a");
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = `Poem-${dateStamp}-${n}.png`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=> URL.revokeObjectURL(url), 1500);
    }, "image/png");
  }catch(e){}
}

function flashButtonOnce(btn, ms=140){
  if(!btn) return;
  btn.classList.add("on");
  window.setTimeout(()=> btn.classList.remove("on"), ms);
}
function snapScreenshot(){
  flashButtonOnce(screenshotBtn, 160);
  takeScreenshot();
}

/* Card behind phrase */
function applyCardStyle(colorHex){
  const t = sel.borderEnabled ? clamp(sel.borderThickness, 0, 1) : 0;
  if(!sel.borderEnabled || t <= 0){
    cardEl.style.display = "none";
    return;
  }
  cardEl.style.display = "block";
  cardEl.style.background = colorHex;

  const rect = phraseInkBounds() || phraseEl.getBoundingClientRect();
  if(rect.width <= 0 || rect.height <= 0){
    cardEl.style.display = "none";
    return;
  }

  const { w: vw, h: vh } = getViewportSize();
  const tAdj = Math.pow(t, 1.6);

  // Add a small base padding so the card doesn't feel cramped when hugging the ink.
  const fontPx = parseFloat(getComputedStyle(phraseEl).fontSize) || 0;
  const basePadX = clamp(fontPx * 0.40, 14, 36);
  const basePadY = clamp(fontPx * 0.26, 10, 28);

  const maxPadL = Math.max(0, rect.left);
  const maxPadR = Math.max(0, vw - rect.right);
  const maxPadT = Math.max(0, rect.top);
  const maxPadB = Math.max(0, vh - rect.bottom);

  // Keep the phrase centered inside the card as it grows: symmetric padding on each axis.
  const maxSymPadX = Math.min(maxPadL, maxPadR);
  const maxSymPadY = Math.min(maxPadT, maxPadB);

  const padX = Math.min(maxSymPadX, basePadX + (maxSymPadX * tAdj));
  const padY = Math.min(maxSymPadY, basePadY + (maxSymPadY * tAdj));

  cardEl.style.transform = "none";
  cardEl.style.left = `${Math.round(rect.left - padX)}px`;
  cardEl.style.top = `${Math.round(rect.top - padY)}px`;
  cardEl.style.width = `${Math.ceil(rect.width + (padX * 2))}px`;
  cardEl.style.height = `${Math.ceil(rect.height + (padY * 2))}px`;
}

function pctLabel(x){ return `${Math.round(clamp(Number(x),0,1)*100)}%`; }

/* ================= Speed mapping ================= */
const SPEED_MIN_S = 0.01;
const SPEED_MAX_S = 600;

function speedFromSlider(t){
  t = clamp(Number(t), 0, 1);
  const ratio = SPEED_MAX_S / SPEED_MIN_S;
  return SPEED_MIN_S * Math.pow(ratio, t);
}
function formatDuration(seconds){
  if(seconds < 0.1) return `${Math.round(seconds*1000)}ms`;
  if(seconds < 1) return `${seconds.toFixed(2)}s`;
  if(seconds < 60) return `${seconds.toFixed(seconds < 10 ? 2 : 1)}s`;
  const m = seconds / 60;
  if(m < 10) return `${m.toFixed(2)}m`;
  return `${m.toFixed(1)}m`;
}

/* ================= Visual apply ================= */
function applyColorsLive(){
  const bg = applyDimmer(current.bgBase, Number(bgBrightEl.value));
  current.bgLive = bg;
  let fg  = applyDimmer(current.fgBase, Number(fgBrightEl.value));
  let bd  = applyDimmer(current.bdBase, Number(bdBrightEl.value));

  if(bg.toLowerCase() === fg.toLowerCase()){
    const alt = pickColorNonRepeating("fg", sel.fgColor, new Set([current.bgBase]));
    if(alt) current.fgBase = alt;
    fg = applyDimmer(current.fgBase, Number(fgBrightEl.value));
  }
  if(bd.toLowerCase() === bg.toLowerCase()){
    const altB = pickColorNonRepeating("bd", sel.bdColor, new Set([current.bgBase, current.fgBase]));
    if(altB) current.bdBase = altB;
    bd = applyDimmer(current.bdBase, Number(bdBrightEl.value));
  }

  document.body.style.background = bg;
  phraseEl.style.color = fg;

  applyCardStyle(bd);

  // Update UI accents (swatches, buttons, slider dots) after background is applied.
  applyAccentColors();

  bgBrightVal.textContent = pctLabel(bgBrightEl.value);
  fgBrightVal.textContent = pctLabel(fgBrightEl.value);
  bdBrightVal.textContent = pctLabel(bdBrightEl.value);
  bdThickVal.textContent = `${Math.round(clamp(sel.borderThickness,0,1)*100)}%`;
}

/* ================= Border toggle button sync ================= */
function setBorderBtn(){
  bdToggleBtn.textContent = sel.borderEnabled ? "On" : "Off";
  bdToggleBtn.classList.toggle("on", sel.borderEnabled);
  bdToggleBtn.setAttribute("aria-pressed", sel.borderEnabled ? "true" : "false");
}

/* ================= Fullscreen helpers ================= */
const fsApi = {
  request: document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen || document.documentElement.msRequestFullscreen,
  exit: document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen
};
function isFullscreen(){
  return !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
}
function syncFullscreenBtn(){
  if(!fsApi.request || !fsApi.exit){
    fsBtn.classList.add("disabled");
    fsBtn.setAttribute("aria-disabled", "true");
    return;
  }
  fsBtn.classList.remove("disabled");
  fsBtn.removeAttribute("aria-disabled");
  const on = isFullscreen();
  fsBtn.textContent = on ? "On" : "Off";
  fsBtn.classList.toggle("on", on);
  fsBtn.setAttribute("aria-pressed", on ? "true" : "false");
}

/* ================= Tick loop ================= */
function scheduleTick(){
  if(isPaused) return;
  if(timerId) clearTimeout(timerId);
  const seconds = speedFromSlider(speedEl.value);
  speedVal.textContent = formatDuration(seconds);
  timerId = setTimeout(()=>{
    nextFrame();
    scheduleTick();
  }, Math.max(10, Math.round(seconds*1000)));
}

/* ================= Frame generation ================= */
function nextFrame(){
  let p = buildPhrase(sel.parts);

  current.phrase = p;
  phraseEl.innerHTML = formatPhraseText(current.phrase);
  last.phrase = current.phrase;

  smartPhraseWidth();

  const wasFirst = isFirstFrame;
  if(isFirstFrame){
    isFirstFrame = false;
  }else if(!isCompositionLocked){
    const bgBase = pickColorNonRepeating("bg", sel.bgColor, new Set());
    current.bgBase = bgBase || current.bgBase;

    const fgBase = pickColorNonRepeating("fg", sel.fgColor, new Set([current.bgBase]));
    current.fgBase = fgBase || current.fgBase;

    const bdBase = pickColorNonRepeating("bd", sel.bdColor, new Set([current.bgBase, current.fgBase]));
    current.bdBase = bdBase || current.bdBase;
  }

  if(!isCompositionLocked && !wasFirst){
    advancePaletteCycle();
  }

  last.bg = current.bgBase;
  last.fg = current.fgBase;
  last.bd = current.bdBase;

  applyColorsLive();
  commitGeneratedScene();
}

/* ================= UI visibility =================
   New model: the dock buttons are always available; submenus open/close via the tabs.
*/
function showUI(){
  uiWrapEl.classList.remove("hidden");
}

/* ================= Events ================= */
// Safari sometimes fails to re-apply :hover styles immediately after a click when classes toggle.
// This adds a tiny "forceHover" class while the pointer is over the button to keep hover fills consistent.
(function initForceHoverFix(){
  if(!window.matchMedia) return;
  const canHover = window.matchMedia("(hover: hover) and (pointer: fine)").matches;
  if(!canHover) return;

  document.addEventListener("pointerdown", (e)=>{
    const btn = e.target && e.target.closest ? e.target.closest("button") : null;
    if(!btn) return;
    btn.classList.add("forceHover");

    const clear = ()=> btn.classList.remove("forceHover");
    btn.addEventListener("mouseleave", clear, {once:true});
    btn.addEventListener("pointercancel", clear, {once:true});
  }, true);
})();

speedEl.addEventListener("input", ()=>{ scheduleTick(); showUI(); });
bgBrightEl.addEventListener("input", ()=>{ applyColorsLive(); showUI(); });
fgBrightEl.addEventListener("input", ()=>{ applyColorsLive(); showUI(); });
bdBrightEl.addEventListener("input", ()=>{ applyColorsLive(); showUI(); });

bdThickEl.addEventListener("input", ()=>{
  sel.borderThickness = clamp(Number(bdThickEl.value), 0, 1);
  applyColorsLive();
  showUI();
});

sizeEl.addEventListener("input", ()=>{ applyTypeAndLayout(); showUI(); });
yEl.addEventListener("input", ()=>{ applyTypeAndLayout(); applyColorsLive(); showUI(); });
widthEl.addEventListener("input", ()=>{
  if(clamp(Number(widthEl.value), 0, 100) === 0){
    phraseEl.innerHTML = formatPhraseText(current.phrase);
  }else{
    phraseEl.textContent = current.phrase;
  }
  applyTypeAndLayout();
  showUI();
});

bdToggleBtn.addEventListener("click", ()=>{
  sel.borderEnabled = !sel.borderEnabled;
  setBorderBtn();
  applyColorsLive();
  showUI();
});

fsBtn.addEventListener("click", async ()=>{
  try{
    if(!fsApi.request || !fsApi.exit) return;
    if(fsBtn.classList.contains("disabled")) return;
    if(!isFullscreen()) await fsApi.request.call(document.documentElement);
    else await fsApi.exit.call(document);
  }catch(e){}
  syncFullscreenBtn();
  showUI();
});

document.addEventListener("fullscreenchange", syncFullscreenBtn);
document.addEventListener("webkitfullscreenchange", syncFullscreenBtn);

if(prevPoemBtn) prevPoemBtn.addEventListener("click", ()=>{ goPrevPoem(); showUI(); });
if(pausePoemBtn) pausePoemBtn.addEventListener("click", ()=>{ togglePaused(); showUI(); });
if(nextPoemBtn) nextPoemBtn.addEventListener("click", ()=>{ goNextPoem(); showUI(); });
if(screenshotBtn) screenshotBtn.addEventListener("click", ()=>{ snapScreenshot(); showUI(); });
if(lockCompositionBtn) lockCompositionBtn.addEventListener("click", ()=>{ toggleCompositionLock(); showUI(); });
if(tabLayoutBtn) tabLayoutBtn.addEventListener("click", ()=>{ setUiPage("layout"); showUI(); });
if(tabLanguageBtn) tabLanguageBtn.addEventListener("click", ()=>{ setUiPage("language"); showUI(); });
if(tabColorsBtn) tabColorsBtn.addEventListener("click", ()=>{ setUiPage("colors"); showUI(); });
if(tabSpeedBtn) tabSpeedBtn.addEventListener("click", ()=>{ setUiPage("speed"); showUI(); });

window.addEventListener("keydown", (e)=>{
  if(e.repeat) return;
  const t = e.target;
  const tag = (t && t.tagName) ? String(t.tagName).toLowerCase() : "";
  const isTypingTarget =
    tag === "input" || tag === "textarea" || tag === "select" || tag === "button" ||
    (t && t.isContentEditable);
  if(isTypingTarget) return;

  if(e.code === "Space"){
    e.preventDefault();
    togglePaused();
    showUI();
    return;
  }
  if(e.code === "ArrowLeft"){
    e.preventDefault();
    goPrevPoem();
    showUI();
    return;
  }
  if(e.code === "ArrowRight"){
    e.preventDefault();
    goNextPoem();
    showUI();
    return;
  }
  if(e.code === "ArrowUp" || e.code === "ArrowDown"){
    e.preventDefault();
    const dir = (e.code === "ArrowUp") ? 1 : -1;
    if(e.shiftKey){
      const next = clamp(Number(widthEl.value) + dir, 0, 100);
      widthEl.value = String(next);
      if(clamp(Number(widthEl.value), 0, 100) === 0){
        phraseEl.innerHTML = formatPhraseText(current.phrase);
      }else{
        phraseEl.textContent = current.phrase;
      }
    }else{
      const next = clamp(Number(sizeEl.value) + dir, 0, 150);
      sizeEl.value = String(next);
    }
    applyTypeAndLayout();
    showUI();
    return;
  }
  if(e.code === "KeyS"){
    e.preventDefault();
    snapScreenshot();
    showUI();
    return;
  }
});

/* ================= Start ================= */
(function init(){
  setViewportVars();
  if(window.visualViewport){
    window.visualViewport.addEventListener("resize", setViewportVars, {passive:true});
    window.visualViewport.addEventListener("scroll", setViewportVars, {passive:true});
  }

  syncMobilePagedClass();
  // Start collapsed: show only the three page buttons.
  setUiPage("none");
  if(mobilePagerMQ){
    const onChange = ()=>{ syncMobilePagedClass(); setUiPage(uiPage); };
    if(mobilePagerMQ.addEventListener) mobilePagerMQ.addEventListener("change", onChange);
    else if(mobilePagerMQ.addListener) mobilePagerMQ.addListener(onChange);
  }

  loadRecentPhrases();

  initPaletteCycles();
  renderSentenceButtons();

  renderSwatchRow(document.getElementById("bgColorsRow"), bgHover, sel.bgColor, "bg");
  renderSwatchRow(document.getElementById("fgColorsRow"), fgHover, sel.fgColor, "fg");
  renderSwatchRow(document.getElementById("bdColorsRow"), bdHover, sel.bdColor, "bd");
  applyAccentColors();
  syncSwatchHeaderWidths();

  sel.borderEnabled = true;
  sel.borderThickness = clamp(Number(bdThickEl.value), 0, 1);

  setBorderBtn();
  applyTypeAndLayout();

  bgBrightVal.textContent = pctLabel(bgBrightEl.value);
  fgBrightVal.textContent = pctLabel(fgBrightEl.value);
  bdBrightVal.textContent = pctLabel(bdBrightEl.value);
  bdThickVal.textContent = `${Math.round(clamp(sel.borderThickness,0,1)*100)}%`;
  speedVal.textContent = formatDuration(speedFromSlider(speedEl.value));
  sizeVal.textContent = `${Math.round(clamp(Number(sizeEl.value),0,150))}%`;

  syncFullscreenBtn();
  syncPauseBtn();
  syncCompositionLockBtn();
  setCalmStart();
  const isCoarse = window.matchMedia("(pointer: coarse)").matches;
  if(isCoarse){
    bdThickEl.value = "0.30";
    sel.borderThickness = 0.30;
  }
  nextFrame();
  // Now that background is set, color the page tabs.
  assignMobileTabColors();
  scheduleTick();
  showUI();
})();

window.addEventListener("resize", ()=>{
  setViewportVars();
  applyTypeAndLayout();
  applyColorsLive();
  syncSwatchHeaderWidths();
  applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
});
</script>
</body>
</html>
