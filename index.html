<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<meta name="theme-color" content="#F7C6D0" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="default" />
<meta name="mobile-web-app-capable" content="yes" />
<title>Sculpture Poems by Margot DeMarco</title>

<style>
:root{
--fg: rgba(0,0,0,0.92);
--ui: rgba(0,0,0,0.72);
--ui3: rgba(0,0,0,0.20);
--vh: 1vh;

/* UI sizing */
--barH: clamp(175px, 21vh, 240px);
--barOffset: 40px;

/* slight scale that doesn't break layout */
--uiScale: 1.02;

/* Phrase layout */
--textScale: 1;
--mobileTextScale: 1;
--fitScale: 1;
--sceneZoom: 1;
--yPct: 50%;
--phraseW: 75vw;
--edgePad: 50px;

/* Sentence-structure pill sizing */
--pillH: 16px;
--pillPadX: 10px;
--pillFont: 7.1px;

/* Swatches */
--swOuter: 1px;
--swRing: 4px;
--swW: calc(var(--pillH) * 2);
--uiGlobalScale: 0.9;
--menuTextSize: calc(14px * 1.15 * 1.05 * 1.1 * var(--uiGlobalScale));

/* Global UI padding */
--uiPadX: 30px;

/* UI lane */
--uiMaxW: 1120px;
--uiW: min(
var(--uiMaxW),
calc(
100vw
- (var(--uiPadX) * 2)
- env(safe-area-inset-left, 0px)
- env(safe-area-inset-right, 0px)
)
);

--titlePadTop: 18px;
}

*{ box-sizing:border-box; }

html, body{
margin:0; padding:0;
width:100%;
height:100%;
overflow:hidden;
background:#F7C6D0;
font-family: "Times New Roman", Times, Georgia, serif;
-webkit-text-size-adjust: 100%;
}

body{ min-height: calc(var(--vh, 1vh) * 100); }

/* Stage above border, below UI */
#stage{
position: fixed;
top:0; left:0;
width:100vw;
height: calc(var(--vh, 1vh) * 100);
pointer-events:auto;
touch-action: none;
z-index: 20;
}

#phrase{
position:absolute;
left:50%;
top: var(--yPct);
transform: translate(-50%, -50%);
user-select:none;

text-align:center;
width: 100vw;
max-width: 100vw;
z-index: 25;
}

#phraseText{
display:block;
margin-left: auto;
margin-right: auto;
font-weight: 650;
font-size: calc(clamp(32px, 5vw, 92px) * var(--textScale) * var(--mobileTextScale) * var(--fitScale) * var(--sceneZoom));
line-height:1.12;
letter-spacing:.2px;
width: calc(var(--phraseW) * var(--sceneZoom));
max-width: calc((100vw - (var(--edgePad) * 2)) * var(--sceneZoom));
text-align:center;
white-space: normal;
overflow-wrap: normal;
word-break: normal;
hyphens: none;
}

/* Card behind phrase */
#card{
position:absolute;
left:50%;
top: var(--yPct);
transform: translate(-50%, -50%);
background: transparent;
pointer-events: none;
z-index: 10;
}

/* ===== UI wrapper (title + bar) ===== */
#uiWrap{
position: fixed;
left:0; right:0;
top:0; bottom:0;
z-index: 30;
pointer-events: none; /* bar re-enables */
transition: opacity .18s ease, transform .18s ease;
}
#uiWrap.hidden{
opacity:0;
transform: translateY(10px);
}
#uiWrap.hidden #bar,
#uiWrap.hidden #titleBlock{
pointer-events: none;
}

/* Minimal entry point when UI is hidden. */
#menuToggleBtn{
position: fixed;
left: 50%;
bottom: calc(env(safe-area-inset-bottom, 0px) + 12px);
transform: translateX(-50%);
z-index: 80;
width: calc(66px * 1.1 * var(--uiGlobalScale));
height: calc(30px * 1.1 * var(--uiGlobalScale));
border-radius: 0;
padding: 0;
display:inline-flex;
align-items:center;
justify-content:center;
font-size: var(--menuTextSize);
font-weight: 650;
line-height: 1;
letter-spacing: .2px;
text-transform: lowercase;
background: var(--menuBg, rgba(0,0,0,0.12));
color: var(--menuFg, var(--ui));
border: none;
outline: none;
box-shadow: none;
opacity: 0;
pointer-events: none;
transition: opacity .25s ease, transform .08s ease;
}
#menuToggleBtn.show{
opacity: 1;
pointer-events: auto;
}
#menuToggleBtn:active{
transform: translateX(-50%) translateY(1px);
}
#menuToggleBtn:hover,
#menuToggleBtn:focus-visible{
opacity: 1;
}
#menuToggleBtn.on{
opacity: 1;
pointer-events: auto;
}
#menuToggleBtn.dock-focus{
font-size: var(--menuTextSize);
}
#menuToggleBtn.dock-hover-focus{
font-size: var(--menuTextSize);
}
@media (hover: hover) and (pointer: fine){
#menuToggleBtn[data-tip]::after{
content: attr(data-tip);
position: absolute;
left: 50%;
bottom: calc(100% + 2px);
transform: translateX(-50%);
color: var(--cardUiFg, var(--ui));
font-size: calc(var(--menuTextSize) * 0.62);
font-weight: 650;
line-height: 1;
letter-spacing: .02em;
text-transform: lowercase;
white-space: nowrap;
opacity: 0;
z-index: 2;
pointer-events: none;
transition: opacity .12s ease;
}
#menuToggleBtn[data-tip]:hover::after,
#menuToggleBtn[data-tip]:focus-visible::after{
opacity: .9;
}
}

/* ===== Title (inside uiWrap) ===== */
#titleBlock{
position: fixed;
top: calc(env(safe-area-inset-top, 0px) + var(--titlePadTop));
left: 0;
right: 0;
z-index: 40;
pointer-events: auto;

display:flex;
flex-direction:column;
align-items:center;
gap: 6px;

width: var(--uiW);
max-width: var(--uiMaxW);
margin-left: auto;
margin-right: auto;

text-align:center;
color: var(--ui);
}
.lockBtn{
height: calc(var(--pillH) + 1px);
width: 34px; /* match playback icon pills */
padding: 1px 0 0 0; /* +1px breathing room above the glyph */
font-size: var(--pillFont);
display:inline-flex;
align-items:center;
justify-content:center;
position: relative; /* tooltip anchor */
}
.lockBtn:hover{ filter: none; }

.lockIcons{
position: relative;
width: calc(14px * var(--uiGlobalScale));
height: calc(14px * var(--uiGlobalScale));
display:inline-block;
flex: 0 0 auto;
opacity: 0.72;
}
.lockIcons .lockSvg{
position:absolute;
inset:0;
transition: opacity 140ms ease;
}
.lockSvg{
width: calc(14px * var(--uiGlobalScale));
height: calc(14px * var(--uiGlobalScale));
display:block;
overflow: visible;
}
.lockBtn .lockSvg--open{ opacity: 1; }
.lockBtn .lockSvg--closed{ opacity: 0; }
.lockBtn.locked .lockSvg--open{ opacity: 0; }
.lockBtn.locked .lockSvg--closed{ opacity: 1; }
.lockBtn:not(.locked):hover .lockSvg--open{ opacity: 0; }
.lockBtn:not(.locked):hover .lockSvg--closed{ opacity: 1; }
.lockBtn.locked:hover .lockSvg--open{ opacity: 1; }
.lockBtn.locked:hover .lockSvg--closed{ opacity: 0; }

@media (hover: hover) and (pointer: fine){
.lockBtn[data-tip]::after{
content: attr(data-tip);
position: absolute;
left: 50%;
top: calc(100% + 8px);
transform: translate(-50%, -4px);
color: var(--ui);
font-size: 9px;
letter-spacing: .10em;
text-transform: uppercase;
line-height: 1;
white-space: nowrap;
opacity: 0;
pointer-events: none;
transition: opacity .12s ease, transform .12s ease;
}
.lockBtn[data-tip]:hover::after{
opacity: .9;
transform: translate(-50%, 0);
}
}

.iconBtn{
width: 34px;
height: var(--pillH);
padding: 0;
letter-spacing: 0;
display:inline-flex;
align-items:center;
justify-content:center;
border-color: var(--ui3);
color: var(--ui);
background: transparent;
position: relative;
}
.iconBtn::before{
content:"";
position:absolute;
inset:0;
border-radius: inherit;
background: var(--btnBg, transparent);
}
.iconBtn svg{
width: 14px;
height: 14px;
display:block;
position: relative;
z-index: 1;
}
#pausePoemBtn .playIcon{ display:none; }
#pausePoemBtn.paused .pauseIcon{ display:none; }
#pausePoemBtn.paused .playIcon{ display:block; }
.iconBtn:disabled{
opacity: 0.35;
cursor: default;
background: transparent !important;
}
.iconBtn:hover{
color: var(--ui);
border-color: var(--ui3);
}
.iconBtn:hover::before,
.iconBtn.forceHover::before{
background: color-mix(in srgb, var(--btnBg) 70%, transparent);
filter: none;
}
.iconBtn:active::before{
background: color-mix(in srgb, var(--btnBg) 70%, transparent);
}
.iconBtn:disabled:hover{
filter: none;
color: var(--ui);
border-color: var(--ui3);
}
.iconBtn:disabled:hover::before{ filter: none; }

@media (hover: hover) and (pointer: fine){
.iconBtn[data-tip]::after{
content: attr(data-tip);
position: absolute;
left: 50%;
bottom: calc(100% + 8px);
transform: translate(-50%, 4px);
color: var(--ui);
font-size: 9px;
letter-spacing: .10em;
text-transform: uppercase;
line-height: 1;
white-space: nowrap;
opacity: 0;
pointer-events: none;
transition: opacity .12s ease, transform .12s ease;
}
.iconBtn[data-tip]:hover::after{
opacity: .9;
transform: translate(-50%, 0);
}
}

@media (hover: hover) and (pointer: fine){
/* Dock button hover text (below the button). */
.dockBtn[data-tip]{
position: relative;
}
.dockBtn[data-tip]::after{
content: attr(data-tip);
position: absolute;
left: 50%;
top: calc(100% + 8px);
transform: translate(-50%, -4px);
color: var(--ui);
font-size: 9px;
letter-spacing: .10em;
text-transform: uppercase;
line-height: 1;
white-space: nowrap;
opacity: 0;
pointer-events: none;
transition: opacity .12s ease, transform .12s ease;
}
.dockBtn[data-tip]:hover::after{
opacity: .9;
transform: translate(-50%, 0);
}
}

/* ===== Bottom Dock + Sliding Panel ===== */
#bar{
position: fixed;
left: 0;
right: 0;
top: 0;
bottom: 0;
height: 100%;
padding: 0;

pointer-events:none;
background: transparent;

max-height: calc(var(--vh, 1vh) * 100);
max-width: none;
overflow: visible;
transform: none;
transition: none;
}

.barInner{
width: 100%;
max-width: none;
margin-left: auto;
margin-right: auto;

display:flex;
flex-direction:column;
gap:0;
height:100%;
overflow: visible;

transform: none;
transform-origin: center;
}

#panelWrap{
--panelMaxH: 62vh; /* JS may override this to keep UI out of the phrase/card safe zone */
position: fixed;
left: 0;
top: 0;
bottom: auto;
width: fit-content;
max-width: calc(100vw - 12px);
overflow: visible;
max-height: 0;
opacity: 0;
transform: none;
transition: opacity .14s ease;
pointer-events: none;
margin-bottom: 0;
}
#panelWrap.panel-tiles{
left: 0 !important;
top: 0 !important;
width: 0 !important;
height: 0 !important;
max-width: none !important;
max-height: none !important;
overflow: visible !important;
pointer-events: none !important;
margin: 0 !important;
}
body[data-ui-page]:not([data-ui-page="none"]) #panelWrap{
max-height: var(--panelMaxH, 62vh);
opacity: 1;
transform: none;
pointer-events: auto;
margin-bottom: 10px;
}
#panelInner{
max-height: none;
overflow: visible;
display:flex;
flex-direction:column;
align-items:center;
gap: 8px;
padding-top: 4px;
}
#panelWrap.panel-tiles #panelInner{
max-height: none !important;
overflow: visible !important;
display: block !important;
padding: 0 !important;
gap: 0 !important;
pointer-events: none !important;
}
#panelInner .uiPage{
background: var(--cardUiBg, transparent);
width: fit-content;
max-width: min(var(--uiW), 94vw);
padding: 6px 8px;
}
#panelWrap.panel-tiles #panelInner .uiPage{
background: transparent !important;
width: auto !important;
max-width: none !important;
padding: 0 !important;
}
#panelInner .panelTileFloat{
position: fixed !important;
margin: 0 !important;
z-index: 58;
pointer-events: auto !important;
}

#dock{
position: fixed;
inset: 0;
display: block;
padding: 0;
margin: 0;
pointer-events: none;
transform: none !important;
transition: none;
}
#titleBlock #dock{ margin-top: 22px; }
#dockPlayback{
display:flex;
gap: 3px;
align-items:center;
}
#dockMenu{
display: contents;
}
#dockBottom{
display: contents;
}
.dockBtn{
height: var(--pillH);
padding: 0 12px;
font-size: var(--pillFont);
min-width: 0;
}
#screenshotBtn{ grid-area: shot; }
#tabColorsBtn{ grid-area: colors; }
#fsBtn{ grid-area: fs; }
#tabLanguageBtn{ grid-area: lang; }
#tabContrastBtn{ grid-area: contrast; }
#tabSpeedBtn{ grid-area: speed; }
#lockCompositionBtn{ grid-area: lock; }
#dock .dockBtn,
#dock .iconBtn,
#dock .lockBtn{
--btnScale: var(--uiGlobalScale);
border-radius: 0;
border: none;
background: var(--cardUiBg, transparent);
color: var(--cardUiFg, var(--ui));
box-shadow: none;
text-transform: lowercase;
font-weight: 650;
letter-spacing: .02em;
}
#dock .dockBtn:hover,
#dock .iconBtn:hover,
#dock .lockBtn:hover,
#dock .dockBtn:focus-visible,
#dock .iconBtn:focus-visible,
#dock .lockBtn:focus-visible,
#dock .iconBtn:disabled:hover{
color: var(--cardUiFg, var(--ui));
}
#dock .dockBtn{
height: calc(30px * var(--btnScale));
font-size: calc(var(--menuTextSize) * var(--btnScale));
line-height: 1;
padding: 0 calc(12px * var(--btnScale));
}
#dock .iconBtn{
width: calc(32px * var(--btnScale));
height: calc(30px * var(--btnScale));
padding: 0;
}
#dock .iconBtn::before{
background: var(--cardUiBg, transparent);
border-radius: 0;
}
#dock .iconBtn svg{
width: calc(14px * var(--uiGlobalScale));
height: calc(14px * var(--uiGlobalScale));
}
#dock .lockBtn{
width: calc(30px * var(--btnScale));
height: calc(30px * var(--btnScale));
padding: 0;
}
#dock .lockIcons{
opacity: 1;
}
#panelInner .uiPage .label,
#panelInner .uiPage .val{
color: var(--cardUiFg, var(--ui));
opacity: .9;
}
#panelInner .uiPage .ssBtn,
#panelInner .uiPage .colorBtn{
border-radius: 0;
border: none;
background: var(--cardUiBg, transparent);
color: var(--cardUiFg, var(--ui));
text-transform: lowercase;
font-weight: 650;
letter-spacing: .02em;
}
#panelInner .uiPage .ssBtn:hover,
#panelInner .uiPage .ssBtn:focus-visible,
#panelInner .uiPage .colorBtn:hover,
#panelInner .uiPage .colorBtn:focus-visible{
color: var(--cardUiFg, var(--ui));
}
#panelInner .uiPage .label,
#panelInner .uiPage .val,
#panelInner .uiPage .ssBtn,
#panelInner .uiPage .colorBtn{
font-size: var(--menuTextSize) !important;
line-height: 1;
}
#panelInner .uiPage .label,
#panelInner .uiPage .val{
font-size: calc(var(--menuTextSize) * 0.72) !important;
line-height: 1.05;
letter-spacing: .02em;
text-transform: lowercase;
font-weight: 650;
}
#panelInner .uiPage--contrast,
#panelInner .uiPage--speed{
background: transparent;
padding: 0;
}
#dock .dockControl{
position: fixed;
margin-top: 0;
z-index: 60;
transform: scale(1);
transform-origin: center center;
transition: width .16s ease, height .16s ease, padding .16s ease, font-size .16s ease, margin-top .16s ease, left .18s ease, top .18s ease, transform .12s ease;
}
#dock .dockControl.dock-shrink{
--btnScale: var(--uiGlobalScale);
transform: scale(1);
}
#dock .dockControl.dock-focus{
--btnScale: var(--uiGlobalScale);
transform: scale(1);
z-index: 62;
}
#dock .dockControl.dock-hover-focus{
--btnScale: var(--uiGlobalScale);
transform: scale(1);
}
#dock .dockControl.dock-hover-shrink{
--btnScale: var(--uiGlobalScale);
transform: scale(1);
}
/* When a panel is open, keep extra center space by shrinking non-focused controls. */
body[data-ui-page]:not([data-ui-page="none"]) #dock .dockControl.dock-shrink{
--btnScale: var(--uiGlobalScale);
transform: scale(0.9);
}
body[data-ui-page]:not([data-ui-page="none"]) #dock .dockControl.dock-focus{
--btnScale: var(--uiGlobalScale);
transform: scale(1);
}
#dock .dockObject{
position: fixed;
pointer-events: auto;
}
#dock .dockControl[data-tip]::after{
content: attr(data-tip);
position: absolute;
left: 50%;
bottom: calc(100% + 2px);
top: auto;
transform: translateX(-50%);
color: var(--cardUiFg, var(--ui));
font-size: calc(var(--menuTextSize) * 0.62);
font-weight: 650;
line-height: 1;
letter-spacing: .02em;
text-transform: lowercase;
white-space: nowrap;
opacity: 0;
z-index: 2;
pointer-events: none;
transition: opacity .12s ease;
}
#dock .dockControl.dock-tip-open::after{
opacity: 1;
}
#dock .iconBtn[data-tip]::after{
color: var(--cardUiFg, var(--ui));
font-size: calc(var(--menuTextSize) * 0.62);
font-weight: 650;
line-height: 1;
letter-spacing: .02em;
text-transform: lowercase;
bottom: calc(100% + 2px);
}
.row{
display:flex;
gap:12px;
align-items:flex-end;
flex-wrap:nowrap;
min-width:0;
}
.centerRow{
justify-content: center;
align-items: center;
text-align: center;
}

/* centered 3 swatch sections */
.colorsRow{
justify-content: center;
align-items:flex-end;
gap: 28px;
flex-wrap:nowrap;
}
/* (removed) vertical swatch column; colors page uses the 3-up row again */

.grp{
display:flex;
flex-direction:column;
gap:5px;
min-width:0;
flex: 0 1 360px;
}
.grp.words{
flex: 0 0 auto;
align-items: stretch;
}

.label{
font-size: 9px;
letter-spacing:.10em;
text-transform:uppercase;
color: var(--ui);
user-select:none;
line-height:1;
opacity:.82;
display:block;
white-space:nowrap;
}
.labelRow{
display:flex;
justify-content:space-between;
align-items:baseline;
gap:10px;
min-width:0;
}
.val{
font-size: 9px;
letter-spacing:.10em;
text-transform:uppercase;
color: var(--ui);
opacity:.9;
user-select:none;
white-space:nowrap;
}

button{
font: inherit;
font-weight: 520;
font-size: 7.1px;
letter-spacing: .10em;
text-transform: uppercase;
color: var(--ui);
background: transparent;
border: none;
border-radius: 999px;
padding: 3.6px 6px;
cursor: pointer;
line-height: 1;
user-select: none;
white-space: nowrap;
transition: transform .05s ease, color .15s ease, background-color .15s ease;
-webkit-tap-highlight-color: transparent;
}
button:active{ transform: translateY(1px); }
button:hover{ color: var(--ui); }

/* When a button is "on", kill the outline entirely (keeps sliders unaffected). */
button.on{ border: none !important; }
button.on:hover{ border: none !important; }

.colorBtn{
background: var(--btnBg, transparent);
border: none;
color: var(--ui);
}
.colorBtn:not(.on){
background: var(--btnBg, transparent);
}
.colorBtn:not(.on):hover,
.colorBtn.forceHover:not(.on){
background: var(--btnBg, transparent);
filter: none;
color: var(--ui);
border: none;
}
.colorBtn.on:hover,
.colorBtn.forceHover.on{
background: var(--btnBg, transparent);
filter: none;
color: var(--ui);
border: none;
}
.colorBtn:not(.on):active{
background: var(--btnBg, transparent);
}
.colorBtn.on:active{
background: var(--btnBg, transparent);
}
.colorBtn.disabled{
opacity: 0.55;
cursor: default;
filter: none;
}

.btnGroup{
display:flex;
flex-wrap:wrap;
gap:4.5px;
align-items:center;
min-width:0;
overflow: visible;
}
.btnGroup.centered{ justify-content: center; }

/* Center the "Sentence Structure" title while keeping the tiny on/off indicator on the right. */
.grp.words .labelRow{
position: relative;
justify-content: flex-end;
width: 100%;
}
.grp.words .labelRow .label{
position:absolute;
left:50%;
transform: translateX(-50%);
}
.grp.words .labelRow .hoverVal{
margin-left: auto;
}
.ssBtn{
height: var(--pillH);
padding: 0 var(--pillPadX);
border-radius: 999px;
border: none;
font-weight: 520;
font-size: var(--pillFont);
display:inline-flex;
align-items:center;
justify-content:center;
color: var(--fg);
background: transparent;
}
.ssBtn.on{
background: var(--ssBg);
color: var(--fg);
border: none;
}
.ssBtn:not(.on){
background: transparent;
color: var(--ui);
border: none;
}
.ssBtn:not(.on):hover,
.ssBtn.forceHover:not(.on){
background: color-mix(in srgb, var(--ssBg) 50%, transparent);
filter: none;
color: var(--ui);
border: none;
}
.ssBtn.on:hover,
.ssBtn.forceHover.on{
background: color-mix(in srgb, var(--ssBg) 70%, transparent);
filter: none;
color: var(--ui);
border: none;
}
.ssBtn:not(.on):active{
background: color-mix(in srgb, var(--ssBg) 50%, transparent);
}
.ssBtn.on:active{
background: color-mix(in srgb, var(--ssBg) 70%, transparent);
}

.sliderRow{
display:flex;
gap:12px;
align-items:flex-end;
flex-wrap:nowrap;
min-width:0;
}

/* ===== Paged UI (Language / Contrast / Colors / Speed) ===== */
.uiPage{ display:none; }
body[data-ui-page="language"] .uiPage--language{ display:block; }
body[data-ui-page="info"] .uiPage--info{ display:block; }
body[data-ui-page="contrast"] .uiPage--contrast{ display:block; }
body[data-ui-page="colors"] .uiPage--colors{ display:block; }
body[data-ui-page="speed"] .uiPage--speed{ display:block; }

/* Language panel: sentence structure buttons are standalone controls. */
.uiPage--language{
max-width: min(960px, 96vw);
margin-left: auto;
margin-right: auto;
background: transparent;
padding: 0;
}
.uiPage--language #partsRow{
display:flex;
flex-wrap:wrap;
gap: 8px;
justify-content: center;
align-items:center;
}
.uiPage--language #partsRow .ssBtn{
min-width: max-content;
width: max-content;
height: calc(36px * var(--uiGlobalScale));
padding: 0 calc(12px * var(--uiGlobalScale));
border-radius: 0;
border: none;
background: var(--cardUiBg, transparent);
color: var(--cardUiFg, var(--ui));
text-transform: lowercase;
font-weight: 650;
letter-spacing: .02em;
font-size: calc(var(--menuTextSize) * 1.2) !important;
line-height: 1;
transition: height .12s ease, padding .12s ease, font-size .12s ease;
}
.uiPage--language #partsRow .ssBtn:not(.on){
opacity: 1;
filter: none;
box-shadow: none;
min-width: max-content;
width: max-content;
height: calc(18px * var(--uiGlobalScale));
padding: 0 calc(8px * var(--uiGlobalScale));
font-size: calc(var(--menuTextSize) * 0.6) !important;
}
.uiPage--language #partsRow .ssBtn.on{
opacity: 1;
filter: none;
box-shadow: none;
min-width: max-content;
width: max-content;
height: calc(36px * var(--uiGlobalScale));
padding: 0 calc(12px * var(--uiGlobalScale));
font-size: calc(var(--menuTextSize) * 1.2) !important;
}
.uiPage--language #partsRow .ssBtn:hover,
.uiPage--language #partsRow .ssBtn:focus-visible,
.uiPage--language #partsRow .ssBtn:active{
background: var(--cardUiBg, transparent);
color: var(--cardUiFg, var(--ui));
border: none;
}

.uiPage--info{
max-width: min(980px, 96vw);
margin-left: auto;
margin-right: auto;
}
.uiPage--info .infoGroup{
display: flex;
flex-direction: column;
align-items: center;
gap: 6px;
width: fit-content;
max-width: 94vw;
margin-left: auto;
margin-right: auto;
}
.uiPage--info .infoHeadTile,
.uiPage--info .infoBlurbTile{
background: var(--cardUiBg, transparent);
color: var(--cardUiFg, var(--ui));
text-align: center;
}
.uiPage--info .infoHeadTile{
padding: calc(8px * var(--uiGlobalScale)) calc(10px * var(--uiGlobalScale));
width: max-content;
max-width: 94vw;
}
.uiPage--info .infoBlurbTile{
padding: calc(12px * var(--uiGlobalScale)) calc(14px * var(--uiGlobalScale));
width: min(86vw, 620px);
}
.uiPage--info .infoTitle{
font-size: calc((var(--menuTextSize) * 0.7) + 2px);
font-weight: 400;
letter-spacing: .01em;
line-height: 1.1;
margin-bottom: 0;
text-transform: none;
}
.uiPage--info .infoByline{
font-size: calc((var(--menuTextSize) * 0.7) + 2px);
font-weight: 650;
line-height: 1.1;
margin-bottom: 0;
text-transform: none;
}
.uiPage--info p{
margin: 0 0 10px 0;
font-size: calc((var(--menuTextSize) * 0.7) + 1px);
line-height: 1.24;
letter-spacing: .01em;
text-transform: none;
text-align: center;
}
.uiPage--info p:last-child{
margin-bottom: 0;
}

/* Contrast panel: dedicated brightness sliders. */
.uiPage--contrast{
max-width: min(980px, 96vw);
margin-left: auto;
margin-right: auto;
}
.uiPage--contrast .colorsBrightnessRow{
margin-bottom: 0;
display:grid;
grid-template-columns: repeat(3, minmax(196px, 1fr));
gap: 10px;
}
.uiPage--contrast .ctrl{
min-width: 196px;
flex: 1 1 auto;
}

/* Colors panel: all swatches shown together (no grouped rows). */
.uiPage--colors{
max-width: min(940px, 96vw);
margin-left: auto;
margin-right: auto;
}
.uiPage--colors .colorsPanelLayout{
display: grid;
grid-template-columns: max-content max-content max-content;
align-items: center;
justify-content: center;
gap: 14px;
width: fit-content;
margin-left: auto;
margin-right: auto;
}
.uiPage--colors .colorsScopeCol,
.uiPage--colors .colorsBulkCol{
display: flex;
flex-direction: column;
gap: 7px;
align-items: center;
justify-content: center;
background: transparent;
padding: 0;
}
.uiPage--colors .colorsGridCol{
display: flex;
flex-direction: column;
align-items: center;
gap: 8px;
min-width: 0;
background: var(--cardUiBg, transparent);
padding: calc(9px * var(--uiGlobalScale));
}
.uiPage--colors .swatchGridPanel{
background: transparent;
padding: 0;
display: inline-flex;
align-items: center;
justify-content: center;
}
.uiPage--colors .colorScopeBtn{
height: auto;
min-height: 0;
min-width: max-content;
width: max-content;
padding: calc(6px * var(--uiGlobalScale)) calc(14px * var(--uiGlobalScale));
display: inline-flex;
align-items: center;
justify-content: center;
white-space: nowrap;
line-height: 1;
font-size: var(--menuTextSize) !important;
transition: padding .12s ease, font-size .12s ease, opacity .12s ease;
}
#panelInner .uiPage--colors .colorScopeBtn{
font-size: var(--menuTextSize) !important;
padding: calc(6px * var(--uiGlobalScale)) calc(14px * var(--uiGlobalScale));
min-width: max-content;
width: max-content;
}
#panelInner .uiPage--colors .colorScopeBtn:not(.on){
opacity: 1;
filter: none;
font-size: calc(var(--menuTextSize) * 0.7) !important;
padding: calc(4px * var(--uiGlobalScale)) calc(10px * var(--uiGlobalScale)) !important;
}
#panelInner .uiPage--colors .colorScopeBtn.on{
opacity: 1;
filter: none;
box-shadow: none;
font-size: var(--menuTextSize) !important;
padding: calc(6px * var(--uiGlobalScale)) calc(14px * var(--uiGlobalScale)) !important;
}
#panelInner .uiPage--colors .colorScopeBtn:not(.on):active{
font-size: calc(var(--menuTextSize) * 0.7) !important;
padding: calc(4px * var(--uiGlobalScale)) calc(10px * var(--uiGlobalScale));
}
#panelInner .uiPage--colors .colorScopeBtn.on:active{
font-size: var(--menuTextSize) !important;
padding: calc(6px * var(--uiGlobalScale)) calc(14px * var(--uiGlobalScale));
}
.uiPage--colors .label,
.uiPage--colors .val{
font-size: 8px;
letter-spacing: .07em;
}
.uiPage--colors .swatchRow--all{
display: grid;
grid-template-columns: repeat(10, max-content);
justify-content: center;
gap: 7px;
width: auto;
}
.uiPage--colors .swatchHeader{
width: auto !important;
min-width: 100%;
display: flex;
justify-content: space-between;
gap: 14px;
}
.uiPage--colors .swatchHeader{ display: none; }
.uiPage--colors .swatchHeader .label{
text-transform: lowercase;
}
.uiPage--colors .swatchHeader .hoverVal{
min-width: 12ch;
text-align: right;
}
.uiPage--colors .swatchRow--all .swatch{
position: relative;
width: 30px;
height: 30px;
border: none;
border-radius: 0;
padding: 0;
background: var(--fillCol);
overflow: hidden;
box-shadow: none;
}
.uiPage--colors .swatchRow--all .swatch::before{
content:"";
position:absolute;
left: 5px;
right: 5px;
top: 14px;
height: 1.6px;
background: color-mix(in srgb, var(--cardUiFg, var(--ui)) 70%, transparent);
transform: rotate(42deg);
opacity: 0;
pointer-events: none;
}
.uiPage--colors .swatchRow--all .swatch::after{
content:"";
position:absolute;
left: 5px;
right: 5px;
top: 14px;
height: 1.6px;
background: color-mix(in srgb, var(--cardUiFg, var(--ui)) 70%, transparent);
transform: rotate(-42deg);
opacity: 0;
pointer-events: none;
}
.uiPage--colors .swatchRow--all .swatch.on{
background: var(--fillCol);
opacity: 1;
filter: none;
box-shadow: none;
}
.uiPage--colors .swatchRow--all .swatch:not(.on){
background: var(--fillCol);
opacity: .62;
filter: saturate(.82);
box-shadow: none;
}
.uiPage--colors .swatchRow--all .swatch:not(.on)::before,
.uiPage--colors .swatchRow--all .swatch:not(.on)::after{ opacity: .72; }
.uiPage--colors .swatchRow--all .swatch.on:hover,
.uiPage--colors .swatchRow--all .swatch.on:active{
background: color-mix(in srgb, var(--fillCol) 88%, transparent);
opacity: 1;
box-shadow: none;
}
.uiPage--colors .swatchRow--all .swatch:not(.on):hover,
.uiPage--colors .swatchRow--all .swatch:not(.on):active{
background: var(--fillCol);
opacity: .78;
box-shadow: none;
}

@media(max-width: 860px){
.uiPage--language{ max-width: min(640px, 100%); }
.uiPage--language #partsRow .ssBtn{
height: calc(34px * var(--uiGlobalScale));
}
.uiPage--language #partsRow .ssBtn:not(.on){
height: calc(17px * var(--uiGlobalScale));
padding: 0 calc(7px * var(--uiGlobalScale));
}

.uiPage--contrast{
max-width: min(640px, 100%);
}
.uiPage--contrast .colorsBrightnessRow{
grid-template-columns: repeat(2, minmax(187px, 1fr));
}
.uiPage--colors{
max-width: min(640px, 100%);
}
.uiPage--colors .colorsPanelLayout{
grid-template-columns: 1fr;
justify-items: center;
gap: 10px;
}
.uiPage--colors .colorsScopeCol,
.uiPage--colors .colorsBulkCol{
flex-direction: column;
}
.uiPage--colors .swatchRow--all{
grid-template-columns: repeat(6, max-content);
}
}
@media(max-width: 640px){
.uiPage--contrast .colorsBrightnessRow{ grid-template-columns: 1fr; }
}

#panelInner .uiPage button{
overflow: hidden;
text-overflow: clip;
}

/* ===== Mobile landscape ===== */
@media (pointer: coarse) and (orientation: landscape) and (max-height: 520px){
/* Reduce top clutter so the dock never covers the phrase/card. */
#titleBlock{ gap: 4px; }
#titleBlock #dock{
margin-top: 14px;
gap: 10px;
}

/* Contrast + colors: keep wide layout in landscape. */
.uiPage--contrast{
max-width: min(920px, 94vw);
}
.uiPage--contrast .colorsBrightnessRow{
grid-template-columns: repeat(3, minmax(0, 1fr));
}

.uiPage--colors{
max-width: min(920px, 94vw);
}
.uiPage--colors .colorsPanelLayout{
grid-template-columns: max-content max-content max-content;
}
.uiPage--colors .colorsScopeCol,
.uiPage--colors .colorsBulkCol{
flex-direction: column;
}
.uiPage--colors .swatchRow--all{
grid-template-columns: repeat(8, max-content);
}
}

/* Speed submenu uses the same tile language as other slider menus. */
.uiPage--speed{
max-width: min(420px, 96vw);
margin-left: auto;
margin-right: auto;
}
.uiPage--speed .sliderRow{
display:grid;
grid-template-columns: minmax(230px, 1fr);
justify-content: center;
}
.uiPage--speed .ctrl{ min-width: 230px; }

.uiPage--contrast .ctrl,
.uiPage--speed .ctrl{
background: var(--cardUiBg, transparent);
color: var(--cardUiFg, var(--ui));
padding: calc(9px * var(--uiGlobalScale)) calc(12px * var(--uiGlobalScale));
display: flex;
flex-direction: column;
gap: calc(7px * var(--uiGlobalScale));
min-width: 0;
}
.uiPage--contrast .labelRow,
.uiPage--speed .labelRow{
margin-bottom: 0;
align-items: center;
}
.uiPage--contrast .label,
.uiPage--speed .label,
.uiPage--contrast .val,
.uiPage--speed .val{
font-size: calc((var(--menuTextSize) * 0.74) + 1px) !important;
letter-spacing: .02em;
text-transform: lowercase;
font-weight: 650;
}
.uiPage--contrast input[type=range],
.uiPage--speed input[type=range]{
height: calc(20px * var(--uiGlobalScale));
}
.uiPage--contrast input[type=range]::-webkit-slider-runnable-track,
.uiPage--speed input[type=range]::-webkit-slider-runnable-track{
height: 3px;
}
.uiPage--contrast input[type=range]::-moz-range-track,
.uiPage--speed input[type=range]::-moz-range-track{
height: 3px;
}
.uiPage--contrast input[type=range]::-webkit-slider-thumb,
.uiPage--speed input[type=range]::-webkit-slider-thumb{
width: calc(12px * var(--uiGlobalScale));
height: calc(12px * var(--uiGlobalScale));
margin-top: calc(-4.5px * var(--uiGlobalScale));
}
.uiPage--contrast input[type=range]::-moz-range-thumb,
.uiPage--speed input[type=range]::-moz-range-thumb{
width: calc(12px * var(--uiGlobalScale));
height: calc(12px * var(--uiGlobalScale));
}

/* Dock buttons stay fully visible in the unified card-color style. */
.ctrl{
flex: 1 1 0;
display:flex;
flex-direction:column;
gap:3px;
min-width:0;
}
input[type=range]{
appearance:none;
width:100%;
height:16px;
background:transparent;
color: var(--thumbCol, var(--fg));
margin:0;
padding:0;
touch-action: none;
}
input[type=range]::-webkit-slider-runnable-track{
height:2px;
background:var(--ui3);
border-radius:999px;
}
input[type=range]::-moz-range-track{
height:2px;
background:var(--ui3);
border-radius:999px;
}
input[type=range]::-webkit-slider-thumb{
appearance:none;
width:10px; height:10px;
border-radius:50%;
background: currentColor;
margin-top:-4px;
border: none;
box-sizing: border-box;
}
input[type=range]::-moz-range-thumb{
width:10px; height:10px;
border-radius:50%;
background: currentColor;
border: none;
box-sizing: border-box;
}

.swatchWrap{
display:flex;
flex-direction:column;
gap:5px;
width:100%;
max-width:100%;
align-items:center;
}
.swatchHeader{
display:flex;
justify-content: space-between;
gap: 10px;
align-items: baseline;
width: fit-content;
}
.hoverVal{ min-width: 7ch; text-align: right; }

.swatchRow{
display:flex;
flex-wrap:nowrap;
gap: 10px;
align-items:center;
justify-content:center;
min-width:0;
max-width: 100%;
width: fit-content;
}

#phraseText.oneWord{
white-space: normal;
width: 100%;
max-width: 100%;
}

.swatch{
width: var(--swW);
height: var(--pillH);
padding: 0;
border-radius: 999px;
border: none;
background: transparent;
box-shadow: none;
cursor: pointer;
transition: transform .05s ease, filter .12s ease, box-shadow .12s ease, background-color .12s ease;
}
.swatch:active{ transform: translateY(1px); }

.swatch.on{
background: var(--fillCol);
box-shadow: inset 0 0 0 var(--swRing) var(--ringCol);
}
.swatch:not(.on):hover,
.swatch.forceHover:not(.on){
background: color-mix(in srgb, var(--fillCol) 50%, transparent);
box-shadow: inset 0 0 0 var(--swRing) color-mix(in srgb, var(--ringCol) 50%, transparent);
filter: none;
}
.swatch.on:hover,
.swatch.forceHover.on{
background: color-mix(in srgb, var(--fillCol) 70%, transparent);
box-shadow: inset 0 0 0 var(--swRing) color-mix(in srgb, var(--ringCol) 70%, transparent);
filter: none;
}
.swatch:not(.on):active{
background: color-mix(in srgb, var(--fillCol) 50%, transparent);
box-shadow: inset 0 0 0 var(--swRing) color-mix(in srgb, var(--ringCol) 50%, transparent);
}
.swatch.on:active{
background: color-mix(in srgb, var(--fillCol) 70%, transparent);
box-shadow: inset 0 0 0 var(--swRing) color-mix(in srgb, var(--ringCol) 70%, transparent);
}

@supports not (color-mix(in srgb, red 30%, transparent)){
.swatch{
background: transparent;
box-shadow: none;
opacity: 1;
}
.swatch.on{
background: var(--fillCol);
box-shadow: inset 0 0 0 var(--swRing) var(--ringCol);
}
.swatch:hover{
background: var(--fillCol);
box-shadow: inset 0 0 0 var(--swRing) var(--ringCol);
opacity: 0.85;
}

.colorBtn:hover{ background: var(--btnBg, transparent); }
.ssBtn:hover{ background: var(--ssBg); }
.iconBtn:hover::before{ background: var(--btnBg, transparent); }
}

@media (pointer: coarse){
:root{
--pillH: 18px;
--pillPadX: 12px;
--pillFont: 7.6px;
--mobileTextScale: 0.95;
}
button{ font-size: 7.4px; padding: 5px 8px; }
.iconBtn{ width: 42px; height: var(--pillH); padding: 0; }
.iconBtn svg{ width: 18px; height: 18px; }
input[type=range]{ height: 20px; }
input[type=range]::-webkit-slider-thumb{
width:13px; height:13px;
margin-top:-5.5px;
}
input[type=range]::-moz-range-thumb{
width:13px; height:13px;
}
}

@media(max-width: 980px){
:root{
--barH: clamp(240px, 34vh, 330px);
--barOffset: 30px;
--uiMaxW: 980px;
}
.row, .sliderRow{ flex-wrap:wrap; }
.colorsRow{ flex-wrap:wrap; }
.grp{ flex: 1 1 320px; }
.swatchRow{ flex-wrap:wrap; }
}

@media(max-width: 640px){
:root{
--barH: clamp(260px, 40vh, 370px);
--barOffset: 20px;
--pillH: 15px;
--swW: calc(var(--pillH) * 2);
--uiMaxW: 620px;
--titlePadTop: 16px;
}
#phraseText{ font-size: calc(clamp(28px, 7vw, 70px) * var(--textScale) * var(--mobileTextScale) * var(--fitScale) * var(--sceneZoom)); }
button{ font-size: 6.8px; padding: 3.4px 5.3px; }
.label, .val{ font-size: 8.5px; }
.btnGroup{ gap:4px; }
.swatchRow{ gap: 9px; flex-wrap:wrap; }
}

@media(max-width: 480px), (max-height: 720px){
:root{
--barH: clamp(210px, 30vh, 250px);
--barOffset: 8px;
--uiScale: 0.96;
--uiPadX: 14px;
}
/* Bottom dock/panel manages its own scrolling (panelInner). */
#titleBlock{ gap: 4px; }
}
</style>
</head>

<body data-ui-page="none">
<div id="stage">
<div id="card" aria-hidden="true"></div>
<div id="phrase" role="status" aria-live="polite">
<span id="phraseText"></span>
</div>
</div>

<!-- UI WRAP: title + bar (fades together) -->
<div id="uiWrap">
<div id="titleBlock">
<!-- TOP BUTTONS (always visible on load; fade with UI) -->
<div id="dockTopHost" aria-label="buttons (top host)">
<div id="dock" aria-label="buttons">
<div id="dockPlayback" aria-label="playback controls">
<button id="prevPoemBtn" type="button" class="iconBtn" aria-label="previous poem (left arrow)" data-tip="previous">
<svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
<path d="M15 6l-6 6 6 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</button>
<button id="pausePoemBtn" type="button" class="iconBtn" aria-label="pause (space)" aria-pressed="false" data-tip="pause">
<svg class="pauseIcon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
<path d="M7 6h3v12H7zM14 6h3v12h-3z" fill="currentColor"/>
</svg>
<svg class="playIcon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
<path d="M9 7l10 5-10 5V7z" fill="currentColor"/>
</svg>
</button>
<button id="nextPoemBtn" type="button" class="iconBtn" aria-label="next poem (right arrow)" data-tip="forward">
<svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
<path d="M9 6l6 6-6 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</button>
</div>

<div id="dockBottom" aria-label="utilities">
<button id="screenshotBtn" type="button" class="colorBtn dockBtn" aria-label="screenshot (s)" data-tip="take pic">screenshot</button>
<button id="fsBtn" type="button" class="colorBtn dockBtn" aria-pressed="false" data-tip="zoom">full screen</button>
<button id="lockCompositionBtn" type="button" class="colorBtn lockBtn" aria-label="lock composition" aria-pressed="false" data-tip="lock">
<span class="lockIcons" aria-hidden="true">
<svg class="lockSvg lockSvg--open" viewBox="0 0 24 24" focusable="false" aria-hidden="true">
<rect x="5" y="10" width="14" height="12" rx="1.5" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
<path d="M7 10V7 Q7 2 12 2 Q17 2 17 7 V10" transform="translate(34 -1) scale(-1 1)" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
<rect x="9" y="15" width="6" height="2" fill="currentColor"/>
</svg>
<svg class="lockSvg lockSvg--closed" viewBox="0 0 24 24" focusable="false" aria-hidden="true">
<rect x="5" y="10" width="14" height="12" rx="1.5" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
<path d="M7 10V7 Q7 2 12 2 Q17 2 17 7 V10" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
<rect x="11" y="14" width="2" height="5" fill="currentColor"/>
</svg>
</span>
</button>
</div>

<div id="dockMenu" aria-label="menus">
<button id="tabLanguageBtn" type="button" class="colorBtn dockBtn" aria-pressed="false" data-tip="change phrase structure">language</button>
<button id="tabContrastBtn" type="button" class="colorBtn dockBtn" aria-pressed="false" data-tip="adjust light / dark">contrast</button>
<button id="tabColorsBtn" type="button" class="colorBtn dockBtn" aria-pressed="false" data-tip="adjust swatches">colors</button>
<button id="tabSpeedBtn" type="button" class="colorBtn dockBtn" aria-pressed="false" data-tip="adjust sequence">speed</button>
<button id="tabInfoBtn" type="button" class="colorBtn dockBtn" aria-pressed="false" data-tip="sculpture poems">info</button>
</div>
</div>
</div>
</div>

<div id="bar">
<div class="barInner">

<!-- Submenu pages -->
<div id="panelWrap" aria-label="submenu panel">
<div id="panelInner">
<section class="uiPage uiPage--language" aria-label="language">
<div class="btnGroup centered" id="partsRow"></div>
</section>

<section class="uiPage uiPage--info" aria-label="info">
<div class="infoGroup">
<div class="infoHeadTile">
<div class="infoTitle">Sculpture Poems by Margot DeMarco</div>
</div>
<div class="infoBlurbTile">
<p>These poems are randomly generated object-focused sculptural scenes, continuously reshuffled. All language is drawn from a large bank of words written by the artist. Viewer can adjust the sentence structure of the poems, as well as how they look visually.</p>
</div>
</div>
</section>

<section class="uiPage uiPage--speed" aria-label="speed">
<div class="sliderRow">
<div class="ctrl">
<div class="labelRow"><div class="label">speed</div><div class="val" id="speedVal">7.0s</div></div>
<input id="speedSlider" type="range" min="0" max="1" step="0.001" value="0.595">
</div>
</div>
</section>

<section class="uiPage uiPage--contrast" aria-label="contrast">
<div class="sliderRow colorsBrightnessRow">
<div class="ctrl">
<div class="labelRow"><div class="label">background brightness</div><div class="val" id="bgBrightVal">50%</div></div>
<input id="bgBrightSlider" type="range" min="0" max="1" step="0.001" value="0.50">
</div>
<div class="ctrl">
<div class="labelRow"><div class="label">text brightness</div><div class="val" id="fgBrightVal">0%</div></div>
<input id="fgBrightSlider" type="range" min="0" max="1" step="0.001" value="0.00">
</div>
<div class="ctrl">
<div class="labelRow"><div class="label">card brightness</div><div class="val" id="bdBrightVal">100%</div></div>
<input id="bdBrightSlider" type="range" min="0" max="1" step="0.001" value="1.00">
</div>
</div>
</section>

<section class="uiPage uiPage--colors" aria-label="colors">
<div class="colorsPanelLayout">
<div class="colorsScopeCol" id="colorScopeRow" aria-label="color target">
<button id="scopeFgBtn" type="button" class="colorBtn colorScopeBtn" aria-pressed="false">text color</button>
<button id="scopeBgBtn" type="button" class="colorBtn colorScopeBtn" aria-pressed="false">background color</button>
<button id="scopeBdBtn" type="button" class="colorBtn colorScopeBtn" aria-pressed="true">card color</button>
</div>

<div class="colorsGridCol" id="colorsGridTile">
<div class="swatchGridPanel">
<div class="swatchRow swatchRow--all" id="allColorsRow"></div>
</div>
</div>

<div class="colorsBulkCol">
<button id="allOffBtn" type="button" class="colorBtn colorScopeBtn">all off</button>
<button id="allOnBtn" type="button" class="colorBtn colorScopeBtn">all on</button>
</div>
</div>
</section>
</div>
</div>

<div id="layoutStateStore" hidden aria-hidden="true">
<input id="sizeSlider" type="range" min="0" max="150" step="0.1" value="40">
<input id="ySlider" type="range" min="0" max="100" step="0.01" value="50">
<input id="widthSlider" type="range" min="0" max="100" step="0.01" value="40">
<input id="bdThickSlider" type="range" min="0" max="1" step="0.001" value="0.30">
<button id="bdToggleBtn" type="button" aria-pressed="true">on</button>
<span id="sizeVal">40%</span>
<span id="yVal">50%</span>
<span id="widthVal">40%</span>
<span id="bdThickVal">30%</span>
</div>

<div id="dockBottomHost" aria-label="buttons (bottom host)"></div>

</div>
</div>
</div>

<button id="menuToggleBtn" type="button" aria-label="toggle menu" aria-pressed="false">menu</button>

<script>
/* ================= Helpers ================= */
function uniq(arr){
const s = new Set();
for(const x of arr){
const v = String(x ?? "").trim().replace(/\s+/g," ");
const v2 = v.toLowerCase();
if(v2) s.add(v2);
}
return Array.from(s);
}
function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
function lerp(a,b,t){ return a + (b-a)*t; }

function shuffleInPlace(a){
for(let i=a.length-1;i>0;i--){
const j = (Math.random()*(i+1))|0;
[a[i],a[j]]=[a[j],a[i]];
}
return a;
}

function setViewportVars(){
const vv = window.visualViewport;
const h = (vv ? vv.height : window.innerHeight) * 0.01;
document.documentElement.style.setProperty("--vh", `${h}px`);
}

function getViewportSize(){
const vv = window.visualViewport;
return {
w: vv ? vv.width : window.innerWidth,
h: vv ? vv.height : window.innerHeight
};
}

function isIosDevice(){
const ua = navigator.userAgent || "";
const classicIos = /iPad|iPhone|iPod/.test(ua);
const iPadOsDesktopUa = (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
return classicIos || iPadOsDesktopUa;
}

function isPortraitViewport(){
const { w, h } = getViewportSize();
return h >= w;
}

function applyIosPortraitLoadSizing(){
if(!isIosDevice() || !isPortraitViewport()) return;
// iOS portrait default: larger phrase/card on first load.
sizeEl.value = String(clamp(Math.max(Number(sizeEl.value), 62), 0, 150));
widthEl.value = String(clamp(Math.max(Number(widthEl.value), 52), 0, 100));
}

function applyMobileViewerDefaults(){
const coarse = window.matchMedia("(pointer: coarse)").matches || (navigator.maxTouchPoints || 0) > 0;
if(!coarse) return;
// Keep the poem vertically centered on the full mobile viewport.
yEl.value = "50";
}

function parsePx(val){
const n = Number(String(val || "").replace("px","").trim());
return Number.isFinite(n) ? n : 0;
}
function getRootVarPx(name){
return parsePx(getComputedStyle(document.documentElement).getPropertyValue(name));
}
function getRootVarVw(name){
const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
if(v.endsWith("vw")) return Number(v.replace("vw","").trim());
const n = Number(v);
return Number.isFinite(n) ? n : null;
}

/* ================= Non-repeating shuffle bags ================= */
const BAGS = new Map();
function bagNext(key, pool){
const cleanPool = uniq(pool);
if(!cleanPool.length) return null;

const sig = cleanPool.join("âŸ");
const prev = BAGS.get(key);

if(!prev || prev._sig !== sig){
const arr = cleanPool.slice();
shuffleInPlace(arr);
BAGS.set(key, { arr, i: 0, _sig: sig });
}
const bag = BAGS.get(key);
if(bag.i >= bag.arr.length){
shuffleInPlace(bag.arr);
bag.i = 0;
}
const out = bag.arr[bag.i];
bag.i++;
return out;
}

const WORD_RECENCY = new Map();
function normToken(v){
return String(v || "").trim().replace(/\s+/g, " ").toLowerCase();
}
function getWordRecencyBucket(key, maxKeep){
const k = String(key || "");
const keep = Math.max(0, Math.floor(maxKeep || 0));
let bucket = WORD_RECENCY.get(k);
if(!bucket){
bucket = { max: keep, queue: [], seen: new Set() };
WORD_RECENCY.set(k, bucket);
}else if(bucket.max !== keep){
bucket.max = keep;
while(bucket.queue.length > bucket.max){
const old = bucket.queue.shift();
if(!bucket.queue.includes(old)) bucket.seen.delete(old);
}
}
return bucket;
}
function rememberWordRecent(key, token, maxKeep){
const t = normToken(token);
if(!t) return;
const bucket = getWordRecencyBucket(key, maxKeep);
if(bucket.max <= 0) return;
bucket.queue.push(t);
bucket.seen.add(t);
while(bucket.queue.length > bucket.max){
const old = bucket.queue.shift();
if(!bucket.queue.includes(old)) bucket.seen.delete(old);
}
}
function bagNextWithCooldown(key, pool, maxRecent){
const cleanPool = uniq(pool);
if(!cleanPool.length) return null;
const effectiveRecent = clamp(Math.floor(maxRecent || 0), 0, Math.max(0, cleanPool.length - 1));
if(effectiveRecent <= 0){
return bagNext(key, cleanPool);
}

const bucket = getWordRecencyBucket(key, effectiveRecent);
const maxTries = Math.max(cleanPool.length + 8, effectiveRecent + 8);
let fallback = null;
for(let i=0; i<maxTries; i++){
const candidate = bagNext(key, cleanPool);
if(candidate == null) continue;
fallback = candidate;
const cn = normToken(candidate);
if(!bucket.seen.has(cn)){
rememberWordRecent(key, candidate, effectiveRecent);
return candidate;
}
}
if(fallback != null){
rememberWordRecent(key, fallback, effectiveRecent);
return fallback;
}
return bagNext(key, cleanPool);
}

/* ================= Palettes ================= */
const PAL = {
circus: ["#FF6AD5","#FF8A00","#FF4D1A","#C85AE0","#FF007A"],
beachy: ["#BDE8FF","#8FB2CF","#CBE7FF","#445F86","#74A8E8"],
fleshy: ["#F7D59B","#F6B77D","#B7852F","#F7B59D","#E1780A"],
future: ["#9EDB00","#C86AD6","#F8C6A4","#B23A2B","#7FB1D9"],
retro: ["#DDE6B7","#00AEB0","#D85A10","#B10D33","#F6A623"],
earthy: ["#A7B827","#D79A16","#536A00","#6F8A1A","#806200"]
};

/* ================= Color helpers ================= */
function hexToRgb(hex){
const h = hex.replace("#","").trim();
const full = h.length === 3 ? h.split("").map(c=>c+c).join("") : h;
const n = parseInt(full,16);
return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
}
function rgbToHex(r,g,b){
const to = (v)=> v.toString(16).padStart(2,"0");
return "#" + to(r) + to(g) + to(b);
}
function rgbToHsl(r,g,b){
r/=255; g/=255; b/=255;
const max = Math.max(r,g,b), min = Math.min(r,g,b);
let h=0, s=0;
const l = (max+min)/2;
const d = max-min;
if(d !== 0){
s = d / (1 - Math.abs(2*l - 1));
switch(max){
case r: h = ((g-b)/d) % 6; break;
case g: h = (b-r)/d + 2; break;
case b: h = (r-g)/d + 4; break;
}
h *= 60;
if(h < 0) h += 360;
}
return {h, s, l};
}
function hslToRgb(h,s,l){
const c = (1 - Math.abs(2*l - 1)) * s;
const x = c * (1 - Math.abs(((h/60) % 2) - 1));
const m = l - c/2;
let rp=0,gp=0,bp=0;

if(0<=h && h<60){ rp=c; gp=x; bp=0; }
else if(60<=h && h<120){ rp=x; gp=c; bp=0; }
else if(120<=h && h<180){ rp=0; gp=c; bp=x; }
else if(180<=h && h<240){ rp=0; gp=x; bp=c; }
else if(240<=h && h<300){ rp=x; gp=0; bp=c; }
else { rp=c; gp=0; bp=x; }

return { r: Math.round((rp+m)*255), g: Math.round((gp+m)*255), b: Math.round((bp+m)*255) };
}
function setHsl(hex, h, s, l){
const out = hslToRgb(h, s, l);
return rgbToHex(out.r,out.g,out.b);
}

/* brightness dimmer */
function applyDimmer(hex, sliderVal){
const t = clamp(Number(sliderVal), 0, 1);
const {r,g,b} = hexToRgb(hex);
let {h,s,l} = rgbToHsl(r,g,b);

if(Math.abs(t - 0.5) < 1e-6) return hex;

if(t < 0.5){
const k = (0.5 - t) / 0.5;
const lMul = lerp(1.0, 0.42, k);
l = clamp(l * lMul, 0.08, 0.90);
s = clamp(s * lerp(1.0, 1.10, k), 0.18, 0.98);
}else{
const k = (t - 0.5) / 0.5;
l = clamp(l + (1 - l) * (0.33 * k), 0.08, 0.92);
s = clamp(s * lerp(1.0, 1.28, k), 0.18, 0.98);
}
return setHsl(hex, h, s, l);
}

function lightestHexFromPalette(palName){
const pal = PAL[palName] || [];
let best = pal[0] || "#ffffff";
let bestL = -1;
for(const hex of pal){
const {r,g,b} = hexToRgb(hex);
const {l} = rgbToHsl(r,g,b);
if(l > bestL){
bestL = l;
best = hex;
}
}
return best;
}
function darkestHexFromPalette(palName){
const pal = PAL[palName] || [];
let best = pal[0] || "#000000";
let bestL = 2;
for(const hex of pal){
const {r,g,b} = hexToRgb(hex);
const {l} = rgbToHsl(r,g,b);
if(l < bestL){
bestL = l;
best = hex;
}
}
return best;
}

/* ================= Controls ================= */
const PART_OPTS = ["description","object","person","action","location"];
const COLOR_OPTS = ["earthy","beachy","fleshy","retro","future","circus"];
const ALL_SWATCH_COLORS = uniq(Object.values(PAL).flat().map((hex)=> String(hex || "").trim().toLowerCase()));
const SLIDER_PALS = ["circus","beachy","fleshy","retro","future","earthy","circus","beachy"];
const palCycleIndex = {};

function initPaletteCycles(){
for(const name of COLOR_OPTS) palCycleIndex[name] = 0;
}
function paletteColor(name, offset=0){
const pal = PAL[name] || [];
if(!pal.length) return "#000000";
const idx = palCycleIndex[name] ?? 0;
return pal[(idx + offset) % pal.length];
}
function normHex(hex){
return String(hex || "").trim().toLowerCase();
}
function getBgLiveHex(){
// Prefer the actual rendered background; fall back to what we'd compute right now.
const live = normHex(current.bgLive);
if(live) return live;
return normHex(applyDimmer(current.bgBase, Number(bgBrightEl.value)));
}
function getFgLiveHex(){
const live = normHex(current.fgLive);
if(live) return live;
return normHex(applyDimmer(current.fgBase, Number(fgBrightEl.value)));
}
function paletteColorAvoid(palName, offset=0, avoidHex=""){
const pal = PAL[palName] || [];
if(!pal.length) return "#000000";
const avoid = normHex(avoidHex);
const idx = palCycleIndex[palName] ?? 0;
if(!avoid) return pal[(idx + offset) % pal.length];

for(let i=0; i<pal.length; i++){
const c = pal[(idx + offset + i) % pal.length];
if(normHex(c) !== avoid) return c;
}
return pal[(idx + offset) % pal.length];
}

function advancePaletteCycle(){
for(const name of COLOR_OPTS){
const pal = PAL[name] || [];
if(!pal.length) continue;
palCycleIndex[name] = (palCycleIndex[name] + 1) % pal.length;
}
}

/* ================= DOM refs ================= */
const phraseEl = document.getElementById("phraseText");
const uiWrapEl = document.getElementById("uiWrap");
const panelWrapEl = document.getElementById("panelWrap");
const panelInnerEl = document.getElementById("panelInner");
const cardEl = document.getElementById("card");

const speedEl = document.getElementById("speedSlider");
const bgBrightEl = document.getElementById("bgBrightSlider");
const fgBrightEl = document.getElementById("fgBrightSlider");
const bdBrightEl = document.getElementById("bdBrightSlider");

const sizeEl = document.getElementById("sizeSlider");
const yEl = document.getElementById("ySlider");
const widthEl = document.getElementById("widthSlider");

const bdThickEl = document.getElementById("bdThickSlider");
const bdToggleBtn = document.getElementById("bdToggleBtn");
const fsBtn = document.getElementById("fsBtn");
const prevPoemBtn = document.getElementById("prevPoemBtn");
const pausePoemBtn = document.getElementById("pausePoemBtn");
const nextPoemBtn = document.getElementById("nextPoemBtn");
const screenshotBtn = document.getElementById("screenshotBtn");
const lockCompositionBtn = document.getElementById("lockCompositionBtn");
const tabLanguageBtn = document.getElementById("tabLanguageBtn");
const tabContrastBtn = document.getElementById("tabContrastBtn");
const tabColorsBtn = document.getElementById("tabColorsBtn");
const tabSpeedBtn = document.getElementById("tabSpeedBtn");
const tabInfoBtn = document.getElementById("tabInfoBtn");
const dockPlaybackEl = document.getElementById("dockPlayback");
const scopeBgBtn = document.getElementById("scopeBgBtn");
const scopeFgBtn = document.getElementById("scopeFgBtn");
const scopeBdBtn = document.getElementById("scopeBdBtn");
const allOnBtn = document.getElementById("allOnBtn");
const allOffBtn = document.getElementById("allOffBtn");
const menuToggleBtn = document.getElementById("menuToggleBtn");
const dockEl = document.getElementById("dock");
const dockTopHostEl = document.getElementById("dockTopHost");
const dockBottomHostEl = document.getElementById("dockBottomHost");

const speedVal = document.getElementById("speedVal");
const bgBrightVal = document.getElementById("bgBrightVal");
const fgBrightVal = document.getElementById("fgBrightVal");
const bdBrightVal = document.getElementById("bdBrightVal");
const sizeVal = document.getElementById("sizeVal");
const yVal = document.getElementById("yVal");
const widthVal = document.getElementById("widthVal");
const bdThickVal = document.getElementById("bdThickVal");

const sliderEls = [
speedEl, bgBrightEl, fgBrightEl, bdBrightEl,
bdThickEl, sizeEl, yEl, widthEl
];

/* ================= Dock Constellation sizing ================= */
const dockControlBtns = [
dockPlaybackEl,
screenshotBtn, fsBtn, lockCompositionBtn,
tabLanguageBtn, tabContrastBtn, tabColorsBtn, tabSpeedBtn, tabInfoBtn
].filter(Boolean);
const dockControlById = new Map(dockControlBtns.map((btn)=>[btn.id, btn]));
let dockActiveBtnId = "";
let dockHoverBtnId = "";
let dockLayoutRaf = 0;
const DOCK_LAYOUT_MARGIN = 8;
const DOCK_LAYOUT_GAP = 6;
const DOCK_LAYOUT_OBS_PAD = 8;
const DOCK_GRID_MIN_STEP_X = 12;
const DOCK_GRID_MIN_STEP_Y = 10;
const DOCK_GRID_MAX_RING = 64;
const DOCK_PANEL_MAX_RING = 96;
const DOCK_SUBMENU_Y_SHIFT = 20;
const DOCK_MENU_SPACER_EXTRA = 28;
const DOCK_SUBMENU_IDS = new Set([
"tabLanguageBtn",
"tabContrastBtn",
"tabColorsBtn",
"tabSpeedBtn",
"tabInfoBtn",
"screenshotBtn",
"fsBtn"
]);

function shouldUseBandedMobileLayout(vw, vh){
const w = Number.isFinite(vw) ? vw : (window.innerWidth || 0);
const h = Number.isFinite(vh) ? vh : (window.innerHeight || 0);
const coarse = !!(window.matchMedia && window.matchMedia("(pointer: coarse)").matches);
const touch = (navigator.maxTouchPoints || 0) > 0;
const maxSide = Math.max(w, h);
return (coarse || touch) && maxSide <= 1400;
}

function inflateRect(r, pad){
return {
left: r.left - pad,
top: r.top - pad,
right: r.right + pad,
bottom: r.bottom + pad
};
}

function makeDockRect(x, y, w, h, tipTop = 0){
return {
left: x,
top: y - tipTop,
right: x + w,
bottom: y + h
};
}

function measureDockControl(btn){
const rect = btn.getBoundingClientRect();
// Use layout box dimensions so measurements stay stable while CSS transforms animate.
const w = Math.max(20, Math.ceil(btn.offsetWidth || rect.width || 0));
const h = Math.max(20, Math.ceil(btn.offsetHeight || rect.height || 0));
const fontPx = parseFloat(getComputedStyle(btn).fontSize) || 12;
const hasTip = !!(btn.dataset && btn.dataset.tip);
const hasChildTips = (btn.id === "dockPlayback");
// Reserve tooltip space in layout at all times so hover text never collides.
const tipTop = (hasTip || hasChildTips) ? Math.ceil((fontPx * 0.9) + 10) : 0;
return { w, h, tipTop };
}

function getDockLayoutOrder(){
const priority = {
tabLanguageBtn: 10,
tabColorsBtn: 20,
tabInfoBtn: 30,
lockCompositionBtn: 40,
tabSpeedBtn: 50,
dockPlayback: 60,
tabContrastBtn: 70,
fsBtn: 80,
screenshotBtn: 90
};
return dockControlBtns
.map((btn)=>btn.id)
.sort((a, b)=>(priority[a] ?? 999) - (priority[b] ?? 999));
}

function getDockObstacles(){
const obstacles = [];
const safe = getSceneSafeRect();
if(safe){
obstacles.push(inflateRect(safe, DOCK_LAYOUT_OBS_PAD));
}
if(menuToggleBtn){
const mr = menuToggleBtn.getBoundingClientRect();
if(mr.width > 0 && mr.height > 0){
obstacles.push(inflateRect(mr, DOCK_LAYOUT_GAP));
}
}
return obstacles;
}

function fitsDockRect(rect, vw, vh, obstacles, placed){
if(rect.left < DOCK_LAYOUT_MARGIN) return false;
if(rect.top < DOCK_LAYOUT_MARGIN) return false;
if(rect.right > (vw - DOCK_LAYOUT_MARGIN)) return false;
if(rect.bottom > (vh - DOCK_LAYOUT_MARGIN)) return false;
for(const r of obstacles){
if(rectsOverlap(rect, r, 0)) return false;
}
for(const r of placed){
if(rectsOverlap(rect, r, DOCK_LAYOUT_GAP)) return false;
}
return true;
}

function buildDockCandidates(maxRing){
const out = [];
for(let row = -maxRing; row <= maxRing; row++){
for(let col = -maxRing; col <= maxRing; col++){
if(row === 0 && col === 0) continue;
const ring = Math.max(Math.abs(row), Math.abs(col));
if(ring > maxRing) continue;
// Compact square around menu with strong bias to rows above menu.
let score = (ring * 8) + (Math.abs(col) * 0.6) + (Math.abs(row) * 0.4);
if(row > 0) score += 100 + (row * 14);
out.push({ row, col, score });
}
}
out.sort((a,b)=> a.score - b.score);
return out;
}

function buildPanelCandidates(maxRing){
const out = [];
const seen = new Set();
const rows = [-4,-5,-3,-6,-2,-7,-1,-8,0,1,2];
const cols = [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6];
for(const row of rows){
for(const col of cols){
if(row === 0 && col === 0) continue;
const key = `${row},${col}`;
if(seen.has(key)) continue;
seen.add(key);
out.push({ row, col });
}
}
for(const c of buildDockCandidates(maxRing)){
const key = `${c.row},${c.col}`;
if(seen.has(key)) continue;
seen.add(key);
out.push({ row: c.row, col: c.col });
}
return out;
}

function shouldUsePanelTileLayout(vw, vh, page){
const activePage = String(page || document.body.dataset.uiPage || "none");
if(activePage === "none") return false;
return true;
}

function getActivePanelTileEls(page){
if(!panelInnerEl) return [];
const safePage = String(page || "none");
if(safePage === "language"){
return Array.from(panelInnerEl.querySelectorAll(".uiPage--language #partsRow .ssBtn"));
}
if(safePage === "info"){
return Array.from(panelInnerEl.querySelectorAll(".uiPage--info .infoGroup"));
}
if(safePage === "contrast"){
return Array.from(panelInnerEl.querySelectorAll(".uiPage--contrast .ctrl"));
}
if(safePage === "colors"){
return [
panelInnerEl.querySelector("#colorsGridTile"),
panelInnerEl.querySelector("#scopeFgBtn"),
panelInnerEl.querySelector("#scopeBgBtn"),
panelInnerEl.querySelector("#scopeBdBtn"),
panelInnerEl.querySelector("#allOffBtn"),
panelInnerEl.querySelector("#allOnBtn")
].filter(Boolean);
}
if(safePage === "speed"){
return Array.from(panelInnerEl.querySelectorAll(".uiPage--speed .ctrl"));
}
return [];
}

function clearPanelFloatingTiles(){
if(!panelWrapEl || !panelInnerEl) return;
panelWrapEl.classList.remove("panel-tiles");
panelWrapEl.style.left = "";
panelWrapEl.style.top = "";
panelWrapEl.style.bottom = "";
panelWrapEl.style.transform = "";
panelWrapEl.style.width = "";
panelWrapEl.style.height = "";
panelInnerEl.querySelectorAll(".panelTileFloat").forEach((el)=>{
el.classList.remove("panelTileFloat");
el.style.left = "";
el.style.top = "";
el.style.width = "";
el.style.height = "";
el.style.opacity = "";
el.style.pointerEvents = "";
});
}

function getPanelTopBounds(vh, blockH, panelTopLimit){
const { w: vw } = getViewportSize();
const safe = getSceneSafeRect();
if(shouldUseBandedMobileLayout(vw, vh) && safe){
const minTopBand = DOCK_LAYOUT_MARGIN;
const topZoneBottom = Math.max(minTopBand, Math.round(safe.top - UI_SAFE_GAP_PX - 6));
const maxTopBand = Math.max(minTopBand, topZoneBottom - blockH);
if(maxTopBand >= minTopBand){
return { minTop: minTopBand, maxTop: maxTopBand };
}
}
const safeBottom = safe ? safe.bottom : Math.round(vh * 0.40);
const minTop = Math.max(
DOCK_LAYOUT_MARGIN,
Math.round(safeBottom + UI_SAFE_GAP_PX + 8)
);
const topLimit = Number.isFinite(panelTopLimit)
? panelTopLimit
: (vh - DOCK_LAYOUT_MARGIN);
const maxTop = Math.max(minTop, Math.round(topLimit - blockH - 6));
return { minTop, maxTop };
}

function buildPanelFlowRows(items, maxRowW, gapX){
const rows = [];
let row = [];
let rowW = 0;
let rowH = 0;

const flush = ()=>{
if(!row.length) return;
rows.push({ items: row, rowW, rowH });
row = [];
rowW = 0;
rowH = 0;
};

for(const item of items){
const w = item.measure.w;
const h = item.measure.h;
const nextW = row.length ? (rowW + gapX + w) : w;
if(row.length && nextW > maxRowW){
flush();
}
row.push(item);
rowW = row.length === 1 ? w : (rowW + gapX + w);
rowH = Math.max(rowH, h);
}
flush();
return rows;
}

function tryPlacePanelFlowCluster(measured, vw, vh, obstacles, placed, opts = {}){
if(!measured.length) return false;
const preferBelow = !!opts.preferBelow;
const gapX = Math.max(6, Math.round(opts.gapX || 8));
const gapY = Math.max(6, Math.round(opts.gapY || 8));
const maxAvailW = Math.max(120, vw - (DOCK_LAYOUT_MARGIN * 2));
const centerX = Number.isFinite(opts.centerX) ? opts.centerX : (vw * 0.5);
const requestedRowW = Number.isFinite(opts.maxRowW) ? opts.maxRowW : maxAvailW;
const maxRowW = clamp(Math.round(requestedRowW), 120, maxAvailW);

const rows = buildPanelFlowRows(measured, maxRowW, gapX);
if(!rows.length) return false;

const blockW = Math.max(...rows.map((r)=>r.rowW));
const blockH = rows.reduce((sum, r)=>sum + r.rowH, 0) + (gapY * (rows.length - 1));
const { minTop, maxTop } = getPanelTopBounds(vh, blockH, opts.panelTopLimit);
const minX = DOCK_LAYOUT_MARGIN;
const maxX = Math.max(minX, vw - DOCK_LAYOUT_MARGIN - blockW);
const xShifts = [0, -12, 12, -24, 24, -36, 36];
const desiredTop = preferBelow
? minTop
: clamp(
Math.round(minTop + ((maxTop - minTop) * 0.45)),
minTop,
maxTop
);
const yCandidates = preferBelow
? Array.from(new Set([
minTop,
clamp(minTop + 8, minTop, maxTop),
clamp(minTop + 16, minTop, maxTop),
maxTop
]))
: Array.from(new Set([
desiredTop,
minTop,
maxTop,
clamp(desiredTop - 10, minTop, maxTop),
clamp(desiredTop + 10, minTop, maxTop)
]));

for(const yBase of yCandidates){
for(const sx of xShifts){
const blockX = clamp(Math.round(centerX - (blockW * 0.5) + sx), minX, maxX);
const blockY = clamp(Math.round(yBase), minTop, maxTop);
const local = [];
const placements = [];
let y = blockY;
let ok = true;

for(const row of rows){
let x = blockX + Math.round((blockW - row.rowW) * 0.5);
for(const item of row.items){
const top = y + Math.round((row.rowH - item.measure.h) * 0.5);
const rect = makeDockRect(x, top, item.measure.w, item.measure.h, 0);
if(!fitsDockRect(rect, vw, vh, obstacles, placed.concat(local))){
ok = false;
break;
}
local.push(rect);
placements.push({ item, x, y: top, rect });
x += item.measure.w + gapX;
}
if(!ok) break;
y += row.rowH + gapY;
}
if(!ok) continue;

for(const p of placements){
p.item.el.style.left = `${Math.round(p.x)}px`;
p.item.el.style.top = `${Math.round(p.y)}px`;
obstacles.push(p.rect);
placed.push(p.rect);
}
return true;
}
}
return false;
}

function tryPlaceColorsPanelCluster(measured, vw, vh, obstacles, placed, opts = {}){
const byId = new Map(measured.map((item)=>[String(item.el && item.el.id || ""), item]));
const grid = byId.get("colorsGridTile");
const leftBtns = ["scopeFgBtn","scopeBgBtn","scopeBdBtn"]
.map((id)=>byId.get(id))
.filter(Boolean);
const rightBtns = ["allOffBtn","allOnBtn"]
.map((id)=>byId.get(id))
.filter(Boolean);

if(!grid || leftBtns.length !== 3 || rightBtns.length !== 2) return false;

function commitIfFits(placements){
const local = [];
for(const p of placements){
const rect = makeDockRect(p.x, p.y, p.item.measure.w, p.item.measure.h, 0);
if(!fitsDockRect(rect, vw, vh, obstacles, placed.concat(local))){
return false;
}
local.push(rect);
p.rect = rect;
}
for(const p of placements){
p.item.el.style.left = `${Math.round(p.x)}px`;
p.item.el.style.top = `${Math.round(p.y)}px`;
obstacles.push(p.rect);
placed.push(p.rect);
}
return true;
}

const rowGap = Math.max(6, DOCK_LAYOUT_GAP);
const colGap = 12;

const leftW = Math.max(...leftBtns.map((item)=>item.measure.w));
const leftH = leftBtns.reduce((sum, item)=>sum + item.measure.h, 0) + (rowGap * (leftBtns.length - 1));
const rightW = Math.max(...rightBtns.map((item)=>item.measure.w));
const rightH = rightBtns.reduce((sum, item)=>sum + item.measure.h, 0) + (rowGap * (rightBtns.length - 1));
const gridW = grid.measure.w;
const gridH = grid.measure.h;
const maxAvailW = vw - (DOCK_LAYOUT_MARGIN * 2);

const centerX = Number.isFinite(opts.centerX) ? opts.centerX : (vw * 0.5);
const xShifts = [0, -16, 16, -32, 32, -48, 48];

// layout A: classic left stack + swatch grid + right stack (all shift together).
{
const blockW = leftW + colGap + gridW + colGap + rightW;
const blockH = Math.max(leftH, gridH, rightH);
if(blockW <= maxAvailW){
const { minTop, maxTop } = getPanelTopBounds(vh, blockH, opts.panelTopLimit);
const minX = DOCK_LAYOUT_MARGIN;
const maxX = Math.max(minX, vw - DOCK_LAYOUT_MARGIN - blockW);
const desiredTop = clamp(
Math.round(minTop + ((maxTop - minTop) * 0.42)),
minTop,
maxTop
);
const yCandidates = Array.from(new Set([
desiredTop,
minTop,
maxTop,
clamp(desiredTop - 8, minTop, maxTop),
clamp(desiredTop + 8, minTop, maxTop)
]));
for(const topBase of yCandidates){
for(const sx of xShifts){
const leftX = clamp(Math.round(centerX - (blockW * 0.5) + sx), minX, maxX);
const topY = clamp(Math.round(topBase), minTop, maxTop);
const gridX = leftX + leftW + colGap;
const rightX = gridX + gridW + colGap;
const leftStartY = Math.round(topY + ((blockH - leftH) * 0.5));
const gridY = Math.round(topY + ((blockH - gridH) * 0.5));
const rightStartY = Math.round(topY + ((blockH - rightH) * 0.5));
const placements = [{ item: grid, x: gridX, y: gridY }];
let yL = leftStartY;
for(const item of leftBtns){
const x = leftX + Math.round((leftW - item.measure.w) * 0.5);
placements.push({ item, x, y: yL });
yL += item.measure.h + rowGap;
}
let yR = rightStartY;
for(const item of rightBtns){
const x = rightX + Math.round((rightW - item.measure.w) * 0.5);
placements.push({ item, x, y: yR });
yR += item.measure.h + rowGap;
}
if(commitIfFits(placements)) return true;
}
}
}
}

// layout B: narrow fallback, still grouped tightly and moving as one bundle.
{
const leftRowW = leftBtns.reduce((sum, item)=>sum + item.measure.w, 0) + (rowGap * (leftBtns.length - 1));
const rightRowW = rightBtns.reduce((sum, item)=>sum + item.measure.w, 0) + (rowGap * (rightBtns.length - 1));
const leftRowH = Math.max(...leftBtns.map((item)=>item.measure.h));
const rightRowH = Math.max(...rightBtns.map((item)=>item.measure.h));
const blockW = Math.max(gridW, leftRowW, rightRowW);
const blockH = gridH + rowGap + leftRowH + rowGap + rightRowH;
if(blockW <= maxAvailW){
const { minTop, maxTop } = getPanelTopBounds(vh, blockH, opts.panelTopLimit);
const minX = DOCK_LAYOUT_MARGIN;
const maxX = Math.max(minX, vw - DOCK_LAYOUT_MARGIN - blockW);
const desiredTop = clamp(
Math.round(minTop + ((maxTop - minTop) * 0.38)),
minTop,
maxTop
);
const yCandidates = Array.from(new Set([
desiredTop,
minTop,
clamp(minTop + 12, minTop, maxTop),
maxTop
]));
for(const topBase of yCandidates){
for(const sx of xShifts){
const blockX = clamp(Math.round(centerX - (blockW * 0.5) + sx), minX, maxX);
const topY = clamp(Math.round(topBase), minTop, maxTop);
const gridX = blockX + Math.round((blockW - gridW) * 0.5);
const leftY = topY + gridH + rowGap;
const rightY = leftY + leftRowH + rowGap;
const leftStartX = blockX + Math.round((blockW - leftRowW) * 0.5);
const rightStartX = blockX + Math.round((blockW - rightRowW) * 0.5);
const placements = [{ item: grid, x: gridX, y: topY }];
let xL = leftStartX;
for(const item of leftBtns){
placements.push({ item, x: xL, y: leftY + Math.round((leftRowH - item.measure.h) * 0.5) });
xL += item.measure.w + rowGap;
}
let xR = rightStartX;
for(const item of rightBtns){
placements.push({ item, x: xR, y: rightY + Math.round((rightRowH - item.measure.h) * 0.5) });
xR += item.measure.w + rowGap;
}
if(commitIfFits(placements)) return true;
}
}
}
}

return false;
}

function placeOpenPanelTiles(anchorX, anchorY, vw, vh, obstacles, placed, opts = {}){
if(!panelWrapEl || !panelInnerEl) return false;
const page = String(document.body.dataset.uiPage || "none");
const centerX = Number.isFinite(opts.centerX) ? opts.centerX : (vw * 0.5);
const panelTopLimit = Number.isFinite(opts.panelTopLimit) ? opts.panelTopLimit : null;
const tiles = getActivePanelTileEls(page);
if(!tiles.length) return false;

panelWrapEl.classList.add("panel-tiles");
panelWrapEl.style.left = "0px";
panelWrapEl.style.top = "0px";
panelWrapEl.style.bottom = "auto";
panelWrapEl.style.transform = "none";

const measured = [];
tiles.forEach((el, idx)=>{
if(!el) return;
const r = el.getBoundingClientRect();
const w = Math.max(44, Math.ceil(r.width || 0));
const h = Math.max(28, Math.ceil(r.height || 0));
if(w <= 0 || h <= 0) return;
measured.push({
el,
idx,
measure: { w, h, tipTop: 0 }
});
});
if(!measured.length) return false;

measured.forEach((item)=>{
item.el.classList.add("panelTileFloat");
item.el.style.width = `${item.measure.w}px`;
item.el.style.height = `${item.measure.h}px`;
item.el.style.opacity = "1";
item.el.style.pointerEvents = "auto";
});

if(page === "colors"){
const clustered = tryPlaceColorsPanelCluster(
measured,
vw,
vh,
obstacles,
placed,
{
centerX,
panelTopLimit
}
);
if(clustered) return true;
}

const flowMaxW = (()=>{
if(page === "language") return Math.min(vw - (DOCK_LAYOUT_MARGIN * 2), 860);
if(page === "contrast") return vw - (DOCK_LAYOUT_MARGIN * 2);
if(page === "speed" || page === "info"){
return Math.max(...measured.map((item)=>item.measure.w));
}
return vw - (DOCK_LAYOUT_MARGIN * 2);
})();
const flowPlaced = tryPlacePanelFlowCluster(
measured,
vw,
vh,
obstacles,
placed,
{
centerX,
panelTopLimit,
maxRowW: flowMaxW,
preferBelow: page === "info",
gapX: 8,
gapY: 8
}
);
if(flowPlaced) return true;

const ordered = measured.slice().sort((a, b)=>{
const areaA = a.measure.w * a.measure.h;
const areaB = b.measure.w * b.measure.h;
if(areaA !== areaB) return areaB - areaA;
return a.idx - b.idx;
});

let baseY = Math.round(anchorY - 12);
if(Number.isFinite(panelTopLimit)){
baseY = Math.min(baseY, Math.round(panelTopLimit - 24));
}
for(const item of ordered){
let spot = findDockSpot(
`__panel_tile_${item.idx}`,
item.measure,
centerX,
baseY,
vw,
vh,
obstacles,
placed,
{
stepX: Math.max(10, Math.floor(DOCK_GRID_MIN_STEP_X * 0.9)),
stepY: Math.max(8, Math.floor(DOCK_GRID_MIN_STEP_Y * 0.9)),
maxRing: DOCK_PANEL_MAX_RING
}
);

if(!spot || !spot.rect || !fitsDockRect(spot.rect, vw, vh, obstacles, placed)){
spot = null;
const fallbackCandidates = buildPanelCandidates(DOCK_PANEL_MAX_RING + 28);
for(const c of fallbackCandidates){
const cx = centerX + (c.col * DOCK_GRID_MIN_STEP_X);
const cy = baseY + (c.row * DOCK_GRID_MIN_STEP_Y);
const x = Math.round(cx - (item.measure.w * 0.5));
const y = Math.round(cy - (item.measure.h * 0.5));
const rect = makeDockRect(x, y, item.measure.w, item.measure.h, 0);
if(!fitsDockRect(rect, vw, vh, obstacles, placed)) continue;
spot = { x, y, rect };
break;
}
}

if(!spot || !spot.rect || !fitsDockRect(spot.rect, vw, vh, obstacles, placed)){
// Keep strict no-overlap behavior on cramped screens.
item.el.style.opacity = "0";
item.el.style.pointerEvents = "none";
continue;
}

item.el.style.left = `${Math.round(spot.x)}px`;
item.el.style.top = `${Math.round(spot.y)}px`;
obstacles.push(spot.rect);
placed.push(spot.rect);
}
return true;
}

function findDockSpot(btnId, measure, anchorX, anchorY, vw, vh, obstacles, placed, layoutCfg){
const localAnchorY = anchorY + (DOCK_SUBMENU_IDS.has(btnId) ? DOCK_SUBMENU_Y_SHIFT : 0);
const stepX = Math.max(DOCK_GRID_MIN_STEP_X, Math.round(layoutCfg?.stepX || DOCK_GRID_MIN_STEP_X));
const stepY = Math.max(DOCK_GRID_MIN_STEP_Y, Math.round(layoutCfg?.stepY || DOCK_GRID_MIN_STEP_Y));
const maxRing = Math.max(6, Math.round(layoutCfg?.maxRing || DOCK_GRID_MAX_RING));
const candidates = (btnId === "__panel__")
? buildPanelCandidates(Math.max(maxRing, DOCK_PANEL_MAX_RING))
: buildDockCandidates(maxRing);

for(const c of candidates){
const cx = anchorX + (c.col * stepX);
const cy = localAnchorY + (c.row * stepY);
const x = Math.round(cx - (measure.w * 0.5));
const y = Math.round(cy - (measure.h * 0.5));
const rect = makeDockRect(x, y, measure.w, measure.h, measure.tipTop);
if(fitsDockRect(rect, vw, vh, obstacles, placed)){
return { x, y, rect };
}
}

// Exhaustive near-anchor scan before hard fallback.
const minX = DOCK_LAYOUT_MARGIN;
const maxX = Math.max(minX, vw - DOCK_LAYOUT_MARGIN - measure.w);
const minY = DOCK_LAYOUT_MARGIN + measure.tipTop;
const maxY = Math.max(minY, vh - DOCK_LAYOUT_MARGIN - measure.h);
const scanStepX = Math.max(6, Math.floor(stepX * 0.9));
const scanStepY = Math.max(6, Math.floor(stepY * 0.9));
const centerX = clamp(Math.round(anchorX - (measure.w * 0.5)), minX, maxX);

for(let y = maxY; y >= minY; y -= scanStepY){
const tried = new Set();
const xs = [centerX];
for(let d = scanStepX; d <= (vw + stepX); d += scanStepX){
xs.push(centerX - d, centerX + d);
if((centerX - d) <= minX && (centerX + d) >= maxX) break;
}
for(const xRaw of xs){
const x = clamp(Math.round(xRaw), minX, maxX);
if(tried.has(x)) continue;
tried.add(x);
const rect = makeDockRect(x, y, measure.w, measure.h, measure.tipTop);
if(fitsDockRect(rect, vw, vh, obstacles, placed)){
return { x, y, rect };
}
}
}

// Final fallback: pin near menu center, above the menu whenever possible.
const fallbackY = clamp(
Math.round(localAnchorY - (stepY * 2) - (measure.h * 0.5)),
DOCK_LAYOUT_MARGIN + measure.tipTop,
vh - DOCK_LAYOUT_MARGIN - measure.h
);
const fallbackX = clamp(
Math.round(anchorX - (measure.w * 0.5)),
DOCK_LAYOUT_MARGIN,
Math.max(DOCK_LAYOUT_MARGIN, vw - DOCK_LAYOUT_MARGIN - measure.w)
);
const fallbackRect = makeDockRect(fallbackX, fallbackY, measure.w, measure.h, measure.tipTop);
return { x: fallbackX, y: fallbackY, rect: fallbackRect };
}

function placePresetDockCluster(anchorX, anchorY, vw, vh, obstacles, placed, measuresById){
const placedIds = new Set();
const getM = (id)=> measuresById.get(id) || measureDockControl(dockControlById.get(id));
const menuRect = menuToggleBtn ? menuToggleBtn.getBoundingClientRect() : null;
const menuW = Math.max(40, Math.ceil(menuRect ? menuRect.width : 68));
const menuH = Math.max(24, Math.ceil(menuRect ? menuRect.height : 32));
const g = DOCK_LAYOUT_GAP;
const minX = DOCK_LAYOUT_MARGIN;
const maxY = vh - DOCK_LAYOUT_MARGIN;

function buildRow(items){
const present = items
.map((item)=>{
if(!item || !item.id){
return {
id: "",
w: Math.max(0, Math.ceil(item && item.w ? item.w : 0)),
h: Math.max(0, Math.ceil(item && item.h ? item.h : 0)),
tipTop: 0
};
}
const btn = dockControlById.get(item.id);
if(!btn) return null;
const m = getM(item.id);
if(!m) return null;
return { id: item.id, w: m.w, h: m.h, tipTop: m.tipTop || 0 };
})
.filter(Boolean);

const rowW = present.reduce((sum, item)=> sum + item.w, 0) + (Math.max(0, present.length - 1) * g);
const maxHalfH = present.reduce((max, item)=> Math.max(max, item.h * 0.5), 0);
const hasTips = present.some((item)=> item.tipTop > 0);
// Keep rows compact but leave a little headroom for hover labels.
const up = maxHalfH + (hasTips ? 8 : 0);
const down = maxHalfH;
return { items: present, rowW, up, down, h: up + down };
}

// Target stack (top -> bottom):
// language | colors | info
// lock | speed | playback | contrast
// full screen | menu | screenshot
const row1 = buildRow([
{ id: "tabLanguageBtn" },
{ id: "tabColorsBtn" },
{ id: "tabInfoBtn" }
]);
const row2 = buildRow([
{ id: "lockCompositionBtn" },
{ id: "tabSpeedBtn" },
{ id: "dockPlayback" },
{ id: "tabContrastBtn" }
]);
const row3 = buildRow([
{ id: "fsBtn" },
{ id: "", w: menuW + DOCK_MENU_SPACER_EXTRA, h: menuH },
{ id: "screenshotBtn" }
]);

const rows = [row1, row2, row3];
const rowGapOptions = [4, 6, 8, 10, 12];

function tryPreset(rowGap, shiftX = 0, shiftY = 0){
const localRects = [];
const localPos = [];

const row3CenterY = anchorY + shiftY;
const row2CenterY = row3CenterY - (row2.down + rowGap + row3.up);
const row1CenterY = row2CenterY - (row1.down + rowGap + row2.up);
const centers = [row1CenterY, row2CenterY, row3CenterY];

// Keep whole stack visible before per-item checks.
const topMost = row1CenterY - row1.up;
const bottomMost = row3CenterY + row3.down;
if(topMost < DOCK_LAYOUT_MARGIN || bottomMost > maxY){
return null;
}

for(let r = 0; r < rows.length; r++){
const row = rows[r];
const centerY = centers[r];
if(!row || !row.items.length) continue;

const centerX = anchorX + shiftX;
const maxX = Math.max(minX, vw - DOCK_LAYOUT_MARGIN - row.rowW);
const startX = clamp(Math.round(centerX - (row.rowW * 0.5)), minX, maxX);

let x = startX;
for(const item of row.items){
if(!item.id){
x += item.w + g;
continue;
}
const y = Math.round(centerY - (item.h * 0.5));
// In preset mode, reserve body area (not tooltip area) to keep stack compact/clean.
const rect = makeDockRect(Math.round(x), y, item.w, item.h, 0);
if(!fitsDockRect(rect, vw, vh, obstacles, placed.concat(localRects))){
return null;
}
localRects.push(rect);
localPos.push({ id: item.id, x: Math.round(x), y });
x += item.w + g;
}
}

return { localRects, localPos };
}

let found = null;
const shiftXOptions = [0, -14, 14, -28, 28, -42, 42, -56, 56];
const shiftYOptions = [0, 8, 14, -8, 20, -14];
for(const gap of rowGapOptions){
for(const sx of shiftXOptions){
for(const sy of shiftYOptions){
found = tryPreset(gap, sx, sy);
if(found) break;
}
if(found) break;
}
if(found) break;
}
if(!found) return placedIds;

for(const pos of found.localPos){
const btn = dockControlById.get(pos.id);
if(!btn) continue;
btn.classList.add("dockObject");
btn.style.left = `${pos.x}px`;
btn.style.top = `${pos.y}px`;
placedIds.add(pos.id);
}
for(const rect of found.localRects){
placed.push(rect);
}
return placedIds;
}

function placeBandedDockRows(vw, vh, obstacles, placed, measuresById){
const placedIds = new Set();
const getM = (id)=> measuresById.get(id) || measureDockControl(dockControlById.get(id));
const menuRect = menuToggleBtn ? menuToggleBtn.getBoundingClientRect() : null;
const menuW = Math.max(40, Math.ceil(menuRect ? menuRect.width : 68));
const menuH = Math.max(24, Math.ceil(menuRect ? menuRect.height : 32));
const gapX = DOCK_LAYOUT_GAP;
const safe = getSceneSafeRect();
const minTop = safe
? Math.max(DOCK_LAYOUT_MARGIN, Math.round(safe.bottom + UI_SAFE_GAP_PX + 6))
: Math.round(vh * 0.58);

function buildRow(items){
const present = items
.map((item)=>{
if(!item || !item.id){
return {
id: "",
w: Math.max(0, Math.ceil(item && item.w ? item.w : 0)),
h: Math.max(0, Math.ceil(item && item.h ? item.h : 0)),
tipTop: 0
};
}
const btn = dockControlById.get(item.id);
if(!btn) return null;
const m = getM(item.id);
if(!m) return null;
return { id: item.id, w: m.w, h: m.h, tipTop: m.tipTop || 0 };
})
.filter(Boolean);
const rowW = present.reduce((sum, item)=> sum + item.w, 0) + (Math.max(0, present.length - 1) * gapX);
const maxHalfH = present.reduce((max, item)=> Math.max(max, item.h * 0.5), 0);
const hasTips = present.some((item)=> item.tipTop > 0);
const up = maxHalfH + (hasTips ? 8 : 0);
const down = maxHalfH;
return { items: present, rowW, up, down, h: up + down };
}

const row1 = buildRow([
{ id: "tabLanguageBtn" },
{ id: "tabColorsBtn" },
{ id: "tabInfoBtn" }
]);
const row2 = buildRow([
{ id: "lockCompositionBtn" },
{ id: "tabSpeedBtn" },
{ id: "dockPlayback" },
{ id: "tabContrastBtn" }
]);
const row3 = buildRow([
{ id: "fsBtn" },
{ id: "", w: menuW + DOCK_MENU_SPACER_EXTRA, h: menuH },
{ id: "screenshotBtn" }
]);

const rows = [row1, row2, row3];
const rowGapOptions = [4, 3, 2];
const xShiftOptions = [0, -10, 10, -20, 20, -30, 30];

function tryRows(rowGap, shiftX = 0){
const localRects = [];
const localPos = [];
const anchorX = clamp(Math.round((menuRect ? (menuRect.left + (menuRect.width * 0.5)) : (vw * 0.5)) + shiftX), DOCK_LAYOUT_MARGIN, vw - DOCK_LAYOUT_MARGIN);

const row3TargetCenter = menuRect
? Math.round(menuRect.top - 6 - row3.down)
: Math.round(vh - DOCK_LAYOUT_MARGIN - row3.down - 36);
const row3MinCenter = Math.round(minTop + row1.h + rowGap + row2.h + rowGap + row3.up);
const row3MaxCenter = Math.round(vh - DOCK_LAYOUT_MARGIN - row3.down);
if(row3MinCenter > row3MaxCenter) return null;

const row3Center = clamp(row3TargetCenter, row3MinCenter, row3MaxCenter);
const row2Center = row3Center - (row2.down + rowGap + row3.up);
const row1Center = row2Center - (row1.down + rowGap + row2.up);
const centers = [row1Center, row2Center, row3Center];

for(let r = 0; r < rows.length; r++){
const row = rows[r];
const centerY = centers[r];
const minX = DOCK_LAYOUT_MARGIN;
const maxX = Math.max(minX, vw - DOCK_LAYOUT_MARGIN - row.rowW);
const startX = clamp(Math.round(anchorX - (row.rowW * 0.5)), minX, maxX);
let x = startX;

for(const item of row.items){
if(!item.id){
x += item.w + gapX;
continue;
}
const y = Math.round(centerY - (item.h * 0.5));
const rect = makeDockRect(Math.round(x), y, item.w, item.h, 0);
if(!fitsDockRect(rect, vw, vh, obstacles, placed.concat(localRects))){
return null;
}
localRects.push(rect);
localPos.push({ id: item.id, x: Math.round(x), y });
x += item.w + gapX;
}
}
return { localRects, localPos };
}

let found = null;
for(const gap of rowGapOptions){
for(const sx of xShiftOptions){
found = tryRows(gap, sx);
if(found) break;
}
if(found) break;
}
if(!found) return placedIds;

for(const pos of found.localPos){
const btn = dockControlById.get(pos.id);
if(!btn) continue;
btn.classList.add("dockObject");
btn.style.left = `${pos.x}px`;
btn.style.top = `${pos.y}px`;
placedIds.add(pos.id);
}
for(const rect of found.localRects){
placed.push(rect);
}
return placedIds;
}

function placeOpenDockCluster(anchorX, anchorY, vw, vh, obstacles, placed, measuresById, panelMeasure){
const placedIds = new Set();
const activePage = String(document.body.dataset.uiPage || "none");
const getM = (id)=> measuresById.get(id) || measureDockControl(dockControlById.get(id));
const menuRect = menuToggleBtn ? menuToggleBtn.getBoundingClientRect() : null;
const menuW = Math.max(40, Math.ceil(menuRect ? menuRect.width : 68));
const menuH = Math.max(24, Math.ceil(menuRect ? menuRect.height : 32));
const g = DOCK_LAYOUT_GAP;
const rowGap = 4;
const panelGap = 6;

function buildRow(items){
const present = items
.map((item)=>{
if(!item || !item.id){
return {
id: "",
w: Math.max(0, Math.ceil(item && item.w ? item.w : 0)),
h: Math.max(0, Math.ceil(item && item.h ? item.h : 0)),
tipTop: 0
};
}
const btn = dockControlById.get(item.id);
if(!btn) return null;
const m = getM(item.id);
if(!m) return null;
return { id: item.id, w: m.w, h: m.h, tipTop: m.tipTop || 0 };
})
.filter(Boolean);

const rowW = present.reduce((sum, item)=> sum + item.w, 0) + (Math.max(0, present.length - 1) * g);
const maxHalfH = present.reduce((max, item)=> Math.max(max, item.h * 0.5), 0);
const hasTips = present.some((item)=> item.tipTop > 0);
const up = maxHalfH + (hasTips ? 8 : 0);
const down = maxHalfH;
return { items: present, rowW, up, down };
}

function placeRow(row, centerY){
if(!row || !row.items.length) return { ok: true, top: centerY, byId: new Map() };
const minX = DOCK_LAYOUT_MARGIN;
const maxX = Math.max(minX, vw - DOCK_LAYOUT_MARGIN - row.rowW);
const startX = clamp(Math.round(anchorX - (row.rowW * 0.5)), minX, maxX);
let x = startX;
const localRects = [];
const localPos = [];
const byId = new Map();
for(const item of row.items){
if(!item.id){
x += item.w + g;
continue;
}
const y = Math.round(centerY - (item.h * 0.5));
const rect = makeDockRect(Math.round(x), y, item.w, item.h, 0);
if(!fitsDockRect(rect, vw, vh, obstacles, placed.concat(localRects))){
return { ok: false, top: y, byId: new Map() };
}
localRects.push(rect);
localPos.push({ id: item.id, x: Math.round(x), y });
byId.set(item.id, { x: Math.round(x), y, w: item.w, h: item.h });
x += item.w + g;
}
for(const pos of localPos){
const btn = dockControlById.get(pos.id);
if(!btn) continue;
btn.classList.add("dockObject");
btn.style.left = `${pos.x}px`;
btn.style.top = `${pos.y}px`;
placedIds.add(pos.id);
}
for(const rect of localRects){
placed.push(rect);
}
const rowTop = Math.round(centerY - row.up);
return { ok: true, top: rowTop, byId };
}

const row1 = buildRow([
{ id: "tabLanguageBtn" },
{ id: "tabColorsBtn" },
{ id: "tabInfoBtn" }
]);
const row2 = buildRow([
{ id: "lockCompositionBtn" },
{ id: "tabSpeedBtn" },
{ id: "dockPlayback" },
{ id: "tabContrastBtn" }
]);
const row3 = buildRow([
{ id: "fsBtn" },
{ id: "", w: menuW + DOCK_MENU_SPACER_EXTRA, h: menuH },
{ id: "screenshotBtn" }
]);

const row3CenterY = anchorY;
const row2CenterY = row3CenterY - (row2.down + rowGap + row3.up);
const row1CenterY = row2CenterY - (row1.down + rowGap + row2.up);

const p3 = placeRow(row3, row3CenterY);
if(!p3.ok) return { placedIds, panelPlaced: false };
const p2 = placeRow(row2, row2CenterY);
if(!p2.ok) return { placedIds, panelPlaced: false };
const p1 = placeRow(row1, row1CenterY);
if(!p1.ok) return { placedIds, panelPlaced: false };

if(shouldUsePanelTileLayout(vw, vh, activePage)){
const panelPlaced = placeOpenPanelTiles(anchorX, anchorY, vw, vh, obstacles, placed, {
centerX: vw * 0.5,
panelTopLimit: p1.top - panelGap
});
return { placedIds, panelPlaced };
}

if(!panelWrapEl || !panelMeasure || panelMeasure.w <= 0 || panelMeasure.h <= 0){
return { placedIds, panelPlaced: false };
}

const panelAnchorX = vw * 0.5;
const maxPanelLeft = Math.max(DOCK_LAYOUT_MARGIN, vw - DOCK_LAYOUT_MARGIN - panelMeasure.w);
const panelBottom = p1.top - panelGap;
const safe = getSceneSafeRect();
const safeBottom = safe ? safe.bottom : (vh * 0.5);
const minPanelY = Math.max(DOCK_LAYOUT_MARGIN, Math.round(safeBottom + UI_SAFE_GAP_PX + 6));
const maxPanelY = Math.max(minPanelY, Math.round(panelBottom - panelMeasure.h));
const centeredGapY = Math.round(minPanelY + ((maxPanelY - minPanelY) * 0.5));

const yCandidates = [centeredGapY, maxPanelY, minPanelY];
const xCandidates = [0, -16, 16, -32, 32, -48, 48];
let panelRect = null;
let panelX = 0;
let panelY = centeredGapY;

for(const yTry of yCandidates){
for(const d of xCandidates){
const x = clamp(Math.round(panelAnchorX - (panelMeasure.w * 0.5) + d), DOCK_LAYOUT_MARGIN, maxPanelLeft);
const y = clamp(Math.round(yTry), DOCK_LAYOUT_MARGIN, Math.max(DOCK_LAYOUT_MARGIN, vh - DOCK_LAYOUT_MARGIN - panelMeasure.h));
const rect = makeDockRect(x, y, panelMeasure.w, panelMeasure.h, 0);
if(fitsDockRect(rect, vw, vh, obstacles, placed)){
panelRect = rect;
panelX = x;
panelY = y;
break;
}
}
if(panelRect) break;
}

if(!panelRect){
// Deterministic fallback: keep buttons stable, then find any legal spot for panel.
const panelSpot = findDockSpot("__panel__", panelMeasure, panelAnchorX, Math.min(anchorY, maxPanelY), vw, vh, obstacles, placed, {
stepX: DOCK_GRID_MIN_STEP_X,
stepY: DOCK_GRID_MIN_STEP_Y,
maxRing: DOCK_PANEL_MAX_RING
});
panelX = Math.round(panelSpot.x);
panelY = Math.round(panelSpot.y);
panelRect = panelSpot.rect;
}

panelWrapEl.style.left = `${panelX}px`;
panelWrapEl.style.top = `${panelY}px`;
panelWrapEl.style.bottom = "auto";
panelWrapEl.style.transform = "none";
obstacles.push(panelRect);
placed.push(panelRect);
return { placedIds, panelPlaced: true };
}

function layoutDockObjects(){
if(!dockControlBtns.length) return;
const { w: vw, h: vh } = getViewportSize();
if(vw <= 0 || vh <= 0) return;
clearPanelFloatingTiles();

const menuRect = menuToggleBtn ? menuToggleBtn.getBoundingClientRect() : null;
const anchorX = menuRect ? (menuRect.left + (menuRect.width * 0.5)) : (vw * 0.5);
const anchorY = menuRect ? (menuRect.top + (menuRect.height * 0.5)) : (vh - 34);

const obstacles = getDockObstacles();
const placed = [];
const measuresById = new Map();
const order = getDockLayoutOrder();
const activePage = String(document.body.dataset.uiPage || "none");
const panelOpen = activePage !== "none";
const panelRectMeasure = panelInnerEl ? panelInnerEl.getBoundingClientRect() : (panelWrapEl ? panelWrapEl.getBoundingClientRect() : null);
const panelMeasure = panelWrapEl ? {
w: Math.max(42, Math.ceil((panelRectMeasure && panelRectMeasure.width) || panelWrapEl.scrollWidth || 0)),
h: Math.max(24, Math.ceil((panelRectMeasure && panelRectMeasure.height) || panelWrapEl.scrollHeight || 0)),
tipTop: 0
} : null;
for(const id of order){
const btn = dockControlById.get(id);
if(!btn) continue;
const m = measureDockControl(btn);
measuresById.set(id, m);
}

if(shouldUseBandedMobileLayout(vw, vh)){
const placedIds = placeBandedDockRows(vw, vh, obstacles, placed, measuresById);
if(panelOpen){
const safe = getSceneSafeRect();
placeOpenPanelTiles(anchorX, anchorY, vw, vh, obstacles, placed, {
centerX: vw * 0.5,
panelTopLimit: safe ? Math.round(safe.top - 6) : Math.round(vh * 0.46)
});
}

const layoutCfg = {
stepX: DOCK_GRID_MIN_STEP_X,
stepY: DOCK_GRID_MIN_STEP_Y,
maxRing: DOCK_GRID_MAX_RING
};
for(const id of order){
const btn = dockControlById.get(id);
if(!btn) continue;
if(placedIds.has(id)) continue;
btn.classList.add("dockObject");
const measure = measuresById.get(id) || measureDockControl(btn);
const spot = findDockSpot(id, measure, anchorX, anchorY, vw, vh, obstacles, placed, layoutCfg);
btn.style.left = `${Math.round(spot.x)}px`;
btn.style.top = `${Math.round(spot.y)}px`;
placed.push(spot.rect);
}
return;
}

const layoutCfg = {
stepX: DOCK_GRID_MIN_STEP_X,
stepY: DOCK_GRID_MIN_STEP_Y,
maxRing: DOCK_GRID_MAX_RING
};
const presetPlacedIds = (!panelOpen)
? placePresetDockCluster(anchorX, anchorY, vw, vh, obstacles, placed, measuresById)
: (placeOpenDockCluster(anchorX, anchorY, vw, vh, obstacles, placed, measuresById, panelMeasure).placedIds || new Set());

for(const id of order){
const btn = dockControlById.get(id);
if(!btn) continue;
if(presetPlacedIds.has(id)){
continue;
}
btn.classList.add("dockObject");
const measure = measuresById.get(id) || measureDockControl(btn);
const spot = findDockSpot(id, measure, anchorX, anchorY, vw, vh, obstacles, placed, layoutCfg);
btn.style.left = `${Math.round(spot.x)}px`;
btn.style.top = `${Math.round(spot.y)}px`;
placed.push(spot.rect);
}
}

function scheduleDockLayout(){
if(dockLayoutRaf) return;
dockLayoutRaf = requestAnimationFrame(()=>{
dockLayoutRaf = 0;
layoutDockObjects();
});
}

function applyDockConstellationState(){
const activePageOpen = !!(document.body.dataset.uiPage && document.body.dataset.uiPage !== "none");
const focusId = activePageOpen ? dockActiveBtnId : (dockHoverBtnId || dockActiveBtnId);
[prevPoemBtn, pausePoemBtn, nextPoemBtn].filter(Boolean).forEach((btn)=>{
btn.classList.remove("dockControl", "dockObject", "dock-shrink", "dock-focus", "dock-hover-focus", "dock-hover-shrink", "dock-tip-open");
btn.style.left = "";
btn.style.top = "";
});
dockControlBtns.forEach((btn)=>{
btn.classList.add("dockControl", "dockObject");
btn.classList.remove("dock-shrink", "dock-focus", "dock-hover-focus", "dock-hover-shrink", "dock-tip-open");

if(!focusId) return;
const isFocus = btn.id === focusId;
if(dockHoverBtnId && !activePageOpen){
btn.classList.add(isFocus ? "dock-hover-focus" : "dock-hover-shrink");
}else{
btn.classList.add(isFocus ? "dock-focus" : "dock-shrink");
}
if(dockHoverBtnId === btn.id && btn.dataset && btn.dataset.tip){
btn.classList.add("dock-tip-open");
}
});

if(menuToggleBtn){
menuToggleBtn.classList.remove("dock-focus", "dock-hover-focus");
if(focusId){
if(dockHoverBtnId && focusId === "menuToggleBtn"){
menuToggleBtn.classList.add("dock-hover-focus");
}else if(focusId === "menuToggleBtn"){
menuToggleBtn.classList.add("dock-focus");
}
}
}
}

function syncMenuTogglePosition(){
scheduleDockLayout();
}

function applyDockClickResponse(e){
if(!e || typeof e.clientX !== "number" || typeof e.clientY !== "number") return;
const el = e.currentTarget;
if(!el || !el.getBoundingClientRect) return;
const r = el.getBoundingClientRect();
if(r.width <= 0 || r.height <= 0) return;

scheduleDockLayout();
}

function setDockActiveButton(btnId){
dockActiveBtnId = String(btnId || "");
applyDockConstellationState();
scheduleDockLayout();
}

/* ================= Dock placement ================= */
function placeDockForViewport(){
if(!dockEl || !dockTopHostEl || !dockBottomHostEl) return;
const target = dockBottomHostEl;
const other = dockTopHostEl;
if(dockEl.parentElement !== target){
target.appendChild(dockEl);
}
// Prevent empty hosts from affecting layout.
target.style.display = "";
other.style.display = "none";
scheduleDockLayout();
scheduleUiSafeUpdate();
}

/* ================= Mobile UI pages ================= */
const UI_PAGES = ["none","language","info","contrast","colors","speed"];
let uiPage = "none";
function setTabPressed(btn, on){
if(!btn) return;
btn.classList.toggle("on", on);
btn.setAttribute("aria-pressed", on ? "true" : "false");
btn.setAttribute("aria-selected", on ? "true" : "false");
}
function assignMobileTabColors(){
// Unified theme: controls match the live card color.
applyButtonColors();
}
function setUiPage(next){
const page = UI_PAGES.includes(next) ? next : "none";
// Tap the active tab again to collapse back to "tabs only".
const finalPage = (uiPage === page && page !== "none") ? "none" : page;
uiPage = finalPage;
document.body.dataset.uiPage = finalPage;
setTabPressed(tabLanguageBtn, finalPage === "language");
setTabPressed(tabInfoBtn, finalPage === "info");
setTabPressed(tabContrastBtn, finalPage === "contrast");
setTabPressed(tabColorsBtn, finalPage === "colors");
setTabPressed(tabSpeedBtn, finalPage === "speed");
if(finalPage === "language") setDockActiveButton("tabLanguageBtn");
else if(finalPage === "info") setDockActiveButton("tabInfoBtn");
else if(finalPage === "contrast") setDockActiveButton("tabContrastBtn");
else if(finalPage === "colors") setDockActiveButton("tabColorsBtn");
else if(finalPage === "speed") setDockActiveButton("tabSpeedBtn");
else{
dockHoverBtnId = "";
setDockActiveButton("");
// Reset any sticky focus state so closed state returns to the load layout.
if(document.activeElement && typeof document.activeElement.blur === "function"){
document.activeElement.blur();
}
requestAnimationFrame(()=> requestAnimationFrame(scheduleDockLayout));
}

// Recolor on every page switch.
assignMobileTabColors();

// Keep the sliding panel out of the phrase/card region (especially on mobile landscape).
syncMenuTogglePosition();
scheduleUiSafeUpdate();
}

/* ================= UI Safe Zone (Never Overlap Phrase/Card) ================= */
// The "safe zone" is the card (if enabled) or the phrase ink bounds (if card is off).
// We clamp the sliding panel max-height so it cannot rise into that zone.
const UI_SAFE_GAP_PX = 10;
let uiSafeRaf = 0;

function getSceneSafeRect(){
const { w: vw, h: vh } = getViewportSize();
if(vw <= 0 || vh <= 0) return null;

const cardVisible = !!cardEl && (getComputedStyle(cardEl).display !== "none");

let r = null;
if(cardVisible){
r = cardEl.getBoundingClientRect();
}else{
const ink = phraseInkBounds();
if(ink) r = ink;
else r = phraseEl.getBoundingClientRect();
}
if(!r || !Number.isFinite(r.top) || !Number.isFinite(r.bottom)) return null;

const left = clamp(r.left, 0, vw);
const right = clamp(r.right, 0, vw);
const top = clamp(r.top, 0, vh);
const bottom = clamp(r.bottom, 0, vh);
return { left, right, top, bottom };
}

function rectsOverlap(a, b, gap=0){
if(!a || !b) return false;
return !(
(a.right + gap) <= b.left ||
(b.right + gap) <= a.left ||
(a.bottom + gap) <= b.top ||
(b.bottom + gap) <= a.top
);
}

function updatePanelSafeMaxHeight(){
if(!panelWrapEl) return;
const open = document.body.dataset.uiPage && document.body.dataset.uiPage !== "none";
if(!open){
panelWrapEl.style.setProperty("--panelMaxH", "0px");
scheduleDockLayout();
return;
}

const { w: vw, h: vh } = getViewportSize();
const activePage = String(document.body.dataset.uiPage || "none");
if(shouldUsePanelTileLayout(vw, vh, activePage)){
panelWrapEl.style.setProperty("--panelMaxH", "0px");
scheduleDockLayout();
return;
}

const desiredPanelH = Math.ceil((panelInnerEl ? panelInnerEl.scrollHeight : panelWrapEl.scrollHeight) + 2);
const maxH = clamp(Math.max(0, desiredPanelH), 0, Math.max(0, Math.floor(vh - (DOCK_LAYOUT_MARGIN * 2))));
panelWrapEl.style.setProperty("--panelMaxH", `${maxH}px`);
scheduleDockLayout();
}

function scheduleUiSafeUpdate(){
if(uiSafeRaf) return;
uiSafeRaf = requestAnimationFrame(()=>{
uiSafeRaf = 0;
updatePanelSafeMaxHeight();
});
}

/* ================= Scene Gestures (Drag / Pinch Scale) ================= */
const SCENE_ZOOM_MIN = 0.5;
const SCENE_ZOOM_MAX = 3.0;
let sceneZoom = 1;
const sceneGesture = {
active: false,
mode: "none",
pointers: new Map(),
startZoom: 1,
startY: 0,
startDist: 1
};

function setSceneZoom(next){
const z = clamp(Number(next), SCENE_ZOOM_MIN, SCENE_ZOOM_MAX);
if(!Number.isFinite(z)) return;
if(Math.abs(z - sceneZoom) < 0.0005) return;
sceneZoom = z;
document.documentElement.style.setProperty("--sceneZoom", sceneZoom.toFixed(3));
applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
}

function pointInRect(x, y, r){
return !!r && x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
}

function getSceneGestureRect(){
const cardShown = !!cardEl && getComputedStyle(cardEl).display !== "none";
if(cardShown){
return cardEl.getBoundingClientRect();
}
return phraseInkBounds() || phraseEl.getBoundingClientRect();
}

function isUiTarget(target){
if(!target || !target.closest) return false;
return !!target.closest("#titleBlock, #bar, #menuToggleBtn");
}

function refreshSceneGestureMode(){
const points = Array.from(sceneGesture.pointers.values());
if(points.length >= 2){
const [a, b] = points;
sceneGesture.mode = "pinch";
sceneGesture.startDist = Math.max(1, Math.hypot(a.x - b.x, a.y - b.y));
sceneGesture.startZoom = sceneZoom;
return;
}
if(points.length === 1){
sceneGesture.mode = "drag";
sceneGesture.startY = points[0].y;
sceneGesture.startZoom = sceneZoom;
return;
}
sceneGesture.mode = "none";
sceneGesture.active = false;
}

function onScenePointerDown(e){
if(e.pointerType === "mouse" && e.button !== 0) return;
if(isUiTarget(e.target)) return;

const inScene = pointInRect(e.clientX, e.clientY, getSceneGestureRect());
const allowSecondTouch = sceneGesture.active && sceneGesture.pointers.size === 1 && e.pointerType !== "mouse";
if(!inScene && !allowSecondTouch) return;

sceneGesture.active = true;
sceneGesture.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
refreshSceneGestureMode();
if(e.target && typeof e.target.setPointerCapture === "function"){
try{ e.target.setPointerCapture(e.pointerId); }catch(_){}
}
e.preventDefault();
}

function onScenePointerMove(e){
if(!sceneGesture.pointers.has(e.pointerId)) return;
sceneGesture.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

if(sceneGesture.mode === "drag" && sceneGesture.pointers.size === 1){
const p = sceneGesture.pointers.get(e.pointerId);
const dy = p.y - sceneGesture.startY;
const next = sceneGesture.startZoom * Math.exp(-dy / 220);
setSceneZoom(next);
e.preventDefault();
return;
}

if(sceneGesture.pointers.size >= 2){
const points = Array.from(sceneGesture.pointers.values());
const dist = Math.max(1, Math.hypot(points[0].x - points[1].x, points[0].y - points[1].y));
const next = sceneGesture.startZoom * (dist / sceneGesture.startDist);
setSceneZoom(next);
e.preventDefault();
}
}

function onScenePointerEnd(e){
if(!sceneGesture.pointers.has(e.pointerId)) return;
sceneGesture.pointers.delete(e.pointerId);
if(e.target && typeof e.target.releasePointerCapture === "function"){
try{ e.target.releasePointerCapture(e.pointerId); }catch(_){}
}
refreshSceneGestureMode();
}

/* ================= Selection state ================= */
const sel = {
parts: new Set(["description","person","action","location"]),
bgColor: new Set(ALL_SWATCH_COLORS),
fgColor: new Set(ALL_SWATCH_COLORS),
bdColor: new Set(ALL_SWATCH_COLORS),
borderEnabled: true,
borderThickness: Number(bdThickEl.value)
};

/* ================= Vocab banks ================= */
/*
Editing tips:
- One entry per line.
- Blank lines are fine.
- Everything is lowercased + de-duped at runtime.
*/
function vocabLines(str){
return uniq(
str
.split("\n")
.map(s => String(s).replace(/\r/g, "").trim())
.filter(Boolean)
.map(s => s.toLowerCase())
);
}

/* description (object) */
const DESC_OBJECT = vocabLines(`
a sycophantic
accepting
anti-fascist
antique
arcane
ashen
asymmetrical
atonal
attentive
baggy
balanced
bald
beautiful
bent
blasÃ©
bloated
brassy
brilliant
brittle
buff
bumpy
buoyant
burnished
burnt
buttery
buzzing
carpeted
charming
chubby
civilized
classical
compact
compact
confident
considered
contrasting
cracked
crude
crumbly
crunchy
cryptic
curly
cute
damp
daybreak
decaying
deft
delicate
delighted
despondent
detached
dewy
diamond encrusted
diaphanous
dimly lit
dingy
discreet
distended
drafty
dreamy
dried out
dry
dulcet
dusty
effervescent
elegant
elevated
elongated
emerald
enlarged
ennui
esoteric
ethereal
evocative
exploratory
extended
feathery
flashy
flavorful
fleshy
flickering
flowing
foamy
folded neatly
formal
fresh
freshly repaired
fried
frosted
fruity
fugitive
furry
futile
gentle
gently used
ghostly
gigantic
glittery
glossy
gluttonous
gracefully arranged
grand
granite
greasy
growing
guarded
hairy
hard
hedonistic
hermetic
herringbone
hushed
immersed
indifferent
inlaid
insular
introverted
iridescent
jazzy
jealous
jiggly
joyful
languid
lean
leisurely
lighthearted
lightly crushed
lightly worn
listless
lithe
lively
long
loud
lumpy
maladjusted
malaise
malnourished
marble
matte
melted
messy
mindful
moist
moldy
mother-of-pearl
muffled
muscular
muscular
muted
mysterious
nervous
nostalgic
nuanced
obsequious
oily
opalescent
orderly
ornamental
ossified
overflowing
oversized
padded
painted
patched
pearly
pensive
perceptive
petite
petulant
pillowy
plaintive
plaintive
plump
pocket-sized
poetic
poignant
poised
polished
poorly proportioned
powdery
precise
puffy
quartz
radiant
reclusive
refined
reflective
reminiscent
repaired
reserved
restrained
ribbed
ritualistic
rocky
rotten
rough
ruby
rueful
salty
sandy
scrambled
sculpted
sculptural
serene
shaved
short
silent
skimpy
slim
slimy
slippery
smelly
smoggy
smoky
smooth
soapstone
soapy
soft
sparkly
spilt
spoiled
spontaneous
stately
stone
stormy
strange
strappy
stubbly
subdued
subtle
suggestive
sullen
sunken
sunset
supple
sweaty
sweet
tailored
tall
tarnished
tasteful
tempered
tenderly handled
thick
thirsty
tie-died
translucent
transparent
twisted
ubiquitous
ugly
unbalanced
unctuous
understated
undulating
unhurried
unrequited
unspoken
veiled
velvety
vermicular
verve
vigorous
vivacious
weary
wet
wiggly
windy
wistful
witchy
withering
witty
woolen
worried
wrapped
yearning
zestful
Ã©lan
`);

/* description (person) */
const DESC_PERSON = vocabLines(`
adventurous
aggressive
alcoholic
amateur
anarchist
annoying
antifa
artistic
athletic
autistic
awkward
balding
barefoot
betrayed
bigoted
blind
bloated
blonde
blue collar
brassy
bratty
british
broke
bumbling
butch
charming
chic
chubby
clever
closed-minded
clueless
communist
confident
conservative
cool
cranky
creepy
crude
curvy
dancing
deaf
dehydrated
depressed
desperate
disgraced
disgruntled
distraught
divorced
dorky
down-to-earth
dried out
eager
earthy
easy going
easygoing
eccentric
educated
elegant
elite
erudite
excited
exhausted
failed
famous
fastidious
feckless
female
feminine
flashy
foolish
former
frazzled
french
fresh-faced
frugal
funky
future
gay
gen-x
generous
glamorous
glitzy
good natured
gorgeous
gray-haired
greasy
greedy
greek
hairless
handsome
hapless
hateful
hedonistic
heterosexual
high strung
hilarious
hipster
humble
idealistic
illiterate
immature
incompetent
indie
indigenous
inexperienced
infamous
infantile
injured
insecure
insular
introspective
introverted
irate
irritated
italian
jaded
jazzy
jet-lagged
kleptomaniac
lanky
left-wing
leftist
leggy
lethargic
liberal
lithe
long haired
male
maoist
moody
naive
nerdy
neuro divergent
new
non-binary
obsessive
old
optimistic
over-dressed
overstimulated
overwhelmed
pacifist
paint splattered
pessimistic
petite
petulant
plus-sized
poor
popular
potential
pregnant
pretentious
prickly
primped
professional
progressive
prospective
prudish
punk rock
queer
quick-thinking
quiet
recovering
red headed
retired
ribald
rich
ridiculous
right-wing
rockabilly
rude
scandalized
scantily clad
scholarly
shaved
short
short haired
shrewd
shy
silent
skanky
skeletal
skilled
sleepy
slim
slimy
slumped-over
snappy
sober
socialist
sophisticated
specialized
spunky
steampunk
stunned
stylish
suave
sunburned
surly
sweaty
talkative
tall
tattooed
teenaged
tightly wound
tiny
tired
transsexual
unaware
uncomfortable
under-dressed
underground
unemployed
unhappy
unpleasant
unwed
uptight
virginal
vivacious
wealthy
weary
well dressed
witchy
witty
worldly
wounded
young
youthful
zippy
`);

/* object */
const OBJECTS = vocabLines(`
absinthe
air conditioner
air fryer
airport shuttle
alarm bell
alleyway
aperol spritz
ash tray
atm
baby bottle
bacon egg and cheese
bag of weed
bagel with cream cheese
baggie of ketamine
bagpipe
ball of yarn
bandsaw
banjo
bank vault
baseball bat
baseball glove
bath tub
bed
bedside table
beer bottle
beer can
beer stein
bento box
bibimbap
bicycle
big mac
birdbath
birdcage
birdhouse
blu-ray player
bluetooth speaker
blush
board game
bookcase
bookshelf
bouncy ball
bow tie
bracelet
bralette
broom
brownstone
bulletin board
bungee cord
bunk beds
cabinet
caesar salad
canned cocktail
canvas
cardboard box
cardigan
carpet
carrot juice
cash register
catchers mitt
cd-rom
celery juice
chaise longue
chapstick
cheeseburger
chess board
chicken katsu
chisel
chopper
christmas lights
chunky heels
circuit board
circuit breaker
clock
closet
clothes line
cocktail
coffee maker
coffee mug
coffee table
comedy club
comforter
computer monitor
convertible
cooler
couch
couscous
crock pot
croquet mallet
croquette
cross-body bag
crushed cicodin
cucumber salad
curtains
cushion
cutting board
dance club
deck chair
denim skirt
dental pick
deodorant
dictionary
diner booth
dining room table
director's chair
dirt bike
dish rack
dive bar
doctor's office
doorknob
draft beer
drapery
drawer
drill
drill press
drinking glass
driveway
driving gloves
drum kit
drying rack
dump truck
dumpster
dune buggy
dust pan
duvet
dvd box set
dvd player
egg salad
electric kettle
enchiladas
end table
envelope
eye drops
fernet
fidget spinner
fingerless gloves
flip phone
folded map
foot rest
foot stool
ford bronco
freezer
freight train
french food
french press
fried chicken sandwich
fried rice
frying pan
fur pelt
futon
gallery
gaming chair
garlicky kale
geiger counter
glass of blush
gondola
grain bowl
grand piano
granite counter tops
greek salad
green juice
greenhouse
grilled chicken sandwich
guinness
gyro
hair brush
hair clip
hair tie
hairpiece
halter top
ham sandwich
hamburger
handbag
hard boiled egg
hardwood floor
harmonica
hash pipe
hatchback
hedge trimmer
hero sandwich
heroin spoon
high ball glass
high heels
hot dog cart
hot glue gun
hot toddy
hot tub
hourglass
ink wash
instruction manual
ipad
italian food
jacuzzi
japanese curry
japanese food
karaage
keg of beer
keyboard
kitchen sink
kitten heels
knit sweater
knitting needles
korean food
krazy glue
lace bra
lace thong
lace underwear
ladder
lager
lamp
lampshade
laser pointer
latex mask
laundry basket
laundry hamper
lawn mower
leather gloves
lecture hall
legal pad
library
line of cocaine
linen napkin
lip gloss
lipstick
love seat
makeup
manhole cover
margarita
martini
mattress
maxi pad
metal detector
mexican food
microphone
mini fridge
mini-van
mission style burrito
mocktail
mojito
moo shu pork
mop bucket
mountain lodge
moving boxes
museum
mushroom chocolate
nail polish
name tag
nashville hot fried chicken
necklace
neon sign
newspaper
night stand
nitrous oxide canister
noodles
note pad
notebook
office cubicle
old washing machine
oled panel
opium tea
ottoman
oven
pack of cigarettes
padded booth
paint brush
paint bucket
pantyhose
paperback book
parachute
parking garage
parking lot
participation trophy
pastrami on rye
peanut butter and jelly
pendant
pendulum
percolator
perfume bottle
photocopier
pilsner
pinwheel
pipe organ
pizza box
playing cards
playstation
plywood
poached egg
pocket watch
pomegranate juice
portable fan
portrait
potted plant
printed out pdf
printer
propeller
propeller beanie
pulled pork sandwich
punk club
purse
push-up bra
quinoa
ramen
rave
reading glasses
record player
record store
recycling bin
refrigerator
remote control
rice bowl
riding lawn mower
ring
rocking chair
roku tv
room service tray
rosÃ© wine
rug
samovar of coffee
sawhorse
saxophone
scaffolding
scissors
scoop neck shirt
seaweed salad
seltzer
sensible pumps
sewer
sheriff's badge
shop vac
shopping cart
shower head
side salad
sizzling fajita platter
skis
slate tile
slot machine
soap
soft boiled egg
solar panel
sound board
soupspoon
spaghetti strap tank top
sports car
spray paint
sprinter van
station wagon
steering wheel
step ladder
straight jacket
strappy sandals
subaru forester
succulent garden
sundial
superglue
suv
switchback
synthesizer
t-shirt
tab of acid
table saw
tablet
tambourine
tank top
tap shoes
tape measure
taqueria
tea bag
tea pot
tequila shot
terrarium
throw pillow
ticket stub
tie pin
tights
tissue box
toilet paper
tomato juice
tombstone
toolbox
townhouse
trade paperback
traffic median
trailhead
trash can
trombone
trophy
tube top
turtleneck
typewriter
ukulele
umbrella
undershirt
upholstery
vacuum cleaner
vanity mirror
velvet rope
vending machine
video game
waiting room
wardrobe
water slide
water tower
wedding band
wedge salad
weed whacker
welding mask
whisky sour
white glue
whoopie cushion
wicker basket
window
wine decanter
wine glass
workbench
wrist watch
x-ray machine
xerox machine
`);

/* person */
const PERSONS = vocabLines(`
acquaintance
architect
art teacher
art therapist
artist
athlete
babe
barber
bathroom attendant
best friend
boat builder
bodega guy
brain surgeon
bro
bully
businessman
businesswoman
butt-head
chaperone
chef
coal miner
couples therapist
crane operator
dancer
day trader
dj
dude
employee
ex-husband
ex-wife
farmer
fascist
father
flautist
flight attendant
florist
friend
grad student
grandma
grandpa
guitar player
guy
gym teacher
gymnast
hair stylist
heterosexual
homeowner
homosexual
housemate
immigrant
improv comic
insomniac
insurance broker
intern
jazz singer
jerk
jock
journalist
luddite
machinist
man
masseuse
mayor
meter maid
middle manager
model
mother
neighbor
newscaster
novelist
nun
nurse
painter
performance artist
person
pervert
photographer
piano player
playwright
podcaster
poet
police officer
politician
producer
refugee
reporter
roadie
roommate
sculptor
secretary
shopkeep
singer
standup comic
step-dad
step-mom
straight guy
stud
student
substitute teacher
tech bro
trucker
waiter
waitress
woman
woodcarver
`);

/* action */
const ACTIONS = vocabLines(`
a little damp
a little damp
a little drunk
acting tough
acting unprofessional
acting up
afraid of getting in trouble
agreed to an open marriage
all alone
all scratched up
all scuffed up
all sticky
approaching middle age
arms akimbo
at peace
at rest
at the bottom of a well
balanced on a ledge
balancing
being cyber bullied
being held accountable
being ignored
being ignored
being interrogated
being praised
being rude
being tricked
being very theatrical
beloved by everybody
bent backwards
better off alone
binge drinking
binge eating
blacked out
bleeding
blemish-free
blowing in the wind
blowing massive vape clouds
blowing out a candle
blowing out candles
blowing smoke rings
blowing smoke rings
bodysurfing
bored
bored
bottomless
bouncing up and down
braiding its hair
brainstorming
breaking convention
breaking the rules
breaking wind
broiling a flounder
broken
buried in the back yard
buried under rubble
buying a raffle ticket
buying crypto
can't handle ~it~ anymore
can't hit the pinata
can't stop laughing
carefully stacked
carved from a block of wood
carving marble
cashing a check
cast aside
cast aside
cast in bronze
casually dating
catching up with an old friend
caught crying
caught in a summer rain
caught in the rain
caught in the rip current
celebrating the holidays
changing its tampon
charging its phone
chatting
cheating
checking instagram
checking its email
chewing gum
chewing nicotine gum
chugging warm beer
clearly lying
climbing over the fence
clingy
clutching the hand rail
coming out of the closet
committing fraud
committing perjury
committing tax fraud
comparison shopping
completely wasted
cooling slightly
couldn't cut it
counting money
covered in paint
covered in vaseline
cranky
craving something sweet
crunching the numbers
crushing garlic
crying
curled up
cut down
cutting the cord
dancing
dancing in the moonlight
dancing in the rain
dancing to house music
declaring love
decluttering
dehydrated
delivering a baby
delivering a message
dented on the corner
deserves a treat
desperate for affection
dewy-faced
dicing onions
dimming the lights
disappointing itself
disassociating
disrespected
doe eyed
doesn't smell great
doing a cold plunge
doing a keg stand
doing a line of ketamine
doing a photoshoot
doing downward dog
doing improv
doing its thing
doing kegels
doing ok
doing pilates
doing the best it can
doing the dishes
doing the macarena
doomscrolling
drawing
drifting off
drinking a cold glass of milk
drinking a martini
drinking wine
dripping quietly
dripping wet
driving a tractor
dropped a plate of spaghetti
dropping acid
drying on a rack
drying out in the sun
dusting
eating a bagel
eating alone
eating beans out of the can
eating boogers
eating french fries
eating leftovers
eavesdropping
effortlessly arranged
embarrassed
emitting a high pitched sound
experimenting
extremely bored
facing dire consequences
facing the music
faking an orgasm
falling down
farting
feeling a little hopeful
feeling betrayed
feeling blue
feeling discouraged
feeling discouraged
feeling doubt
feeling dried out
feeling good
feeling groovy
feeling homesick
feeling itself
feeling nauseous
feeling nostalgic
feeling old
feeling satisfied
feeling so gross
feeling tense
feeling unheard
fell down the stairs
fidgeting anxiously
fighting
filled with an overwhelming sense of dread
filled with dread
filled with jealousy
filled with regret
finally gave up
finding itself
flickering
flickering softly
flipping a house
flipping through a magazine
flipping through a magazine
flirting
floating
floating
flossing aggressively
folding laundry
found bedbugs
freak dancing
freshly cleaned
freshly unpacked
frowning
frowning
gently dabbing perfume
gently kayaking
gesturing wildly
getting a boner
getting a haircut
getting a manicure
getting a pedicure
getting a perm
getting a promotion
getting a tattoo
getting a vitamin drip
getting chilly
getting circumcised
getting cramps
getting cursed out
getting dismissed
getting emotional
getting fingered
getting hired
getting its eyebrows tweezed
getting its hair done
getting its nails done
getting moldy
getting picked on
getting reupholstered
getting shorter
getting sick
getting sober
getting talked down to
getting the ick
getting therapy
getting wet
getting worked up
getting yelled at
giggling
giving birth
giving up
giving up hope
glistening
glistening
glowing softly
going off
going through a break up
going through a breakup
going to the bathroom
got dumped
got laid off
got too high
got up early to watch the sunrise
grabbing a slice
grilling hot dogs
grinding weed
grinning to itself
growing taller
grumpy
had a one night stand
half submerged
half-finished
half-naked
hanging out
happy enough
happy this way
has never been
hasn't changed at all
having a breakdown
having a moment
having an orgasm
having fun
hedonistically indulging
held at gunpoint
hiding
hiding under the covers
hiking its skirt up
holding back tears
holding back tears
hooting
horny
howling
humming faintly
humming to itself
hungry
hurling insults
ignoring its text messages
imagining a smooth wet stone
impatiently waiting
impatiently waiting
in a bath robe
in a new outfit
in a nightgown
in a situationship
in despair
in hiding
in its best clothes
in shambles
is all tuckered out
is becoming oxidized
is being gently caressed
is burning bridges
is draped in silk
is getting annoyed
is getting encased in resin
is getting wasted
is mending fences
is over it
is pissed off
is ready for a change
is sitting on its side
is smoking a cigarette
jacking off
jogging
jogging first thing in the morning
jotting down ideas
journaling
keeping a secret
keeping its head down
keeping its mouth shut
kicking back
kicking back
killing time
knocked over
knocked over a bottle of wine
landing a kickflip
lashing out
laying on the floor
lazily napping
leaning against a wall
leaning back
learning a magic trick
learning about plants
learning how to whistle
learning spanish
left behind
left out in the cold
left out overnight
licking its wounds
lighting a candle
lightly casting a bedsheet across its bare mattress
lightly tapping
lip-syncing
listening
listening to the dripping water
listening to the rain
listless
logging off
loitering
looked upon fondly
looking around
looking for a hole in the air mattress
looking for a lighter
looking for a roommate
looking for attention
looking for its keys
looking for its underwear
looking for love
looking for meaning
looking for survivors
looking for trouble
looking out the window
looking through a microscope
looking within
losing control
losing interest
losing touch with itself
losing weight
lost an earbud
lost the spark
loving life
lubed up
lurking
maintaining control
making a smoothie
making an omelette
making friends
marinating overnight
masturbating furiously
meal prepping
meditating
melting on a slice of warm toast
mining bitcoin
misaligned
missing its mother
moisturizing
mounted to the wall
moving slowly
naked
nearly fainted
needs a haircut
needs some help
nicely toasted
nodding off
nonchalantly tossed aside
not making a sound
not over it
not thinking about the news
noticing what's changed
on its last legs
on the run
online shopping
opening a restaurant
opening the shutters
ordering a drink
ordering lunch
out of reach
overcome with guilt
overcome with happiness
overcome with malaise
overeating
overheated
oversharing
painting its nails
painting with watercolors
panicking
passing gas
people watching
perfectly posed
performing surgery
picking a scab
picking apples
picking its underwear
picking through the bulk bins
picking up on signals
picking up trash
pissed off
placing a bet
playing hookie
playing mini golf
playing powerball
playing tetris
plucking a harp
plucking hairs
plugging in the aux cord
pogo dancing
polishing boots
pooping
popped an advil
popping a pimple
practically melting
preparing for surgery
preparing matcha tea
pressed against the wall
pressed into velvet
proposing marriage
protesting the genocide
proud of itself
pulled a muscle
pulled out to see
pulling hair out of the drain
pulling itself together
pushing the boundaries
putting its feet up
putting its hair up
putting on eyeshadow
putting on makeup
quit drinking
rapping
ready for a change
really happy
really likes it
receiving communion
receiving electrolysis
recording a podcast
reflecting on the past
rekindling an old fling
reminiscing
rescued from danger
resigned to its fate
resting
resting
resting against a window
resting quietly
revealing a mean streak
riding a dirtbike
ringing slightly
ripening on the kitchen counter
ripped to shreds
roasting in the sun
rock climbing
rocking back and forth
rollerblading
rolling a spliff
rolling around in an office chair
rolling downhill
rubbing its neck
running its fingers through cool water
running its fingers through its hair
running on a treadmill
running through water
rusted
sailing east
sanding furniture
sauteing mushrooms
scratching itself
scratching off a lottery ticket
scrubbing behind the toilet
searching for meaning
seeking forgiveness
self-soothing
serving on a jury
setting the table
shaking its hair out
shaking maracas
shaking slightly
shaving
shifting a ball of energy
shifting its weight
shirtless
shoplifting
shopping
shrinking
shuffling around
sick of arguing
singing acapella
singing softly
sinking into snow
sipping coffee
sipping from a hip flask
sitting
sitting on a balcony
sitting on a milk crate
sitting under a heat lamp
sitting untouched
skipping
slicing onions
sliding across a table
slightly angled
slowly rotating
smiling
smiling
smiling politely
smoking
smoking a joint
smoking crack
smoldering
smudged at the edges
snacking
sneezing
snooping
snooping through drawers
soaked in sweat
soaking wet
sobbing softly
softly weeping
soul-searching
speaking in tongues
speaking softly
spewing bullshit
spilling a little
spinning in circles
spinning out of control
splashing water on its face
splayed apart
squealing with delight
squeezing lemons
squinting
stacking coins
staining the counter
standing alone
standing at the window while the city wakes
standing still
staring into the middle-distance
starting to cry
staying late
steaming
stewing in its own juices
still damp
still hungry
still single
still warm
straining its seams
stressed out
stretched out
stretching its legs
stretching out
struggling
struggling with insomnia
strumming a guitar
strutting its stuff
strutting its stuff
stuck in a rut
stuck in a tree
stuck in mud
stuck in traffic
studying german
styling an outfit
sucking dick
sucking on a vape pen
sucking up
suffering silently
sulking
sunbathing
swapping out the air freshener on its rear view mirror
taking a bump of cocaine
taking a hint
taking a knee
taking a load off
taking ecstasy
taking out the trash
taking the train
talking shit
tapping lightly
telling the truth
tending to a wound
thinking about giving up
thinking about its dog
thinking too hard
thirsty
thriving
throwing a frisbee
throwing dinner together
tidying up
tightly wound
tipping generously
took a huge bong hit
topless
toppled over
touching itself
touching itself
toweled dry
traveling with friends
treading mud onto the carpet
treading water
treating a burn
tried its best
trying not to be seen
trying on shoes
trying out a new hat
trying to figure things out
trying to stay hidden
tucked into a drawer
tucked into bed
twisting and turning
unable to lie
unclogging a toilet
uncrossing its legs
under a lot of pressure
under a pile of clothes
under a tight deadline
under arrest
under dappled light
under scrutiny
under the influence
under water
unpacking boxes
unsteady on a ladder
unsure
up all night
updating its website
upside-down
using nonviolent resistance
vaping
vibrating
vibrating faintly
vibrating with anticipation
violently scratching itself
virtue signaling
voting
wading through dirty water
waiting
waiting for the bus
waiting in line
walking through wet grass
wandering aimlessly
wandering around
warped by heat
watching asmr
watching the sunset
waxing its legs
wearing
wearing a bikini
wearing a bikini
wearing a mini skirt
wearing a tracksuit
wearing cargo pants
wearing chunky heels
wearing cutoffs
wearing cutoffs
wearing incredible jeans
wearing overalls
wearing slacks
wearing streetwear
wearing the same old clothes
wearing yoga pants
weeping
weeping
whispering
wide awake
wiping away tears
with a bouquet of flowers
with a brutal headache
with a cracked screen
with a dark sense of humor
with a proclivity for the absurd
with a skewed perspective
with a thick accent
with chipped paint
with incredible skin
with its eyes closed
with nothing to say
working retail
working through something
worn out
wrapped in plastic
wrapped in tape
writhing in pain
zipping a suitcase slowly
`);

/* location */
const LOCATIONS = vocabLines(`
across the street from an abandoned church
among folded deck chairs
among rolling hills
at a beachfront bonfire
at a beauty pageant
at a book club
at a bus stop at dusk
at a construction site
at a department store
at a dive bar
at a dude ranch
at a foggy ferry terminal
at a gay bar
at a pawn shop
at a poker table
at a pumpkin patch
at a rave
at a record store
at a rodeo
at a rooftop bar
at a silent retreat
at a strip club
at a strip mall
at a used book store
at an amphitheater
at an art house theater
at an open mic night
at an outlet mall
at madison square garden
at the acropolis
at the beach
at the bottom of a lake
at the campgrounds
at the catacombs
at the club
at the eiffel tower
at the farm stand
at the foot of the bed
at the garbage dump
at the great wall of china
at the hardware store
at the top of a cherry picker
at the top of a ladder
at the top of the bleachers
at the trailhead
at the waterfront
at the world trade center
behind barbed wire fencing
beneath a flickering neon sign
buried in a shallow grave
by a printing press
by the fire pit
by the water tower
during its own wedding
face down in the mud
frozen in a block of ice
hanging out
in a bank vault
in a bog
in a breakfast nook
in a cafeteria
in a cemetery
in a ceramics studio
in a city center
in a clown car
in a corner office
in a cozy brownstone apartment
in a craft room
in a cramped studio apartment
in a cubicle
in a cul-de-sac
in a cvs
in a darkened movie theater
in a day spa
in a dingy bowling alley
in a dorm room
in a dressing room
in a dune buggy
in a food court
in a haunted house
in a high-rise apartment building
in a home office
in a karaoke bar
in a kitschy dive bar
in a lady footlocker
in a loft space
in a long-unused childhood bedroom
in a med spa
in a pantry
in a pet store
in a polyamorous relationship
in a punk house
in a railroad dining car
in a renovated tenement building
in a root cellar
in a rustic fishing village
in a saltwater pool
in a same-sex relationship
in a shoemaker's workshop
in a sketchy town upstate
in a soaking tub
in a spare bedroom
in a steam room
in a steamy bathroom
in a theme park
in a tourist trap
in a tv studio
in a vineyard
in a walk-in freezer
in a walkable neighborhood
in a wine bar
in a wine cellar
in a writing workshop
in an airplane
in an airport
in an airport lounge
in an empty museum gallery
in an improv class
in an italian restaurant
in an obsolete shopping mall
in an off-season seaside town
in an open-plan office
in an unfinished basement
in an unfinished housing development
in an unlit attic
in an unpleasant post-modern apartment
in back stairwells
in bed
in bushwick
in carnegie hall
in chicago
in detention
in dimes square
in english class
in greenpoint
in gym class
in line at the pharmacy
in line for the bathroom
in soho
in solitary confinement
in tall grasses
in the alleyway
in the amusement park
in the apartment
in the arcade
in the attic
in the back seat of a car
in the backyard
in the basement
in the bathroom
in the bedroom
in the dining room
in the doctor's office
in the driver's seat
in the driveway
in the fiery pits hell
in the kitchen
in the lecture hall
in the library
in the living room
in the mall of america
in the office
in the parking garage
in the parking lot
in the passenger seat of a car
in the pelapenese
in the penthouse
in the shadow of a mountain
in the south of france
in the studio
in the swimming pool
in the trunk of a car
in the waiting room
in times square
in williamsburg
inside a black box theater
inside a cramped submarine
inside a display case
inside a movie studio
inside a vacant motel
inside an automotive plant
inside an overhead bin
locked in the trunk of a car
lying in a hammock
near a courtyard fountain
near the dollar store
near the old gas station
on a balcony chair
on a basketball court
on a bean bag chair
on a construction site
on a corduroy love seat
on a dirt road
on a first date
on a game show
on a golf course
on a mowed lawn
on a second date
on a soundstage
on a suspension bridge
on a tennis court
on a third date
on a tv show
on an artist's residency
on an empty boardwalk
on an empty train platform
on cobblestone
on stone steps
on the balcony
on the casino floor
on the couch
on the dance floor
on the last day of school
on the other side of town
on the outskirts of town
on the pier
on the sidewalk
on the trail
on the upper east side
on the waterfront in portugal
on the yucatan peninsula
on vacation
outside a closed movie theater
sitting in a diner booth
skimming the headlines
stuck to the floor of a movie theater
under a disco ball
under overgrown vines
under red lights
under the bed
under the overpass
up in a tree
while being held hostage
while enveloped by a fog machine
while lost in a wheat field
while riding on the back of a horse
while stuck in an airport
while testifying in court
while trapped in an elevator
while trapped underwater
while walking the runway show
with feet in the sand
within a sinister gated community
`);

/* ========================================================== */

const WORD_REPEAT_COOLDOWN = {
"desc:object": 180,
"desc:person": 180,
"desc:mixed": 220,
"obj": 260,
"person": 220,
"act": 320,
"loc": 260
};
function pickDescriptorObject(){ return bagNextWithCooldown("desc:object", DESC_OBJECT, WORD_REPEAT_COOLDOWN["desc:object"]); }
function pickDescriptorPerson(){ return bagNextWithCooldown("desc:person", DESC_PERSON, WORD_REPEAT_COOLDOWN["desc:person"]); }
function pickDescriptorMixed(){ return bagNextWithCooldown("desc:mixed", DESC_OBJECT.concat(DESC_PERSON), WORD_REPEAT_COOLDOWN["desc:mixed"]); }
function pickDescriptor(useObj, usePerson){
if(usePerson) return pickDescriptorPerson();
if(useObj) return pickDescriptorObject();
return pickDescriptorMixed();
}
function pickObject(){ return bagNextWithCooldown("obj", OBJECTS, WORD_REPEAT_COOLDOWN["obj"]); }
function pickPerson(){ return bagNextWithCooldown("person", PERSONS, WORD_REPEAT_COOLDOWN["person"]); }
function pickAction(){ return bagNextWithCooldown("act", ACTIONS, WORD_REPEAT_COOLDOWN["act"]); }
function pickLocation(){ return bagNextWithCooldown("loc", LOCATIONS, WORD_REPEAT_COOLDOWN["loc"]); }

/* ================= Phrase build ================= */
function safeStr(x){ return (x == null) ? "" : String(x).trim(); }
function formatPhraseText(p){
return p;
}

function swapItPronounsForPerson(actionStr){
let s = String(actionStr || "");
if(!s) return s;

// Escape hatch: wrap any text in ~...~ to protect it from pronoun swapping.
// Example: "totally over ~it~" stays "totally over it".
const locked = [];
s = s.replace(/~([^~]+)~/g, (_, inner)=>{
const token = `__LOCK_${locked.length}__`;
locked.push(inner);
return token;
});

// If a vocab line accidentally includes "it's" (possessive typo), treat it like "its"
// so pronoun swapping still works.
s = s.replace(/\bit[â€™']s\b/g, "its");

const female = Math.random() < 0.5;
const map = female
? { it: "she", its: "her", itself: "herself" }
: { it: "he", its: "his", itself: "himself" };

// Avoid matching inside contractions like "it's".
s = s.replace(/\b(itself|its|it)\b(?!')/g, (m)=> map[m] || m);

// Restore protected text and remove the ~...~ wrappers.
return s.replace(/__LOCK_(\d+)__/g, (_, i)=> locked[Number(i)] ?? "");
}

/* ================= Phrase non-repeat (persists across reloads) ================= */
// Keep a long memory so exact repeats stay rare even across days.
// Stored in localStorage; keep this large but not huge.
const RECENT_PHRASES_MAX = 6000;
const RECENT_PHRASES_KEY = "sculpture_poems_recent_phrases_v1";
let recentPhraseQueue = [];
let recentPhraseSet = new Set();
let recentPhraseCount = new Map();
let recentPhraseSaveTimer = null;

function loadRecentPhrases(){
try{
const raw = localStorage.getItem(RECENT_PHRASES_KEY);
if(!raw) return;
const arr = JSON.parse(raw);
if(!Array.isArray(arr)) return;
const clean = arr.map(x => String(x || "").trim()).filter(Boolean);
recentPhraseQueue = clean.slice(-RECENT_PHRASES_MAX);
recentPhraseSet = new Set(recentPhraseQueue);
recentPhraseCount = new Map();
for(const k of recentPhraseQueue){
recentPhraseCount.set(k, (recentPhraseCount.get(k) || 0) + 1);
}
}catch(e){}
}

function scheduleSaveRecentPhrases(){
if(recentPhraseSaveTimer) return;
recentPhraseSaveTimer = window.setTimeout(()=>{
recentPhraseSaveTimer = null;
try{
localStorage.setItem(
RECENT_PHRASES_KEY,
JSON.stringify(recentPhraseQueue.slice(-RECENT_PHRASES_MAX))
);
}catch(e){}
}, 1200);
}

function rememberRecentPhrase(p){
const s = String(p || "").trim();
if(!s) return;
recentPhraseQueue.push(s);
recentPhraseSet.add(s);
recentPhraseCount.set(s, (recentPhraseCount.get(s) || 0) + 1);
while(recentPhraseQueue.length > RECENT_PHRASES_MAX){
const old = recentPhraseQueue.shift();
const nextCount = (recentPhraseCount.get(old) || 0) - 1;
if(nextCount <= 0){
recentPhraseCount.delete(old);
recentPhraseSet.delete(old);
}else{
recentPhraseCount.set(old, nextCount);
}
}
scheduleSaveRecentPhrases();
}

const RECENT_COLOR_COMBOS_MAX = 2800;
const RECENT_COLOR_COMBOS_KEY = "sculpture_poems_recent_color_combos_v1";
let recentColorComboQueue = [];
let recentColorComboSet = new Set();
let recentColorComboCount = new Map();
let recentColorComboSaveTimer = null;
const colorComboPoolCache = { sig: "", pool: [] };

function colorComboKey(bgHex, fgHex, bdHex){
return `${normHex(bgHex)}|${normHex(fgHex)}|${normHex(bdHex)}`;
}

function loadRecentColorCombos(){
try{
const raw = localStorage.getItem(RECENT_COLOR_COMBOS_KEY);
if(!raw) return;
const arr = JSON.parse(raw);
if(!Array.isArray(arr)) return;
const clean = arr.map(x => String(x || "").trim()).filter(Boolean);
recentColorComboQueue = clean.slice(-RECENT_COLOR_COMBOS_MAX);
recentColorComboSet = new Set(recentColorComboQueue);
recentColorComboCount = new Map();
for(const k of recentColorComboQueue){
recentColorComboCount.set(k, (recentColorComboCount.get(k) || 0) + 1);
}
}catch(e){}
}

function scheduleSaveRecentColorCombos(){
if(recentColorComboSaveTimer) return;
recentColorComboSaveTimer = window.setTimeout(()=>{
recentColorComboSaveTimer = null;
try{
localStorage.setItem(
RECENT_COLOR_COMBOS_KEY,
JSON.stringify(recentColorComboQueue.slice(-RECENT_COLOR_COMBOS_MAX))
);
}catch(e){}
}, 1200);
}

function rememberRecentColorCombo(bgHex, fgHex, bdHex){
const key = colorComboKey(bgHex, fgHex, bdHex);
if(!key) return;
recentColorComboQueue.push(key);
recentColorComboSet.add(key);
recentColorComboCount.set(key, (recentColorComboCount.get(key) || 0) + 1);
while(recentColorComboQueue.length > RECENT_COLOR_COMBOS_MAX){
const old = recentColorComboQueue.shift();
const nextCount = (recentColorComboCount.get(old) || 0) - 1;
if(nextCount <= 0){
recentColorComboCount.delete(old);
recentColorComboSet.delete(old);
}else{
recentColorComboCount.set(old, nextCount);
}
}
scheduleSaveRecentColorCombos();
}

function getScopeColorPool(setRef){
const pool = unionColorsFrom(setRef);
return pool.length ? pool : ALL_SWATCH_COLORS.slice();
}

function getColorComboPool(){
const bgPool = getScopeColorPool(sel.bgColor);
const fgPool = getScopeColorPool(sel.fgColor);
const bdPool = getScopeColorPool(sel.bdColor);

const sig = `bg:${bgPool.join(",")}|fg:${fgPool.join(",")}|bd:${bdPool.join(",")}`;
if(colorComboPoolCache.sig === sig && colorComboPoolCache.pool.length){
return { sig, pool: colorComboPoolCache.pool };
}

const pool = [];
for(const bg of bgPool){
const bgN = normHex(bg);
for(const fg of fgPool){
const fgN = normHex(fg);
if(fgN === bgN) continue;
for(const bd of bdPool){
const bdN = normHex(bd);
if(bdN === bgN || bdN === fgN) continue;
pool.push(colorComboKey(bgN, fgN, bdN));
}
}
}

colorComboPoolCache.sig = sig;
colorComboPoolCache.pool = pool;
return { sig, pool };
}

function parseColorComboKey(key){
const [bgRaw, fgRaw, bdRaw] = String(key || "").split("|");
return {
bgBase: normHex(bgRaw || ""),
fgBase: normHex(fgRaw || ""),
bdBase: normHex(bdRaw || "")
};
}

function pickNextColorCombo(){
const { pool } = getColorComboPool();
if(!pool.length){
return {
bgBase: current.bgBase || "#ffffff",
fgBase: current.fgBase || "#000000",
bdBase: current.bdBase || "#4d4d4d"
};
}

const currentKey = colorComboKey(current.bgBase, current.fgBase, current.bdBase);
const currentCard = normHex(current.bdBase);
const bdPool = getScopeColorPool(sel.bdColor);
const avoidSameCard = bdPool.length > 1;
const randomKey = ()=> pool[(Math.random() * pool.length) | 0];
const MAX_TRIES = Math.min(Math.max(pool.length * 2, 120), 1000);
let fallbackPick = null;
for(let tries = 0; tries < MAX_TRIES; tries++){
const key = randomKey();
if(pool.length > 1 && key === currentKey) continue;
const pick = parseColorComboKey(key);
if(!pick.bgBase || !pick.fgBase || !pick.bdBase) continue;
if(!fallbackPick) fallbackPick = pick;
if(avoidSameCard && pick.bdBase === currentCard) continue;
rememberRecentColorCombo(pick.bgBase, pick.fgBase, pick.bdBase);
return pick;
}

// Deterministic fallback: scan pool once to honor guards if possible.
if(pool.length){
const start = (Math.random() * pool.length) | 0;
let scanFallback = null;
for(let i=0; i<pool.length; i++){
const key = pool[(start + i) % pool.length];
if(pool.length > 1 && key === currentKey) continue;
const pick = parseColorComboKey(key);
if(!pick.bgBase || !pick.fgBase || !pick.bdBase) continue;
if(!scanFallback) scanFallback = pick;
if(avoidSameCard && pick.bdBase === currentCard) continue;
rememberRecentColorCombo(pick.bgBase, pick.fgBase, pick.bdBase);
return pick;
}
if(scanFallback){
rememberRecentColorCombo(scanFallback.bgBase, scanFallback.fgBase, scanFallback.bdBase);
return scanFallback;
}
}

if(fallbackPick){
rememberRecentColorCombo(fallbackPick.bgBase, fallbackPick.fgBase, fallbackPick.bdBase);
return fallbackPick;
}

return {
bgBase: current.bgBase || "#ffffff",
fgBase: current.fgBase || "#000000",
bdBase: current.bdBase || "#4d4d4d"
};
}

function pickStartupColorCombo(){
const { pool } = getColorComboPool();
if(!pool.length){
return {
bgBase: current.bgBase || "#ffffff",
fgBase: current.fgBase || "#000000",
bdBase: current.bdBase || "#4d4d4d"
};
}
const key = pool[(Math.random() * pool.length) | 0];
const pick = parseColorComboKey(key);
if(pick.bgBase && pick.fgBase && pick.bdBase){
return pick;
}
return {
bgBase: current.bgBase || "#ffffff",
fgBase: current.fgBase || "#000000",
bdBase: current.bdBase || "#4d4d4d"
};
}

function clonePhraseParts(parts){
if(!parts || typeof parts !== "object") return null;
return {
desc: safeStr(parts.desc),
obj: safeStr(parts.obj),
person: safeStr(parts.person),
actRaw: safeStr(parts.actRaw),
locRaw: safeStr(parts.locRaw)
};
}

function buildPhrasePartsSeed(partsSet){
const useObj = partsSet.has("object");
const usePerson = partsSet.has("person") && !useObj;
return {
desc: safeStr(pickDescriptor(useObj, usePerson)),
obj: safeStr(pickObject()),
person: safeStr(pickPerson()),
actRaw: safeStr(pickAction()),
locRaw: safeStr(pickLocation())
};
}

function composePhraseFromParts(partsSet, partsData){
const useDesc = partsSet.has("description");
const useObj = partsSet.has("object");
const usePerson = partsSet.has("person") && !useObj;
const useAct = partsSet.has("action");
const useLoc = partsSet.has("location");
if(!useDesc && !useObj && !usePerson && !useAct && !useLoc) return "";
const p = clonePhraseParts(partsData) || {
desc: "",
obj: "",
person: "",
actRaw: "",
locRaw: ""
};

const desc = useDesc ? p.desc : "";
const obj = useObj ? p.obj : "";
const person = usePerson ? p.person : "";
let act = useAct ? p.actRaw : "";
let loc = useLoc ? p.locRaw : "";

// If object isn't present, pronouns in action/location can map to person pronouns.
if(!useObj){
if(useAct && act) act = swapItPronounsForPerson(act);
if(useLoc && loc) loc = swapItPronounsForPerson(loc);
}

let out = "";
if(useDesc && desc) out += desc + " ";
if(useObj && obj) out += obj;
if(usePerson && person) out += person;
if(useAct && act) out += (out ? " " : "") + act;
if(useLoc && loc) out += (out ? " " : "") + loc;
return out.replace(/\s+/g," ").trim();
}

function buildPhrase(partsSet, opts = {}){
const fromCurrent = !!opts.fromCurrent;
const remember = opts.remember !== false;

if(fromCurrent){
const currentParts = clonePhraseParts(opts.partsData || current.phraseParts);
if(currentParts){
const out = composePhraseFromParts(partsSet, currentParts);
if(out && remember) rememberRecentPhrase(out);
current.phraseParts = currentParts;
return out;
}
}

let lastOut = "";
let lastParts = null;
const MAX_TRIES = 600;

for(let tries=0; tries<MAX_TRIES; tries++){
const partsData = buildPhrasePartsSeed(partsSet);
const out = composePhraseFromParts(partsSet, partsData);
if(!out) continue;
lastOut = out;
lastParts = partsData;

if(!recentPhraseSet.has(out)){
if(remember) rememberRecentPhrase(out);
current.phraseParts = clonePhraseParts(partsData);
return out;
}
}

if(lastParts) current.phraseParts = clonePhraseParts(lastParts);
if(lastOut && remember) rememberRecentPhrase(lastOut);
return lastOut;
}

/* ================= Color selection ================= */
function unionColorsFrom(selectedValues){
// Supports both palette names and direct hex colors.
const vals = Array.from(selectedValues || [])
.map(v => String(v || "").trim().toLowerCase())
.filter(Boolean);

const hexVals = vals
.filter(v => /^#(?:[0-9a-f]{3}|[0-9a-f]{6})$/i.test(v))
.sort();
const palNames = vals
.filter(v => !!PAL[v])
.sort();

let out = hexVals.slice();
for(const n of palNames){
const pal = PAL[n];
if(pal && pal.length) out = out.concat(pal.map((c)=> String(c || "").trim().toLowerCase()));
}
return uniq(out);
}

function pickColorNonRepeating(key, paletteSet, excludeHexSet){
const pool = unionColorsFrom(paletteSet);
const basePool = pool;
if(!basePool.length) return null;
const avoid = new Set((excludeHexSet ? Array.from(excludeHexSet) : []).map(normHex));
if(!avoid.size) return bagNext(key, basePool);

// Important: we always draw from the same (stable) pool for this key so the shuffle bag
// can complete a full cycle before repeating. If a draw hits an avoided color, we consume
// it and keep going (so it can come back after the bag resets).
const maxTries = Math.max(1, basePool.length);
for(let i=0; i<maxTries; i++){
const c = bagNext(key, basePool);
if(!avoid.has(normHex(c))) return c;
}
// If everything is avoided, just return the next color anyway.
return bagNext(key, basePool);
}

function consumeColorFromBag(key, paletteSet, targetHex){
const pool = unionColorsFrom(paletteSet);
const allPool = uniq(Object.values(PAL).flat());
const basePool = pool.length ? pool : allPool;
const targetN = normHex(targetHex);
for(let i=0; i<basePool.length; i++){
const c = bagNext(key, basePool);
if(normHex(c) === targetN) return c;
}
return bagNext(key, basePool) || targetHex;
}

/* ================= Current frame ================= */
const current = {
phrase: "",
phraseParts: null,
bgBase: "#F7C6D0",
fgBase: "#231423",
bdBase: "#231423"
};

const last = { phrase:"", bg:"", fg:"", bd:"" };
let timerId = null;
let isFirstFrame = true;
let isPaused = false;
let isCompositionLocked = false;

/* ================= Playback history ================= */
const HISTORY_MAX = 1000;
const sceneHistory = [];
let sceneIndex = -1;

function snapshotScene(){
const palSnap = {};
for(const name of COLOR_OPTS){
palSnap[name] = palCycleIndex[name] ?? 0;
}
return {
phrase: current.phrase,
phraseParts: clonePhraseParts(current.phraseParts),
bgBase: current.bgBase,
fgBase: current.fgBase,
bdBase: current.bdBase,
palCycleIndex: palSnap
};
}

function syncHistoryButtons(){
if(prevPoemBtn) prevPoemBtn.disabled = sceneIndex <= 0;
}

function restoreSceneAt(index){
if(index < 0 || index >= sceneHistory.length) return;
const sc = sceneHistory[index];
sceneIndex = index;

current.phrase = String(sc.phrase || "");
current.phraseParts = clonePhraseParts(sc.phraseParts);
current.bgBase = String(sc.bgBase || current.bgBase);
current.fgBase = String(sc.fgBase || current.fgBase);
current.bdBase = String(sc.bdBase || current.bdBase);

if(sc.palCycleIndex){
for(const name of COLOR_OPTS){
if(sc.palCycleIndex[name] != null) palCycleIndex[name] = sc.palCycleIndex[name];
}
}

phraseEl.innerHTML = formatPhraseText(current.phrase);
smartPhraseWidth();
applyColorsLive();
syncHistoryButtons();
}

function commitGeneratedScene(){
const sc = snapshotScene();

if(sceneIndex >= 0 && sceneIndex < sceneHistory.length - 1){
sceneHistory.splice(sceneIndex + 1);
}

sceneHistory.push(sc);
sceneIndex = sceneHistory.length - 1;

if(sceneHistory.length > HISTORY_MAX){
const drop = sceneHistory.length - HISTORY_MAX;
sceneHistory.splice(0, drop);
sceneIndex = Math.max(0, sceneIndex - drop);
}

syncHistoryButtons();
}

function syncPauseBtn(){
if(!pausePoemBtn) return;
pausePoemBtn.classList.toggle("paused", isPaused);
pausePoemBtn.setAttribute("aria-pressed", isPaused ? "true" : "false");
pausePoemBtn.setAttribute("aria-label", isPaused ? "play (space)" : "pause (space)");
pausePoemBtn.dataset.tip = "pause";
}

function setPaused(paused){
const next = !!paused;
if(isPaused === next) return;
isPaused = next;
syncPauseBtn();
if(isPaused){
if(timerId) clearTimeout(timerId);
timerId = null;
return;
}
scheduleTick();
}

function togglePaused(){
setPaused(!isPaused);
}

function syncCompositionLockBtn(){
if(!lockCompositionBtn) return;
lockCompositionBtn.classList.toggle("locked", isCompositionLocked);
lockCompositionBtn.classList.toggle("on", isCompositionLocked);
lockCompositionBtn.setAttribute("aria-pressed", isCompositionLocked ? "true" : "false");
lockCompositionBtn.setAttribute("aria-label", isCompositionLocked ? "unlock composition" : "lock composition");
lockCompositionBtn.dataset.tip = isCompositionLocked ? "unlock" : "lock";
lockCompositionBtn.title = isCompositionLocked ? "unlock composition" : "lock composition";
}
function toggleCompositionLock(){
isCompositionLocked = !isCompositionLocked;
syncCompositionLockBtn();
}

function goPrevPoem(){
if(sceneIndex <= 0) return;
setPaused(true);
restoreSceneAt(sceneIndex - 1);
}

function goNextPoem(){
setPaused(true);
// In lock mode, "forward" should always generate a new phrase
// while preserving the current visual composition.
if(isCompositionLocked){
nextFrame();
return;
}
if(sceneIndex < sceneHistory.length - 1){
restoreSceneAt(sceneIndex + 1);
return;
}
// At the end: generate a new one (manual step-forward).
nextFrame();
}

function setCalmStart(){
// First load should always start from a random valid combo.
const combo = pickStartupColorCombo();
current.bgBase = combo.bgBase || current.bgBase;
current.fgBase = combo.fgBase || current.fgBase;
current.bdBase = combo.bdBase || current.bdBase;
rememberRecentColorCombo(current.bgBase, current.fgBase, current.bdBase);
}

/* ================= UI builders ================= */
function syncSentenceStructureUI(){
const container = document.getElementById("partsRow");
if(container){
Array.from(container.querySelectorAll(".ssBtn")).forEach((btn)=>{
const name = String(btn.dataset.part || "").toLowerCase();
const on = sel.parts.has(name);
btn.classList.toggle("on", on);
btn.setAttribute("aria-pressed", on ? "true" : "false");
});
}
}

function renderSentenceButtons(){
const container = document.getElementById("partsRow");
if(!container) return;
container.innerHTML = "";

for(const opt of PART_OPTS){
const b = document.createElement("button");
b.type = "button";
b.className = "ssBtn";
b.textContent = opt;
b.dataset.part = opt;

b.addEventListener("click", ()=>{
if(opt === "object" && !sel.parts.has("object")){
// Object poems shortcut: selecting object snaps to object + location.
sel.parts = new Set(["object", "location"]);
syncSentenceStructureUI();
updatePhraseLive();
showUI();
return;
}

const isObjOrPerson = (opt === "object" || opt === "person");
const enabling = !sel.parts.has(opt);
if(isObjOrPerson && enabling){
// Mutually exclusive: you can enable either object or person, but never both.
if(opt === "object") sel.parts.delete("person");
if(opt === "person") sel.parts.delete("object");
}

if(sel.parts.has(opt)) sel.parts.delete(opt); else sel.parts.add(opt);
if(sel.parts.size === 0) sel.parts.add(opt);
syncSentenceStructureUI();
updatePhraseLive();
showUI();
});

container.appendChild(b);
}

syncSentenceStructureUI();
}

function updatePhraseLive(){
const p = buildPhrase(sel.parts, { fromCurrent: true, remember: false });
current.phrase = p;
phraseEl.innerHTML = formatPhraseText(current.phrase);
last.phrase = current.phrase;
smartPhraseWidth();
applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
commitGeneratedScene();
}

function refreshSentenceButtonColors(){
document.querySelectorAll("#partsRow .ssBtn").forEach(btn=>{
btn.style.removeProperty("--ssPal");
btn.style.removeProperty("--ssBg");
});
}

let colorScope = "bd"; // bg | fg | bd

function getColorScopeSet(scope = colorScope){
if(scope === "fg") return sel.fgColor;
if(scope === "bd") return sel.bdColor;
return sel.bgColor;
}

function setColorScopeBtnState(btn, on){
if(!btn) return;
btn.classList.toggle("on", !!on);
btn.setAttribute("aria-pressed", on ? "true" : "false");
}

function syncBulkColorButtons(){
const setRef = getColorScopeSet(colorScope);
const total = ALL_SWATCH_COLORS.length;
setColorScopeBtnState(allOnBtn, setRef.size >= total);
setColorScopeBtnState(allOffBtn, setRef.size === 0);
}

function getFirstSetColor(setRef, fallbackHex){
if(setRef && setRef.size){
const first = setRef.values().next().value;
if(first) return String(first);
}
return String(fallbackHex || "#000000");
}

function ensureCurrentBaseColorsValid(){
const bgSet = sel.bgColor;
const fgSet = sel.fgColor;
const bdSet = sel.bdColor;

if(!bgSet.size){
current.bgBase = "#ffffff";
}else if(!bgSet.has(normHex(current.bgBase))){
current.bgBase = getFirstSetColor(bgSet, current.bgBase);
}

if(!fgSet.size){
current.fgBase = "#000000";
}else if(!fgSet.has(normHex(current.fgBase))){
current.fgBase = getFirstSetColor(fgSet, current.fgBase);
}

if(!bdSet.size){
current.bdBase = "#4d4d4d";
}else if(!bdSet.has(normHex(current.bdBase))){
current.bdBase = getFirstSetColor(bdSet, current.bdBase);
}
}

function syncColorScopeButtons(){
setColorScopeBtnState(scopeBgBtn, colorScope === "bg");
setColorScopeBtnState(scopeFgBtn, colorScope === "fg");
setColorScopeBtnState(scopeBdBtn, colorScope === "bd");
syncBulkColorButtons();
}

function setCurrentScopeAll(on){
const setRef = getColorScopeSet(colorScope);
if(on){
setRef.clear();
for(const hex of ALL_SWATCH_COLORS) setRef.add(hex);
// Immediately restore a vivid base color for the active scope.
if(colorScope === "bg"){
const nextBg = pickColorNonRepeating("bg", sel.bgColor, new Set());
current.bgBase = nextBg || getFirstSetColor(sel.bgColor, current.bgBase);
}else if(colorScope === "fg"){
const nextFg = pickColorNonRepeating("fg", sel.fgColor, new Set([current.bgBase]));
current.fgBase = nextFg || getFirstSetColor(sel.fgColor, current.fgBase);
}else{
const nextBd = pickColorNonRepeating("bd", sel.bdColor, new Set([current.bgBase, current.fgBase]));
current.bdBase = nextBd || getFirstSetColor(sel.bdColor, current.bdBase);
}
}else{
setRef.clear();
}
ensureCurrentBaseColorsValid();
applyColorsLive();
syncAllSwatchSelection();
syncBulkColorButtons();
}

function setColorScope(scope){
const next = (scope === "fg" || scope === "bd") ? scope : "bg";
colorScope = next;
syncColorScopeButtons();
syncAllSwatchSelection();
}

function syncAllSwatchSelection(){
const setRef = getColorScopeSet(colorScope);
document.querySelectorAll("#allColorsRow .swatch").forEach((btn)=>{
const hex = normHex(btn.dataset.hex);
btn.classList.toggle("on", setRef.has(hex));
});
}

function renderAllSwatches(){
const rowEl = document.getElementById("allColorsRow");
if(!rowEl) return;
rowEl.innerHTML = "";

for(const hex of ALL_SWATCH_COLORS){
const sw = document.createElement("button");
sw.type = "button";
sw.className = "swatch";
sw.dataset.hex = hex;
sw.style.setProperty("--fillCol", hex);

sw.addEventListener("click", ()=>{
const setRef = getColorScopeSet(colorScope);
const on = setRef.has(hex);
if(on){
setRef.delete(hex);
}else{
setRef.add(hex);
}
ensureCurrentBaseColorsValid();
applyColorsLive();
syncAllSwatchSelection();
syncBulkColorButtons();
});

rowEl.appendChild(sw);
}

setColorScope(colorScope);
}

function refreshSwatchColors(){
document.querySelectorAll("#allColorsRow .swatch").forEach((sw)=>{
const hex = normHex(sw.dataset.hex);
sw.style.setProperty("--fillCol", hex);
});
}

function applyButtonColors(){
const cardLive = applyDimmer(current.bdBase, Number(bdBrightEl.value));
const uiFg = getFgLiveHex() || "#000000";

document.documentElement.style.setProperty("--cardUiBg", cardLive);
document.documentElement.style.setProperty("--cardUiFg", uiFg);

[
prevPoemBtn, pausePoemBtn, nextPoemBtn,
screenshotBtn, fsBtn, lockCompositionBtn,
tabLanguageBtn, tabContrastBtn, tabColorsBtn, tabSpeedBtn, tabInfoBtn,
scopeBgBtn, scopeFgBtn, scopeBdBtn, allOnBtn, allOffBtn,
bdToggleBtn
].forEach((btn)=>{
if(!btn) return;
btn.style.setProperty("--btnBg", cardLive);
btn.style.color = uiFg;
});
syncMenuToggleColor(cardLive, uiFg);
}

function syncMenuToggleColor(cardHex, fgHex){
if(!menuToggleBtn) return;
const bg = normHex(cardHex || current.bdBase || "#000000");
const fg = normHex(fgHex || getFgLiveHex() || "#000000");
menuToggleBtn.style.setProperty("--menuBg", bg);
menuToggleBtn.style.setProperty("--menuFg", fg);
}

function syncSwatchHeaderWidths(){
requestAnimationFrame(()=>{
document.querySelectorAll(".swatchRow").forEach(row=>{
const wrap = row.parentElement;
const header = wrap ? wrap.querySelector(".swatchHeader") : null;
const bright = wrap ? wrap.querySelector(".brightCtrl") : null;
if(!header) return;
const w = row.getBoundingClientRect().width;
header.style.width = w > 0 ? `${w}px` : "auto";
header.style.marginLeft = "auto";
header.style.marginRight = "auto";
row.style.marginLeft = "auto";
row.style.marginRight = "auto";

if(bright){
bright.style.width = w > 0 ? `${w}px` : "auto";
bright.style.marginLeft = "auto";
bright.style.marginRight = "auto";
}
});
});
}

function applySliderThumbColors(){
sliderEls.forEach((el, i)=>{
const palName = SLIDER_PALS[i % SLIDER_PALS.length];
const pal = PAL[palName] || [];
const offset = pal.length ? (i % pal.length) : 0;
const col = paletteColor(palName, offset);
el.style.setProperty("--thumbCol", col);
});
}

function applyAccentColors(){
refreshSwatchColors();
refreshSentenceButtonColors();
applySliderThumbColors();
applyButtonColors();
}

/* ================= Type + layout ================= */
function applyTypeAndLayout(){
const sizePct = clamp(Number(sizeEl.value), 0, 150);
let scale = 0.02;
if(sizePct > 0 && sizePct <= 100){
scale = 0.02 + (1.6 - 0.02) * (sizePct / 100);
}else if(sizePct > 100){
scale = 1.6 + (3.5 - 1.6) * ((sizePct - 100) / 50);
}
document.documentElement.style.setProperty("--textScale", scale);
sizeVal.textContent = `${Math.round(sizePct)}%`;

const y = clamp(Number(yEl.value), 0, 100);
document.documentElement.style.setProperty("--yPct", `${y}%`);
yVal.textContent = `${Math.round(y)}%`;

const w = clamp(Number(widthEl.value), 0, 100);
widthVal.textContent = `${Math.round(w)}%`;

smartPhraseWidth();
centerPoemMidpointIfMobile();
}

function phraseInkRects(){
try{
const r = document.createRange();
r.selectNodeContents(phraseEl);
return Array.from(r.getClientRects()).filter(x => x.width > 0 && x.height > 0);
}catch(e){
return [];
}
}
function phraseInkBounds(){
const rects = phraseInkRects();
if(!rects.length) return null;
let left = Infinity, right = -Infinity, top = Infinity, bottom = -Infinity;
for(const r of rects){
left = Math.min(left, r.left);
right = Math.max(right, r.right);
top = Math.min(top, r.top);
bottom = Math.max(bottom, r.bottom);
}
if(!Number.isFinite(left) || !Number.isFinite(right) || !Number.isFinite(top) || !Number.isFinite(bottom)) return null;
return { left, right, top, bottom, width: right - left, height: bottom - top };
}

let centerPoemMidpointBusy = false;
function centerPoemMidpointIfMobile(){
const isMobileViewport =
window.matchMedia("(pointer: coarse)").matches ||
(navigator.maxTouchPoints || 0) > 0;
if(!isMobileViewport) return;
if(centerPoemMidpointBusy) return;

const { h } = getViewportSize();
if(!Number.isFinite(h) || h <= 0) return;

const cardShown = !!cardEl && getComputedStyle(cardEl).display !== "none";
const r = cardShown ? cardEl.getBoundingClientRect() : (phraseInkBounds() || phraseEl.getBoundingClientRect());
if(!r || !Number.isFinite(r.top) || !Number.isFinite(r.bottom)) return;

const mid = (r.top + r.bottom) * 0.5;
const target = h * 0.5;
const dy = target - mid;
if(Math.abs(dy) < 0.5) return;

const currentY = clamp(Number(yEl.value), 0, 100);
const nextY = clamp(currentY + ((dy / h) * 100), 0, 100);
if(Math.abs(nextY - currentY) < 0.01) return;

centerPoemMidpointBusy = true;
yEl.value = String(nextY);
document.documentElement.style.setProperty("--yPct", `${nextY}%`);
yVal.textContent = `${Math.round(nextY)}%`;
applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
centerPoemMidpointBusy = false;
}

function fitPhraseToBox(){
if(Math.abs(sceneZoom - 1) > 0.001){
// Keep manual drag/pinch zoom authoritative.
applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
return;
}

const sizePct = clamp(Number(sizeEl.value), 0, 150);
if(sizePct <= 0){
document.documentElement.style.setProperty("--fitScale", "1");
applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
return;
}
if(sizePct >= 150){
document.documentElement.style.setProperty("--fitScale", "1");
applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
return;
}
const text = (phraseEl.textContent || "").trim();
if(!text){
document.documentElement.style.setProperty("--fitScale", "1");
applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
return;
}

document.documentElement.style.setProperty("--fitScale", "1");
const rect = phraseInkBounds() || phraseEl.getBoundingClientRect();
if(rect.width <= 0 || rect.height <= 0){
document.documentElement.style.setProperty("--fitScale", "1");
applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
return;
}

const { w: vw, h: vh } = getViewportSize();
const edgePad = getRootVarPx("--edgePad");
const wVar = getRootVarVw("--phraseW");
const widthPct = (wVar ? wVar : clamp(Number(widthEl.value), 1, 100)) / 100;

const maxW = Math.min(vw * widthPct, vw - (edgePad * 2));
const maxH = vh - (edgePad * 2);

let scale = Math.min(maxW / rect.width, maxH / rect.height, 1);
if(!Number.isFinite(scale) || scale <= 0) scale = 1;
scale = clamp(scale, 0.01, 1);

document.documentElement.style.setProperty("--fitScale", scale.toFixed(3));
applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
}

function widenPhraseToAvoidOverfullLines(){
// If a line is "overfull" (a word is wider than the box), browsers fall back to start-alignment
// and our card bounds can be wrong. Clamp the box to at least the scroll width to keep it centered.
const { w: vw } = getViewportSize();
if(vw <= 0) return;

// A couple passes handles cases where max-width / edge padding clamps the first widening attempt.
for(let i=0; i<2; i++){
const boxW = phraseEl.getBoundingClientRect().width;
if(boxW <= 0) return;

const scrollW = phraseEl.scrollWidth || 0;
if(scrollW <= boxW + 0.5) return;

const needVw = clamp(((scrollW + 2) / vw) * 100, 1, 100);
const curVw = getRootVarVw("--phraseW") ?? clamp(Number(widthEl.value), 1, 100);
const nextVw = clamp(Math.max(curVw, needVw), 1, 100);

document.documentElement.style.setProperty("--phraseW", `${nextVw.toFixed(2)}vw`);
if(nextVw >= 100){
document.documentElement.style.setProperty("--edgePad", "0px");
return;
}
}

// If we're still overfull, the edge padding is clamping max-width; drop it.
const boxW = phraseEl.getBoundingClientRect().width;
const scrollW = phraseEl.scrollWidth || 0;
if(scrollW > boxW + 0.5){
document.documentElement.style.setProperty("--edgePad", "0px");
document.documentElement.style.setProperty("--phraseW", "100vw");
}
}

function phraseHasOverfullLine(){
const boxW = phraseEl.getBoundingClientRect().width;
if(boxW <= 0) return false;
const scrollW = phraseEl.scrollWidth || 0;
return scrollW > (boxW + 0.5);
}

function buildWidthSearchOrder(center, minW, maxW, step=1){
const out = [];
const seen = new Set();
const push = (v)=>{
const n = Math.round((v / step)) * step;
const c = clamp(n, minW, maxW);
const key = c.toFixed(3);
if(seen.has(key)) return;
seen.add(key);
out.push(c);
};
push(center);
for(let d = step; d <= (maxW - minW + step); d += step){
push(center - d);
push(center + d);
}
return out;
}

function getPhraseLineStats(){
const lineRects = groupClientRectsIntoLines(phraseInkRects());
if(!lineRects.length) return null;

const widths = lineRects.map((r)=>Math.max(1, r.width));
const maxW = Math.max(...widths);
const minW = Math.min(...widths);
const lastW = widths[widths.length - 1];
const lastRatio = lastW / Math.max(1, maxW);

const mean = widths.reduce((a,b)=>a+b, 0) / widths.length;
const variance = widths.reduce((acc, w)=> acc + Math.pow(w - mean, 2), 0) / widths.length;
const relStdDev = Math.sqrt(variance) / Math.max(1, mean);

const renderedLines = getRenderedLinesForScreenshot();
const fullText = renderedLines.join(" ").replace(/\s+/g, " ").trim();
const lineWordCounts = renderedLines.map((line)=>{
const t = String(line || "").trim();
return t ? t.split(/\s+/).filter(Boolean).length : 0;
});
const singleWordLineCount = lineWordCounts.filter((n)=>n === 1).length;
const totalWords = lineWordCounts.reduce((sum, n)=> sum + n, 0);
const totalChars = fullText.length;
const lastLineText = renderedLines.length ? String(renderedLines[renderedLines.length - 1]).trim() : "";
const lastWords = lastLineText ? lastLineText.split(/\s+/).filter(Boolean).length : 0;

return {
lineCount: widths.length,
widths,
maxW,
minW,
lastW,
lastRatio,
relStdDev,
lineWordCounts,
singleWordLineCount,
totalWords,
totalChars,
lastWords
};
}

function hasSingleWordLine(stats){
if(!stats || stats.lineCount <= 1) return false;
return (stats.singleWordLineCount || 0) > 0;
}

function shouldAvoidSingleLine(stats){
if(!stats || stats.lineCount !== 1) return false;
const words = Number(stats.totalWords || 0);
const chars = Number(stats.totalChars || 0);
return words >= 7 || chars >= 42;
}

function scorePhraseLineBalance(stats){
if(!stats) return Infinity;
if(stats.lineCount <= 1){
if(shouldAvoidSingleLine(stats)){
const words = Number(stats.totalWords || 0);
const chars = Number(stats.totalChars || 0);
const wordPenalty = Math.max(0, words - 6) * 2.4;
const charPenalty = Math.max(0, chars - 34) * 0.22;
return 16 + wordPenalty + charPenalty;
}
return 0;
}

let score = 0;
// Strongly discourage any one-word wrapped lines.
if(hasSingleWordLine(stats)){
score += 20 + ((stats.singleWordLineCount || 0) * 18);
}
// Penalize very short final lines and true widows.
score += Math.max(0, 0.66 - stats.lastRatio) * 5.5;
if(stats.lastWords === 1) score += 2.6;
else if(stats.lastWords === 2) score += 0.8;

// Penalize uneven line distribution.
score += stats.relStdDev * 2.0;

// For two-line phrases, require stronger balance.
if(stats.lineCount === 2 && stats.lastRatio < 0.78){
score += (0.78 - stats.lastRatio) * 4.2;
}
return score;
}

function smartPhraseWidth(){
const base = clamp(Number(widthEl.value), 1, 100);
phraseEl.classList.remove("oneWord");
document.documentElement.style.setProperty("--phraseW", `${base}vw`);
document.documentElement.style.setProperty("--edgePad", base >= 100 ? "0px" : "50px");
document.documentElement.style.setProperty("--fitScale", "1");
widenPhraseToAvoidOverfullLines();

const text = (phraseEl.textContent || "").trim();
if(!text){
fitPhraseToBox();
return;
}

const currentW = getRootVarVw("--phraseW") ?? base;
const currentStats = getPhraseLineStats();
if(!currentStats){
fitPhraseToBox();
return;
}

let bestW = currentW;
let bestStats = currentStats;
let bestScore = scorePhraseLineBalance(currentStats);

// If a one-word line or a long single-line poem appears, aggressively reflow width.
const needsSingleLineFix = shouldAvoidSingleLine(currentStats);
const needsWidowFix = hasSingleWordLine(currentStats);
const minSearchW = (needsWidowFix || needsSingleLineFix) ? 1 : clamp(currentW - 14, 1, 100);
const maxSearchW = needsWidowFix
? 100
: (needsSingleLineFix
? clamp(currentW, 1, 100)
: clamp(Math.min(100, currentW + 14), 1, 100));
const candidates = buildWidthSearchOrder(currentW, minSearchW, maxSearchW, 1);

for(const candidateW of candidates){
document.documentElement.style.setProperty("--phraseW", `${candidateW.toFixed(2)}vw`);
if(phraseHasOverfullLine()) continue;

const stats = getPhraseLineStats();
if(!stats) continue;
const score = scorePhraseLineBalance(stats);
const candidateTier =
(needsSingleLineFix && shouldAvoidSingleLine(stats)) ? 2 :
(hasSingleWordLine(stats) ? 1 : 0);
const bestTier =
(needsSingleLineFix && shouldAvoidSingleLine(bestStats)) ? 2 :
(hasSingleWordLine(bestStats) ? 1 : 0);

const tierWin = candidateTier < bestTier;
const sameTier = candidateTier === bestTier;

const strongWin = sameTier && (score < (bestScore - 0.08));
const tieWin =
sameTier &&
Math.abs(score - bestScore) <= 0.08 &&
Math.abs(candidateW - base) < Math.abs(bestW - base);
if(tierWin || strongWin || tieWin){
bestScore = score;
bestW = candidateW;
bestStats = stats;
}
}

document.documentElement.style.setProperty("--phraseW", `${bestW.toFixed(2)}vw`);
fitPhraseToBox();
}

function groupClientRectsIntoLines(rects){
const out = [];
const sorted = rects.slice().sort((a,b)=> (a.top - b.top) || (a.left - b.left));
const EPS = 2.0;
for(const r of sorted){
let line = null;
for(const l of out){
if(Math.abs(l.top - r.top) <= EPS){
line = l;
break;
}
}
if(!line){
out.push({ top: r.top, bottom: r.bottom, left: r.left, right: r.right });
}else{
line.top = Math.min(line.top, r.top);
line.bottom = Math.max(line.bottom, r.bottom);
line.left = Math.min(line.left, r.left);
line.right = Math.max(line.right, r.right);
}
}
return out
.sort((a,b)=> a.top - b.top)
.map(l => ({
top: l.top,
bottom: l.bottom,
left: l.left,
width: l.right - l.left,
height: l.bottom - l.top
}));
}

function getRenderedLinesForScreenshot(){
const raw = String(phraseEl.textContent || "").replace(/\r/g, "");
const text = raw.replace(/\s+/g, " ").trim();
if(!text) return [];

// "one word per line" mode
if(clamp(Number(widthEl.value), 0, 100) === 0){
return text.split(/\s+/).filter(Boolean);
}

// If the DOM contains <br> for any reason, trust it.
if(phraseEl.querySelector("br")){
return String(phraseEl.innerText || "")
.replace(/\r/g, "")
.split("\n")
.map(s => s.trim())
.filter(Boolean);
}

// Normal mode is a single text node (we set innerHTML to plain text).
const node = phraseEl.firstChild;
if(!node || node.nodeType !== Node.TEXT_NODE){
return [text];
}

const words = [];
const re = /\S+/g;
let m;
while((m = re.exec(node.data))){
words.push({ word: m[0], start: m.index, end: m.index + m[0].length });
}
if(!words.length) return [text];

const lines = [];
const range = document.createRange();
const EPS = 2.0;
let curTop = null;
let cur = [];

for(const w of words){
range.setStart(node, w.start);
range.setEnd(node, w.end);
const r = range.getBoundingClientRect();
if(!r || r.width <= 0 || r.height <= 0) continue;
if(curTop == null){
curTop = r.top;
cur.push(w.word);
continue;
}
if(Math.abs(r.top - curTop) <= EPS){
cur.push(w.word);
}else{
if(cur.length) lines.push(cur.join(" "));
cur = [w.word];
curTop = r.top;
}
}
if(cur.length) lines.push(cur.join(" "));

return lines.length ? lines : [text];
}

function takeScreenshot(){
try{
const { w: vw, h: vh } = getViewportSize();
const dpr = Math.max(1, Math.round((window.devicePixelRatio || 1) * 100) / 100);

const canvas = document.createElement("canvas");
canvas.width = Math.max(1, Math.round(vw * dpr));
canvas.height = Math.max(1, Math.round(vh * dpr));
const ctx = canvas.getContext("2d");
if(!ctx) return;
ctx.scale(dpr, dpr);

// Background
ctx.fillStyle = getComputedStyle(document.body).backgroundColor || "#ffffff";
ctx.fillRect(0, 0, vw, vh);

// Card (if enabled)
if(sel.borderEnabled && getComputedStyle(cardEl).display !== "none"){
const r = cardEl.getBoundingClientRect();
if(r.width > 0 && r.height > 0){
ctx.fillStyle = getComputedStyle(cardEl).backgroundColor || "transparent";
ctx.fillRect(r.left, r.top, r.width, r.height);
}
}

// Text
const lines = getRenderedLinesForScreenshot();
if(lines.length){
const cs = getComputedStyle(phraseEl);
const fontSize = cs.fontSize || "48px";
const fontWeight = cs.fontWeight || "600";
const fontFamily = cs.fontFamily || "serif";
const lineHeightPx = parseFloat(cs.lineHeight) || (parseFloat(fontSize) * 1.12);
ctx.font = `${fontWeight} ${fontSize} ${fontFamily}`;
ctx.fillStyle = cs.color || "#000000";
ctx.textAlign = "center";
ctx.textBaseline = "top";

const lineRects = groupClientRectsIntoLines(phraseInkRects());
const n = Math.min(lines.length, lineRects.length);

if(n > 0){
for(let i=0; i<n; i++){
const line = lines[i];
const r = lineRects[i];
ctx.fillText(line, r.left + (r.width / 2), r.top);
}
if(lines.length > n){
const last = lineRects[lineRects.length - 1];
const startY = (last ? last.bottom : (phraseEl.getBoundingClientRect().top));
for(let i=n; i<lines.length; i++){
ctx.fillText(lines[i], vw / 2, startY + ((i - n) * lineHeightPx));
}
}
}else{
const r = phraseEl.getBoundingClientRect();
for(let i=0; i<lines.length; i++){
ctx.fillText(lines[i], vw / 2, r.top + (i * lineHeightPx));
}
}
}

canvas.toBlob((blob)=>{
if(!blob) return;
const now = new Date();
const dateStamp = `${now.getMonth() + 1}.${now.getDate()}.${now.getFullYear()}`;
const pad2 = (n)=> String(n).padStart(2, "0");
const dayKey = `${now.getFullYear()}-${pad2(now.getMonth() + 1)}-${pad2(now.getDate())}`;

let n = 1;
try{
const k = `sculpture_poems_screenshot_counter_${dayKey}`;
const prev = Math.floor(Number(localStorage.getItem(k) || "0"));
n = (Number.isFinite(prev) && prev >= 0) ? (prev + 1) : 1;
localStorage.setItem(k, String(n));
}catch(e){
window.__sculpturePoemsScreenshotN = (window.__sculpturePoemsScreenshotN || 0) + 1;
n = window.__sculpturePoemsScreenshotN;
}

const a = document.createElement("a");
const url = URL.createObjectURL(blob);
a.href = url;
a.download = `Poem-${dateStamp}-${n}.png`;
document.body.appendChild(a);
a.click();
a.remove();
setTimeout(()=> URL.revokeObjectURL(url), 1500);
}, "image/png");
}catch(e){}
}

function flashButtonOnce(btn, ms=140){
if(!btn) return;
btn.classList.add("on");
window.setTimeout(()=> btn.classList.remove("on"), ms);
}
function snapScreenshot(){
flashButtonOnce(screenshotBtn, 160);
takeScreenshot();
}

/* Card behind phrase */
function applyCardStyle(colorHex){
const t = sel.borderEnabled ? clamp(sel.borderThickness, 0, 1) : 0;
if(!sel.borderEnabled || t <= 0){
cardEl.style.display = "none";
scheduleUiSafeUpdate();
return;
}
cardEl.style.display = "block";
cardEl.style.background = colorHex;

const rect = phraseInkBounds() || phraseEl.getBoundingClientRect();
if(rect.width <= 0 || rect.height <= 0){
cardEl.style.display = "none";
scheduleUiSafeUpdate();
return;
}

const { w: vw, h: vh } = getViewportSize();
const tAdj = Math.pow(t, 1.6);

// Add a small base padding so the card doesn't feel cramped when hugging the ink.
const fontPx = parseFloat(getComputedStyle(phraseEl).fontSize) || 0;
const basePadX = clamp(fontPx * 0.40, 14, 36);
const basePadY = clamp(fontPx * 0.26, 10, 28);

const maxPadL = Math.max(0, rect.left);
const maxPadR = Math.max(0, vw - rect.right);
const maxPadT = Math.max(0, rect.top);
const maxPadB = Math.max(0, vh - rect.bottom);

// Keep the phrase centered inside the card as it grows: symmetric padding on each axis.
const maxSymPadX = Math.min(maxPadL, maxPadR);
const maxSymPadY = Math.min(maxPadT, maxPadB);

const padX = Math.min(maxSymPadX, basePadX + (maxSymPadX * tAdj));
const padY = Math.min(maxSymPadY, basePadY + (maxSymPadY * tAdj));

cardEl.style.transform = "none";
cardEl.style.left = `${Math.round(rect.left - padX)}px`;
cardEl.style.top = `${Math.round(rect.top - padY)}px`;
cardEl.style.width = `${Math.ceil(rect.width + (padX * 2))}px`;
cardEl.style.height = `${Math.ceil(rect.height + (padY * 2))}px`;
scheduleUiSafeUpdate();
}

function pctLabel(x){ return `${Math.round(clamp(Number(x),0,1)*100)}%`; }

/* ================= Speed mapping ================= */
const SPEED_MIN_S = 0.01;
const SPEED_MAX_S = 600;

function speedFromSlider(t){
t = clamp(Number(t), 0, 1);
const ratio = SPEED_MAX_S / SPEED_MIN_S;
return SPEED_MIN_S * Math.pow(ratio, t);
}
function formatDuration(seconds){
if(seconds < 0.1) return `${Math.round(seconds*1000)}ms`;
if(seconds < 1) return `${seconds.toFixed(2)}s`;
if(seconds < 60) return `${seconds.toFixed(seconds < 10 ? 2 : 1)}s`;
const m = seconds / 60;
if(m < 10) return `${m.toFixed(2)}m`;
return `${m.toFixed(1)}m`;
}

/* ================= Visual apply ================= */
function applyColorsLive(){
const bg = applyDimmer(current.bgBase, Number(bgBrightEl.value));
current.bgLive = bg;
let fg = applyDimmer(current.fgBase, Number(fgBrightEl.value));
let bd = applyDimmer(current.bdBase, Number(bdBrightEl.value));

if(!isCompositionLocked){
if(bg.toLowerCase() === fg.toLowerCase()){
const alt = pickColorNonRepeating("fg", sel.fgColor, new Set([current.bgBase]));
if(alt) current.fgBase = alt;
fg = applyDimmer(current.fgBase, Number(fgBrightEl.value));
}
if(bd.toLowerCase() === bg.toLowerCase()){
const altB = pickColorNonRepeating("bd", sel.bdColor, new Set([current.bgBase, current.fgBase]));
if(altB) current.bdBase = altB;
bd = applyDimmer(current.bdBase, Number(bdBrightEl.value));
}
}

document.body.style.background = bg;
phraseEl.style.color = fg;
current.fgLive = fg;
current.bdLive = bd;

applyCardStyle(bd);
syncMenuToggleColor(bd, fg);

// Update UI accents (swatches, buttons, slider dots) after background is applied.
applyAccentColors();

bgBrightVal.textContent = pctLabel(bgBrightEl.value);
fgBrightVal.textContent = pctLabel(fgBrightEl.value);
bdBrightVal.textContent = pctLabel(bdBrightEl.value);
bdThickVal.textContent = `${Math.round(clamp(sel.borderThickness,0,1)*100)}%`;
}

/* ================= Border toggle button sync ================= */
function setBorderBtn(){
bdToggleBtn.textContent = sel.borderEnabled ? "on" : "off";
bdToggleBtn.classList.toggle("on", sel.borderEnabled);
bdToggleBtn.setAttribute("aria-pressed", sel.borderEnabled ? "true" : "false");
}

/* ================= Fullscreen helpers ================= */
const fsApi = {
request: document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen || document.documentElement.msRequestFullscreen,
exit: document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen
};
function isFullscreen(){
return !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
}
function syncFullscreenBtn(){
if(!fsApi.request || !fsApi.exit){
fsBtn.classList.add("disabled");
fsBtn.setAttribute("aria-disabled", "true");
return;
}
fsBtn.classList.remove("disabled");
fsBtn.removeAttribute("aria-disabled");
const on = isFullscreen();
fsBtn.textContent = "full screen";
fsBtn.classList.toggle("on", on);
fsBtn.setAttribute("aria-pressed", on ? "true" : "false");
}

/* ================= Tick loop ================= */
function scheduleTick(){
if(isPaused) return;
if(timerId) clearTimeout(timerId);
const seconds = speedFromSlider(speedEl.value);
speedVal.textContent = formatDuration(seconds);
timerId = setTimeout(()=>{
nextFrame();
scheduleTick();
}, Math.max(10, Math.round(seconds*1000)));
}

/* ================= Frame generation ================= */
function nextFrame(){
const prevColorKey = colorComboKey(current.bgBase, current.fgBase, current.bdBase);
let p = buildPhrase(sel.parts);

current.phrase = p;
phraseEl.innerHTML = formatPhraseText(current.phrase);
last.phrase = current.phrase;

smartPhraseWidth();

const wasFirst = isFirstFrame;
if(isFirstFrame){
isFirstFrame = false;
}else if(!isCompositionLocked){
let combo = pickNextColorCombo();
if(colorComboKey(combo.bgBase, combo.fgBase, combo.bdBase) === prevColorKey){
// Hard guard against accidental back-to-back repeats.
combo = pickNextColorCombo();
}
current.bgBase = combo.bgBase || current.bgBase;
current.fgBase = combo.fgBase || current.fgBase;
current.bdBase = combo.bdBase || current.bdBase;
}

if(!isCompositionLocked && !wasFirst){
advancePaletteCycle();
}

last.bg = current.bgBase;
last.fg = current.fgBase;
last.bd = current.bdBase;

applyColorsLive();
centerPoemMidpointIfMobile();
commitGeneratedScene();
}

/* ================= UI fade/auto-hide ================= */
let hideTimer = null;
const UI_HIDE_MS = 5000;
let menuFadeTimer = null;
const MENU_PEEK_MS = 5000;
function setMenuToggleState(open){
if(!menuToggleBtn) return;
menuToggleBtn.classList.toggle("on", !!open);
menuToggleBtn.setAttribute("aria-pressed", open ? "true" : "false");
if(open){
menuToggleBtn.setAttribute("data-tip", "turn off");
}else{
menuToggleBtn.removeAttribute("data-tip");
}
}
function scheduleMenuFade(){
if(!menuToggleBtn) return;
if(menuFadeTimer) clearTimeout(menuFadeTimer);
menuFadeTimer = setTimeout(()=>{
menuFadeTimer = null;
if(!menuToggleBtn.classList.contains("on")){
menuToggleBtn.classList.remove("show");
}
}, MENU_PEEK_MS);
}
function showMenuToggleBriefly(){
if(!menuToggleBtn) return;
menuToggleBtn.classList.add("show");
scheduleMenuFade();
}
function scheduleHideUI(){
if(hideTimer) clearTimeout(hideTimer);
hideTimer = setTimeout(()=> hideUI(), UI_HIDE_MS);
}
function showUI(){
uiWrapEl.classList.remove("hidden");
setMenuToggleState(true);
if(menuFadeTimer) clearTimeout(menuFadeTimer);
menuFadeTimer = null;
if(menuToggleBtn) menuToggleBtn.classList.add("show");
syncMenuTogglePosition();
scheduleUiSafeUpdate();
scheduleHideUI();
}
function hideUI(showMenuPeek = true){
if(hideTimer) clearTimeout(hideTimer);
hideTimer = null;
// Closing the UI always returns to the submenu layer (no slider/swatch page left open).
if(uiPage !== "none"){
setUiPage("none");
}
uiWrapEl.classList.add("hidden");
setMenuToggleState(false);
if(showMenuPeek){
showMenuToggleBriefly();
}else if(menuToggleBtn){
if(menuFadeTimer) clearTimeout(menuFadeTimer);
menuFadeTimer = null;
menuToggleBtn.classList.remove("show");
}
}
function toggleUI(){
if(uiWrapEl.classList.contains("hidden")){
showUI();
}else{
hideUI(false);
}
}
function wakeMenuIfUiHidden(){
if(!uiWrapEl.classList.contains("hidden")) return;
showMenuToggleBriefly();
}
function keepUiAliveWhileMoving(){
if(uiWrapEl.classList.contains("hidden")) return;
scheduleHideUI();
}

/* ================= Events ================= */
// Safari sometimes fails to re-apply :hover styles immediately after a click when classes toggle.
// This adds a tiny "forceHover" class while the pointer is over the button to keep hover fills consistent.
(function initForceHoverFix(){
if(!window.matchMedia) return;
const canHover = window.matchMedia("(hover: hover) and (pointer: fine)").matches;
if(!canHover) return;

document.addEventListener("pointerdown", (e)=>{
const btn = e.target && e.target.closest ? e.target.closest("button") : null;
if(!btn) return;
btn.classList.add("forceHover");

const clear = ()=> btn.classList.remove("forceHover");
btn.addEventListener("mouseleave", clear, {once:true});
btn.addEventListener("pointercancel", clear, {once:true});
}, true);
})();

window.addEventListener("pointerdown", onScenePointerDown, {passive:false});
window.addEventListener("pointermove", onScenePointerMove, {passive:false});
window.addEventListener("pointerup", onScenePointerEnd, {passive:false});
window.addEventListener("pointercancel", onScenePointerEnd, {passive:false});
window.addEventListener("mousemove", wakeMenuIfUiHidden, {passive:true});
window.addEventListener("touchstart", wakeMenuIfUiHidden, {passive:true});
window.addEventListener("mousemove", keepUiAliveWhileMoving, {passive:true});
window.addEventListener("pointermove", keepUiAliveWhileMoving, {passive:true});
window.addEventListener("touchmove", keepUiAliveWhileMoving, {passive:true});

dockControlBtns.forEach((btn)=>{
btn.addEventListener("pointerenter", ()=>{
dockHoverBtnId = btn.id;
applyDockConstellationState();
});
btn.addEventListener("pointerleave", ()=>{
if(dockHoverBtnId === btn.id){
dockHoverBtnId = "";
applyDockConstellationState();
}
});
btn.addEventListener("focus", ()=>{
dockHoverBtnId = btn.id;
applyDockConstellationState();
});
btn.addEventListener("blur", ()=>{
if(dockHoverBtnId === btn.id){
dockHoverBtnId = "";
applyDockConstellationState();
}
});
});
if(menuToggleBtn){
menuToggleBtn.addEventListener("pointerenter", ()=>{
dockHoverBtnId = "menuToggleBtn";
applyDockConstellationState();
});
menuToggleBtn.addEventListener("pointerleave", ()=>{
if(dockHoverBtnId === "menuToggleBtn"){
dockHoverBtnId = "";
applyDockConstellationState();
}
});
menuToggleBtn.addEventListener("focus", ()=>{
dockHoverBtnId = "menuToggleBtn";
applyDockConstellationState();
});
menuToggleBtn.addEventListener("blur", ()=>{
if(dockHoverBtnId === "menuToggleBtn"){
dockHoverBtnId = "";
applyDockConstellationState();
}
});
}

speedEl.addEventListener("input", ()=>{ scheduleTick(); showUI(); });
bgBrightEl.addEventListener("input", ()=>{ applyColorsLive(); showUI(); });
fgBrightEl.addEventListener("input", ()=>{ applyColorsLive(); showUI(); });
bdBrightEl.addEventListener("input", ()=>{ applyColorsLive(); showUI(); });

bdThickEl.addEventListener("input", ()=>{
sel.borderThickness = clamp(Number(bdThickEl.value), 0, 1);
applyColorsLive();
showUI();
});

sizeEl.addEventListener("input", ()=>{ applyTypeAndLayout(); showUI(); });
yEl.addEventListener("input", ()=>{ applyTypeAndLayout(); applyColorsLive(); showUI(); });
widthEl.addEventListener("input", ()=>{
phraseEl.textContent = current.phrase;
applyTypeAndLayout();
showUI();
});

bdToggleBtn.addEventListener("click", ()=>{
sel.borderEnabled = !sel.borderEnabled;
setBorderBtn();
applyColorsLive();
showUI();
});

fsBtn.addEventListener("click", async ()=>{
setDockActiveButton("fsBtn");
try{
if(!fsApi.request || !fsApi.exit) return;
if(fsBtn.classList.contains("disabled")) return;
if(!isFullscreen()) await fsApi.request.call(document.documentElement);
else await fsApi.exit.call(document);
}catch(e){}
syncFullscreenBtn();
showUI();
});

document.addEventListener("fullscreenchange", syncFullscreenBtn);
document.addEventListener("webkitfullscreenchange", syncFullscreenBtn);

if(prevPoemBtn) prevPoemBtn.addEventListener("click", ()=>{ setDockActiveButton("dockPlayback"); goPrevPoem(); showUI(); });
if(pausePoemBtn) pausePoemBtn.addEventListener("click", ()=>{ setDockActiveButton("dockPlayback"); togglePaused(); showUI(); });
if(nextPoemBtn) nextPoemBtn.addEventListener("click", ()=>{ setDockActiveButton("dockPlayback"); goNextPoem(); showUI(); });
if(screenshotBtn) screenshotBtn.addEventListener("click", ()=>{ setDockActiveButton("screenshotBtn"); snapScreenshot(); showUI(); });
if(lockCompositionBtn) lockCompositionBtn.addEventListener("click", ()=>{ setDockActiveButton("lockCompositionBtn"); toggleCompositionLock(); showUI(); });
if(menuToggleBtn) menuToggleBtn.addEventListener("click", ()=>{ setDockActiveButton("menuToggleBtn"); toggleUI(); });
if(tabLanguageBtn) tabLanguageBtn.addEventListener("click", (e)=>{ applyDockClickResponse(e); setDockActiveButton("tabLanguageBtn"); setUiPage("language"); showUI(); });
if(tabInfoBtn) tabInfoBtn.addEventListener("click", (e)=>{ applyDockClickResponse(e); setDockActiveButton("tabInfoBtn"); setUiPage("info"); showUI(); });
if(tabContrastBtn) tabContrastBtn.addEventListener("click", (e)=>{ applyDockClickResponse(e); setDockActiveButton("tabContrastBtn"); setUiPage("contrast"); showUI(); });
if(tabColorsBtn) tabColorsBtn.addEventListener("click", (e)=>{ applyDockClickResponse(e); setDockActiveButton("tabColorsBtn"); setUiPage("colors"); showUI(); });
if(tabSpeedBtn) tabSpeedBtn.addEventListener("click", (e)=>{ applyDockClickResponse(e); setDockActiveButton("tabSpeedBtn"); setUiPage("speed"); showUI(); });
if(scopeBgBtn) scopeBgBtn.addEventListener("click", ()=>{ setColorScope("bg"); showUI(); });
if(scopeFgBtn) scopeFgBtn.addEventListener("click", ()=>{ setColorScope("fg"); showUI(); });
if(scopeBdBtn) scopeBdBtn.addEventListener("click", ()=>{ setColorScope("bd"); showUI(); });
if(allOnBtn) allOnBtn.addEventListener("click", ()=>{ setCurrentScopeAll(true); showUI(); });
if(allOffBtn) allOffBtn.addEventListener("click", ()=>{ setCurrentScopeAll(false); showUI(); });

window.addEventListener("keydown", (e)=>{
if(e.repeat) return;
const t = e.target;
const tag = (t && t.tagName) ? String(t.tagName).toLowerCase() : "";
const isTypingTarget =
tag === "input" || tag === "textarea" || tag === "select" ||
(t && t.isContentEditable);
if(isTypingTarget) return;

if(e.code === "Space"){
e.preventDefault();
setDockActiveButton("dockPlayback");
togglePaused();
showUI();
return;
}
if(e.code === "ArrowLeft" || e.code === "ArrowUp"){
e.preventDefault();
setDockActiveButton("dockPlayback");
goPrevPoem();
showUI();
return;
}
if(e.code === "ArrowRight" || e.code === "ArrowDown"){
e.preventDefault();
setDockActiveButton("dockPlayback");
goNextPoem();
showUI();
return;
}
if(e.code === "KeyS"){
e.preventDefault();
snapScreenshot();
showUI();
return;
}
});

/* ================= Start ================= */
(function init(){
setViewportVars();
document.documentElement.style.setProperty("--sceneZoom", "1");
if(window.visualViewport){
window.visualViewport.addEventListener("resize", setViewportVars, {passive:true});
window.visualViewport.addEventListener("scroll", setViewportVars, {passive:true});
}

placeDockForViewport();
// Start collapsed with submenu buttons visible and no adjustment panel open.
setUiPage("none");

loadRecentPhrases();
loadRecentColorCombos();

initPaletteCycles();
renderSentenceButtons();

renderAllSwatches();
applyAccentColors();
syncSwatchHeaderWidths();

sel.borderEnabled = true;
sel.borderThickness = clamp(Number(bdThickEl.value), 0, 1);

setBorderBtn();
applyIosPortraitLoadSizing();
applyMobileViewerDefaults();
applyTypeAndLayout();

bgBrightVal.textContent = pctLabel(bgBrightEl.value);
fgBrightVal.textContent = pctLabel(fgBrightEl.value);
bdBrightVal.textContent = pctLabel(bdBrightEl.value);
bdThickVal.textContent = `${Math.round(clamp(sel.borderThickness,0,1)*100)}%`;
speedVal.textContent = formatDuration(speedFromSlider(speedEl.value));
sizeVal.textContent = `${Math.round(clamp(Number(sizeEl.value),0,150))}%`;

syncFullscreenBtn();
syncPauseBtn();
syncCompositionLockBtn();
setCalmStart();
const isCoarse = window.matchMedia("(pointer: coarse)").matches;
if(isCoarse){
bdThickEl.value = "0.30";
sel.borderThickness = 0.30;
}
nextFrame();
// Sync button colors with the live scene.
assignMobileTabColors();
scheduleTick();
hideUI();
})();

window.addEventListener("resize", ()=>{
setViewportVars();
placeDockForViewport();
syncMenuTogglePosition();
applyMobileViewerDefaults();
applyTypeAndLayout();
applyColorsLive();
syncSwatchHeaderWidths();
applyCardStyle(applyDimmer(current.bdBase, Number(bdBrightEl.value)));
});
</script>
</body>
</html>

